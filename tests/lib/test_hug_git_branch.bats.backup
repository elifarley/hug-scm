#!/usr/bin/env bats
# Tests for hug-git-branch library: branch selection and filtering functions

load '../test_helper'
load '../../git-config/lib/hug-common'
load '../../git-config/lib/hug-git-branch'

setup() {
  require_hug
  export HUG_HOME="$BATS_TEST_DIRNAME/../.."
  # Create test repository with branches
  TEST_REPO=$(create_test_repo_with_branches)
  cd "$TEST_REPO"
}

teardown() {
  cd /
  cleanup_test_repo "$TEST_REPO"
}

@test "filter_branches: excludes current branch when requested" {
  # Create test data
  local -a test_branches=("main" "feature-1" "feature-2" "bugfix")
  local -a test_hashes=("abc123" "def456" "ghi789" "jkl012")
  local -a test_subjects=("Initial" "Feature" "More work" "Fix")
  local -a test_tracks=("[origin/main]" "" "" "")

  # Test filtering with current branch exclusion
  local -a filtered_branches=() filtered_hashes=() filtered_subjects=() filtered_tracks=()
  filter_branches test_branches test_hashes test_subjects test_tracks "main" \
      filtered_branches filtered_hashes filtered_subjects filtered_tracks \
      "true" "false" ""

  # Should exclude "main" (current branch)
  [[ ${#filtered_branches[@]} -eq 3 ]]
  [[ "${filtered_branches[0]}" == "feature-1" ]]
  [[ "${filtered_branches[1]}" == "feature-2" ]]
  [[ "${filtered_branches[2]}" == "bugfix" ]]
}

@test "filter_branches: excludes backup branches when requested" {
  # Create test data with backup branches
  local -a test_branches=("main" "feature-1" "hug-backups/test" "hug-backups/old-feature")
  local -a test_hashes=("abc123" "def456" "backup1" "backup2")
  local -a test_subjects=("Initial" "Feature" "Backup" "Old backup")
  local -a test_tracks=("[origin/main]" "" "" "")

  # Test filtering with backup branch exclusion
  local -a filtered_branches=() filtered_hashes=() filtered_subjects=() filtered_tracks=()
  filter_branches test_branches test_hashes test_subjects test_tracks "main" \
      filtered_branches filtered_hashes filtered_subjects filtered_tracks \
      "false" "true" ""

  # Should exclude backup branches
  [[ ${#filtered_branches[@]} -eq 2 ]]
  [[ "${filtered_branches[0]}" == "main" ]]
  [[ "${filtered_branches[1]}" == "feature-1" ]]
}

@test "filter_branches: applies custom filter function" {
  # Create test data
  local -a test_branches=("main" "feature-1" "feature-2" "bugfix")
  local -a test_hashes=("abc123" "def456" "ghi789" "jkl012")
  local -a test_subjects=("Initial" "Feature" "More work" "Fix")
  local -a test_tracks=("[origin/main]" "" "" "")

  # Define custom filter function (only allow branches starting with "feature")
  feature_filter() {
    local branch="$1"
    [[ "$branch" == feature-* ]]
  }

  # Test filtering with custom filter
  local -a filtered_branches=() filtered_hashes=() filtered_subjects=() filtered_tracks=()
  filter_branches test_branches test_hashes test_subjects test_tracks "main" \
      filtered_branches filtered_hashes filtered_subjects filtered_tracks \
      "false" "false" "feature_filter"

  # Should only include feature branches
  [[ ${#filtered_branches[@]} -eq 2 ]]
  [[ "${filtered_branches[0]}" == "feature-1" ]]
  [[ "${filtered_branches[1]}" == "feature-2" ]]
}

@test "filter_branches: handles empty input gracefully" {
  # Create empty test data
  local -a test_branches=()
  local -a test_hashes=()
  local -a test_subjects=()
  local -a test_tracks=()

  # Test filtering with empty input
  local -a filtered_branches=() filtered_hashes=() filtered_subjects=() filtered_tracks=()
  filter_branches test_branches test_hashes test_subjects test_tracks "" \
      filtered_branches filtered_hashes filtered_subjects filtered_tracks \
      "true" "true" ""

  # Should return empty arrays
  [[ ${#filtered_branches[@]} -eq 0 ]]
  [[ ${#filtered_hashes[@]} -eq 0 ]]
}

@test "single_select_branch: returns success for valid selection" {
  # Skip this test if we can't provide input for interactive selection
  skip "Interactive test - requires user input simulation"
}

@test "multi_select_branches: formats options correctly" {
  # Create test data
  local -a test_branches=("main" "feature-1" "feature-2")
  local -a test_hashes=("abc123" "def456" "ghi789")
  local -a test_subjects=("Initial commit" "Add feature" "More work")
  local -a test_tracks=("[origin/main]" "[origin/feature-1]" "")

  # Test formatting (we can't test the interactive part easily)
  # But we can verify the function exists and is callable
  declare -F multi_select_branches >/dev/null
}

@test "select_branches: validates input parameters" {
  # Test with missing result array parameter
  run select_branches
  [[ $status -eq 1 ]]

  # Test with invalid option
  run select_branches result_array --invalid-option
  [[ $status -eq 1 ]]
}

@test "select_branches: handles no available branches" {
  # Create a mock scenario where no branches are available
  # This test verifies error handling
  declare -a selected_branches=()

  # Mock compute_local_branch_details to return no branches
  compute_local_branch_details() { return 1; }

  run select_branches selected_branches
  [[ $status -eq 1 ]]
  [[ $output == *"No local branches found"* ]]
}

@test "select_branches: integrates with compute_local_branch_details" {
  # This is an integration test to verify the function chain works
  # We'll test the option parsing and basic setup without interactive selection
  declare -a selected_branches=()

  # Test option parsing
  # We can't easily test interactive selection, but we can verify
  # the function is callable and parses options correctly
  run select_branches selected_branches --exclude-current --exclude-backup
  # This should fail because no interactive input is provided, but
  # the function should have parsed the options correctly
  [[ $status -eq 1 ]]
}

@test "select_branches: supports all option combinations" {
  declare -a selected_branches=()

  # Test include-current option
  run select_branches selected_branches --include-current
  [[ $status -eq 1 ]]

  # Test include-backup option
  run select_branches selected_branches --include-backup
  [[ $status -eq 1 ]]

  # Test custom placeholder
  run select_branches selected_branches --placeholder "Custom prompt"
  [[ $status -eq 1 ]]

  # Test multi-select option
  run select_branches selected_branches --multi-select
  [[ $status -eq 1 ]]

  # Test combination of options
  run select_branches selected_branches --include-current --multi-select --placeholder "Select multiple"
  [[ $status -eq 1 ]]
}

@test "filter_branches: maintains array order" {
  # Create test data in specific order
  local -a test_branches=("zebra" "alpha" "beta" "gamma")
  local -a test_hashes=("z123" "a456" "b789" "c012")
  local -a test_subjects=("Zebra" "Alpha" "Beta" "Gamma")
  local -a test_tracks=("" "" "" "")

  # Test filtering (no exclusions)
  local -a filtered_branches=() filtered_hashes=() filtered_subjects=() filtered_tracks=()
  filter_branches test_branches test_hashes test_subjects test_tracks "" \
      filtered_branches filtered_hashes filtered_subjects filtered_tracks \
      "false" "false" ""

  # Should maintain original order
  [[ ${#filtered_branches[@]} -eq 4 ]]
  [[ "${filtered_branches[0]}" == "zebra" ]]
  [[ "${filtered_branches[1]}" == "alpha" ]]
  [[ "${filtered_branches[2]}" == "beta" ]]
  [[ "${filtered_branches[3]}" == "gamma" ]]
}

@test "filter_branches: handles all filter combinations" {
  # Create comprehensive test data
  local -a test_branches=("main" "feature-1" "hug-backups/test" "feature-2" "bugfix")
  local -a test_hashes=("abc123" "def456" "backup1" "ghi789" "jkl012")
  local -a test_subjects=("Initial" "Feature" "Backup" "More work" "Fix")
  local -a test_tracks=("[origin/main]" "" "" "[origin/feature-2]" "")

  # Test exclude current only
  local -a filtered_branches=() filtered_hashes=() filtered_subjects=() filtered_tracks=()
  filter_branches test_branches test_hashes test_subjects test_tracks "main" \
      filtered_branches filtered_hashes filtered_subjects filtered_tracks \
      "true" "false" ""
  [[ ${#filtered_branches[@]} -eq 4 ]]
  # Should exclude "main" but include backup branches

  # Test exclude backup only
  filtered_branches=() filtered_hashes=() filtered_subjects=() filtered_tracks=()
  filter_branches test_branches test_hashes test_subjects test_tracks "main" \
      filtered_branches filtered_hashes filtered_subjects filtered_tracks \
      "false" "true" ""
  [[ ${#filtered_branches[@]} -eq 4 ]]
  # Should exclude "hug-backups/test" but include main

  # Test exclude both
  filtered_branches=() filtered_hashes=() filtered_subjects=() filtered_tracks=()
  filter_branches test_branches test_hashes test_subjects test_tracks "main" \
      filtered_branches filtered_hashes filtered_subjects filtered_tracks \
      "true" "true" ""
  [[ ${#filtered_branches[@]} -eq 3 ]]
  # Should exclude both "main" and "hug-backups/test"
}

# -----------------------------------------------------------------------------
# Critical tests for overlapping array names (the exact bug scenario)
# -----------------------------------------------------------------------------

@test "filter_branches: handles overlapping input/output array names safely" {
  # This test reproduces the exact bug scenario from hug bdel
  # where input and output array names overlapped, causing unbound variable errors

  # Create test data
  local -a test_branches=("main" "feature-1" "feature-2" "hug-backups/test")
  local -a test_hashes=("abc123" "def456" "ghi789" "backup1");
  local -a test_subjects=("Initial" "Feature" "More work" "Backup")
  local -a test_tracks=("[origin/main]" "" "" "")

  # Test the BUGGY pattern that causes unbound variable error
  # This should FAIL before the fix, and PASS after the fix
  run bash -c '
    source git-config/lib/hug-git-branch

    # Create test data
    local -a available_branches=("main" "feature-1" "feature-2" "hug-backups/test")
    local -a available_hashes=("abc123" "def456" "ghi789" "backup1")
    local -a available_subjects=("Initial" "Feature" "More work" "Backup")
    local -a available_tracks=("[origin/main]" "" "" "")

    # This is the BUGGY pattern from the original git-bdel code
    # Reusing input arrays as output arrays causes unbound variable error
    local -a filtered_branches=()
    filter_branches available_branches available_hashes available_subjects available_tracks "main" \
        filtered_branches available_hashes available_subjects available_tracks \
        "true" "true" ""
  '

  # Before the fix, this would fail with "unbound variable" error
  # After the fix, this should succeed (returns 0)
  assert_success
}

@test "filter_branches: doesn't corrupt input arrays during filtering" {
  # Test that input arrays remain intact after filtering
  # This was a side effect of the bug - input arrays could be corrupted

  # Create original test data
  local -a original_branches=("main" "feature-1" "feature-2" "hug-backups/test-backup")
  local -a original_hashes=("abc123" "def456" "ghi789" "backup1")
  local -a original_subjects=("Initial" "Feature" "More work" "Backup")
  local -a original_tracks=("[origin/main]" "" "" "")

  # Make copies for testing
  local -a test_branches=("${original_branches[@]}")
  local -a test_hashes=("${original_hashes[@]}")
  local -a test_subjects=("${original_subjects[@]}")
  local -a test_tracks=("${original_tracks[@]}")

  # Perform filtering with SEPARATE output arrays (the correct way)
  local -a filtered_branches=() filtered_hashes=() filtered_subjects=() filtered_tracks=()
  filter_branches test_branches test_hashes test_subjects test_tracks "main" \
      filtered_branches filtered_hashes filtered_subjects filtered_tracks \
      "true" "true" ""

  # Verify input arrays are unchanged
  [[ ${#test_branches[@]} -eq ${#original_branches[@]} ]]
  [[ ${#test_hashes[@]} -eq ${#original_hashes[@]} ]]
  [[ ${#test_subjects[@]} -eq ${#original_subjects[@]} ]]
  [[ ${#test_tracks[@]} -eq ${#original_tracks[@]} ]]

  # Verify content is preserved
  for i in "${!original_branches[@]}"; do
    [[ "${test_branches[$i]}" == "${original_branches[$i]}" ]]
    [[ "${test_hashes[$i]}" == "${original_hashes[$i]}" ]]
    [[ "${test_subjects[$i]}" == "${original_subjects[$i]}" ]]
    [[ "${test_tracks[$i]}" == "${original_tracks[$i]}" ]]
  done

  # Verify filtering worked correctly
  [[ ${#filtered_branches[@]} -eq 2 ]]  # main + hug-backups/test-backup excluded
  [[ "${filtered_branches[0]}" == "feature-1" ]]
  [[ "${filtered_branches[1]}" == "feature-2" ]]
}

@test "filter_branches: integrates correctly with compute_local_branch_details" {
  # This test validates the exact integration path that was broken:
  # compute_local_branch_details → filter_branches → select_branches

  # Test the complete integration chain
  declare -a available_branches=() available_hashes=() available_subjects=() available_tracks=()
  local available_current_branch="" available_max_len=""

  # Step 1: Get real branch data from the test repo
  if compute_local_branch_details available_current_branch available_max_len available_hashes available_branches available_tracks available_subjects "true"; then
    # Should have found some branches in the test repo
    [[ ${#available_branches[@]} -gt 0 ]]
    [[ ${#available_hashes[@]} -gt 0 ]]

    # Step 2: Filter the data (this was where the bug occurred)
    # Use SEPARATE output arrays to avoid the bug
    declare -a filtered_branches=() filtered_hashes=() filtered_subjects=() filtered_tracks=()
    filter_branches available_branches available_hashes available_subjects available_tracks "$available_current_branch" \
        filtered_branches filtered_hashes filtered_subjects filtered_tracks \
        "true" "true" ""

    # Step 3: Verify filtering worked without errors
    # The bug would cause "unbound variable" error at this point
    [[ ${#filtered_branches[@]} -ge 0 ]]  # Should be 0 or more, never error

    # Verify arrays are properly synchronized
    [[ ${#filtered_branches[@]} -eq ${#filtered_hashes[@]} ]]
    [[ ${#filtered_hashes[@]} -eq ${#filtered_subjects[@]} ]]
    [[ ${#filtered_subjects[@]} -eq ${#filtered_tracks[@]} ]]
  else
    # If no branches found, that's also valid (empty repo)
    true
  fi
}

@test "select_branches: properly calls filter_branches with correct parameters" {
  # Test that select_branches calls filter_branches with the correct parameter pattern
  # This is an integration test to ensure the bug doesn't reoccur in higher-level functions

  declare -a selected_branches=()

  # Mock the interactive selection part to avoid requiring user input
  # We want to test that the filtering setup works correctly
  run bash -c '
    source git-config/lib/hug-git-branch

    # Mock compute_local_branch_details to return test data
    compute_local_branch_details() {
      local -n _current_branch_ref=$1 _max_len_ref=$2 _hashes_ref=$3 _branches_ref=$4 _tracks_ref=$5 _subjects_ref=$6
      _current_branch_ref="main"
      _max_len_ref="20"
      _hashes_ref=("abc123" "def456" "ghi789")
      _branches_ref=("main" "feature-1" "feature-2")
      _tracks_ref=("[origin/main]" "" "")
      _subjects_ref=("Initial" "Feature" "More work")
      return 0
    }

    # Mock the interactive selection to just return without selecting
    # This lets us test the filtering part
    export HUG_FORCE=true  # Skip confirmation

    # Call select_branches - this should internally call filter_branches correctly
    # If the bug exists, this will fail with "unbound variable" error
    select_branches selected_branches --exclude-current --exclude-backup 2>/dev/null
  '

  # The command should not crash with "unbound variable" error
  # It may fail due to mocked data, but should not have the unbound variable bug
  refute_output --partial "unbound variable"
}

@test "filter_branches: validates array parameter names are independent" {
  # Test that the function works correctly regardless of array names
  # This validates that the fix is robust and doesn't depend on specific naming

  # Create test data with different array names
  local -a input_branches=("branch1" "branch2" "branch3")
  local -a input_hashes=("hash1" "hash2" "hash3")
  local -a input_subjects=("subj1" "subj2" "subj3")
  local -a input_tracks=("track1" "track2" "track3")

  # Test with completely different output array names
  local -a output_branches=() output_hashes=() output_subjects=() output_tracks=()

  # This should work regardless of the specific array names used
  filter_branches input_branches input_hashes input_subjects input_tracks "branch1" \
      output_branches output_hashes output_subjects output_tracks \
      "true" "false" ""

  # Verify it worked correctly
  [[ ${#output_branches[@]} -eq 2 ]]
  [[ "${output_branches[0]}" == "branch2" ]]
  [[ "${output_branches[1]}" == "branch3" ]]
  [[ "${output_hashes[0]}" == "hash2" ]]
  [[ "${output_hashes[1]}" == "hash3" ]]
}
