#!/usr/bin/env bash
# Mock gum for testing
# This script simulates gum behavior for automated tests

# Standalone gum_available function to avoid circular dependency
gum_available() {
  # Check if gum is disabled
  if [[ "${HUG_DISABLE_GUM:-}" == "true" ]]; then
    return 1
  fi

  # In test mode, always report gum as available
  if [[ "${HUG_TEST_MODE:-}" == "true" ]]; then
    return 0
  fi

  # Check if gum command exists
  command -v gum >/dev/null 2>&1
}

# Standalone gum_log function to avoid library dependency
gum_log() {
  local prefix="$1"
  shift
  printf '%s %s\n' "$prefix" "$*"
}

# Handle different gum commands
case "$1" in
  filter)
    # For filter command, read all input lines and return selection
    mapfile -t lines
    
    # Check if we received any input
    if [ ${#lines[@]} -eq 0 ]; then
      # No input means no items to select
      exit 1
    fi
    
    # Check if HUG_TEST_GUM_SELECTION_INDEX is set
    # This allows tests to control which item is selected
    if [[ -n "${HUG_TEST_GUM_SELECTION_INDEX:-}" ]]; then
      idx="$HUG_TEST_GUM_SELECTION_INDEX"
      if [[ "$idx" =~ ^[0-9]+$ ]] && [ "$idx" -lt "${#lines[@]}" ]; then
        printf '%s\n' "${lines[$idx]}"
      else
        # Invalid index, return first line as fallback
        printf '%s\n' "${lines[0]}"
      fi
    else
      # Default: return first line
      printf '%s\n' "${lines[0]}"
    fi
    ;;
    
  confirm)
    # For confirm command, check if HUG_TEST_GUM_CONFIRM is set
    # If "yes", return 0; if "no", return 1; otherwise use real gum
    if [[ "${HUG_TEST_GUM_CONFIRM:-}" == "yes" ]]; then
      exit 0
    elif [[ "${HUG_TEST_GUM_CONFIRM:-}" == "no" ]]; then
      exit 1
    else
      # Fall back to real gum if available
      if gum_available; then
        command gum "$@"
      else
        # No real gum available, default to yes
        exit 0
      fi
    fi
    ;;
    
  log)
    # For log command, just pass through to real gum if available
    # Otherwise, use our standalone implementation
    if gum_available; then
      command gum "$@"
    else
      shift  # Remove 'log' argument
      # Simple implementation for testing
      local message="$*"
      if [[ -n "$message" ]]; then
        echo "$message"
      fi
    fi
    ;;

  input)
    # For input command, check if HUG_TEST_GUM_INPUT is set
    # Otherwise read from stdin or use default
    if [[ -n "${HUG_TEST_GUM_INPUT:-}" ]]; then
      printf '%s\n' "$HUG_TEST_GUM_INPUT"
      exit 0
    elif [[ -n "${HUG_TEST_GUM_INPUT_RETURN_CODE:-}" ]]; then
      # Allow tests to control return code (0=success, 1=cancelled)
      exit "$HUG_TEST_GUM_INPUT_RETURN_CODE"
    else
      # Read from stdin or provide default behavior
      if [[ -t 0 ]]; then
        # Interactive input available
        if read -r input; then
          printf '%s\n' "$input"
          exit 0
        else
          exit 1
        fi
      else
        # No interactive input, simulate cancellation
        exit 1
      fi
    fi
    ;;

  *)
    # For other commands, try to pass through to real gum
    if gum_available; then
      command gum "$@"
    else
      # No real gum, just exit successfully
      exit 0
    fi
    ;;
esac
