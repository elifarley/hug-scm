#!/usr/bin/env bash
# Mock gum for testing
# This script simulates gum behavior for automated tests

# Standalone gum_available function to avoid circular dependency
gum_available() {
  # Check if gum is disabled
  if [[ "${HUG_DISABLE_GUM:-}" == "true" ]]; then
    return 1
  fi

  # In test mode, always report gum as available
  if [[ "${HUG_TEST_MODE:-}" == "true" ]]; then
    return 0
  fi

  # Check if gum command exists
  command -v gum >/dev/null 2>&1
}

# Standalone gum_log function to avoid library dependency
gum_log() {
  local prefix="$1"
  shift
  printf '%s %s\n' "$prefix" "$*"
}

# Handle different gum commands
case "$1" in
  filter)
    # For filter command, read all input lines and return selection
    mapfile -t lines
    
    # Optional: simulate cancellation via test env
    if [[ -n "${HUG_TEST_GUM_INPUT_RETURN_CODE:-}" ]] && [ "${HUG_TEST_GUM_INPUT_RETURN_CODE}" -ne 0 ]; then
      exit "${HUG_TEST_GUM_INPUT_RETURN_CODE}"
    fi
    
    # Check if we received any input
    if [ ${#lines[@]} -eq 0 ]; then
      # No input means no items to select
      exit 1
    fi
    
    # Check if HUG_TEST_GUM_SELECTION_INDEX is set
    # This allows tests to control which item is selected
    if [[ -n "${HUG_TEST_GUM_SELECTION_INDEX:-}" ]]; then
      idx="$HUG_TEST_GUM_SELECTION_INDEX"
      if [[ "$idx" =~ ^[0-9]+$ ]] && [ "$idx" -lt "${#lines[@]}" ]; then
        printf '%s\n' "${lines[$idx]}"
      else
        # Invalid index, return first line as fallback
        printf '%s\n' "${lines[0]}"
      fi
    else
      # Default: return first line
      printf '%s\n' "${lines[0]}"
    fi
    # Ensure the mock terminates cleanly and does not linger
    exit 0
    ;;
    
  confirm)
    # For confirm command, check if HUG_TEST_GUM_CONFIRM is set
    # If "yes", return 0; if "no", return 1; otherwise use real gum
    # 
    # IMPORTANT: gum confirm outputs the prompt message to stderr, so we must
    # echo it ourselves to ensure tests can verify the prompt appeared.
    # Parse the prompt from arguments (skipping flags like --default=false)
    local prompt_msg=""
    local skip_next=false
    for arg in "$@"; do
      if $skip_next; then
        skip_next=false
        continue
      fi
      case "$arg" in
        confirm) continue ;;
        --default=*) continue ;;
        --default) skip_next=true; continue ;;
        --affirmative=*) continue ;;
        --affirmative) skip_next=true; continue ;;
        --negative=*) continue ;;
        --negative) skip_next=true; continue ;;
        *) prompt_msg="$arg" ;;
      esac
    done
    
    # Output the prompt to stderr (like real gum confirm does)
    if [[ -n "$prompt_msg" ]]; then
      printf '%s ' "$prompt_msg" >&2
    fi
    
    if [[ "${HUG_TEST_GUM_CONFIRM:-}" == "yes" ]]; then
      exit 0
    elif [[ "${HUG_TEST_GUM_CONFIRM:-}" == "no" ]]; then
      exit 1
    else
      # Fall back to real gum if available (use full path to avoid recursion)
      if command -v /usr/bin/gum >/dev/null 2>&1 || command -v /usr/local/bin/gum >/dev/null 2>&1; then
        # Find real gum (not the mock)
        real_gum=$(PATH="${PATH#*:}" command -v gum 2>/dev/null || echo "")
        if [[ -n "$real_gum" && "$real_gum" != "$0" ]]; then
          "$real_gum" "$@"
        else
          # No real gum found, default to yes
          exit 0
        fi
      else
        # No real gum available, default to yes
        exit 0
      fi
    fi
    ;;
    
  log)
    # For log command, just pass through to real gum if available
    # Otherwise, use our standalone implementation
    if command -v /usr/bin/gum >/dev/null 2>&1 || command -v /usr/local/bin/gum >/dev/null 2>&1; then
      # Find real gum (not the mock) 
      real_gum=$(PATH="${PATH#*:}" command -v gum 2>/dev/null || echo "")
      if [[ -n "$real_gum" && "$real_gum" != "$0" ]]; then
        "$real_gum" "$@"
      else
        shift  # Remove 'log' argument
        message="$*"
        if [[ -n "$message" ]]; then
          echo "$message"
        fi
      fi
    else
      shift  # Remove 'log' argument
      # Simple implementation for testing
      message="$*"
      if [[ -n "$message" ]]; then
        echo "$message"
      fi
    fi
    ;;

  input)
    # For input command, check if HUG_TEST_GUM_INPUT is set
    # Otherwise read from stdin or use default
    if [[ -n "${HUG_TEST_GUM_INPUT:-}" ]]; then
      printf '%s\n' "$HUG_TEST_GUM_INPUT"
      exit 0
    elif [[ -n "${HUG_TEST_GUM_INPUT_RETURN_CODE:-}" ]]; then
      # Allow tests to control return code (0=success, 1=cancelled)
      exit "$HUG_TEST_GUM_INPUT_RETURN_CODE"
    else
      # Read from stdin or provide default behavior
      if [[ -t 0 ]]; then
        # Interactive input available
        if read -r input; then
          printf '%s\n' "$input"
          exit 0
        else
          exit 1
        fi
      else
        # No interactive input, simulate cancellation
        exit 1
      fi
    fi
    ;;

  *)
    # For other commands, try to pass through to real gum
    if command -v /usr/bin/gum >/dev/null 2>&1 || command -v /usr/local/bin/gum >/dev/null 2>&1; then
      # Find real gum (not the mock)
      real_gum=$(PATH="${PATH#*:}" command -v gum 2>/dev/null || echo "")
      if [[ -n "$real_gum" && "$real_gum" != "$0" ]]; then
        "$real_gum" "$@"
      else
        # No real gum, just exit successfully
        exit 0
      fi
    else
      # No real gum, just exit successfully
      exit 0
    fi
    ;;
esac
