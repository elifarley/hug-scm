# shellcheck shell=bash
# This file is a library to be sourced by shell scripts
#
# HUG-COMMON: Common utilities library
#
# This library provides general-purpose utility functions including:
# - Color definitions for terminal output
# - Output and user interaction functions (error, warning, info, success, prompts)
# - String manipulation utilities
# - Array manipulation utilities  
# - File system utilities
# - Command pattern helpers
#
# These functions are used across all hug commands for consistent
# user experience and error handling.

################################################################################
# Standard Command Script Header Pattern
################################################################################
#
# All hug command scripts should follow this standard pattern:
#
# #!/usr/bin/env bash
# CMD_BASE="$(readlink -f "$0" 2>/dev/null || greadlink -f "$0")" || CMD_BASE="$0"
# CMD_BASE="$(dirname "$CMD_BASE")"
# # shellcheck source=../lib/hug-common
# . "$CMD_BASE/../lib/hug-common"
# # shellcheck source=../lib/hug-git-kit
# . "$CMD_BASE/../lib/hug-git-kit"
# set -euo pipefail  # Exit on error, undefined vars, pipe failures
#
# This ensures:
# - Proper library path resolution (works with symlinks)
# - Sourcing of common functions
# - Strict error handling (fail fast on errors)
# - ShellCheck can follow the source directives
#
################################################################################

################################################################################
# Color Definitions
################################################################################
# Declared and assigned separately to avoid masking tput return values (SC2155)
# Exported so they can be used in sourced scripts without SC2034 warnings
RED=''
GREEN=''
GREEN_BRIGHT=''
YELLOW=''
YELLOW_BRIGHT=''
BLUE=''
MAGENTA=''
CYAN=''
GREY=''
NC=''

test -t 1 && {
  RED=$(tput setaf 1)
  GREEN=$(tput setaf 2)
  GREEN_BRIGHT=$(tput setaf 10)
  YELLOW=$(tput setaf 3)
  YELLOW_BRIGHT=$(tput setaf 11)
  BLUE=$(tput setaf 4)
  MAGENTA=$(tput setaf 5)
  CYAN=$(tput setaf 6)
  GREY=$(tput setaf 8)
  NC=$(tput sgr0) # No Color
}

readonly RED GREEN GREEN_BRIGHT YELLOW YELLOW_BRIGHT BLUE MAGENTA CYAN GREY NC
export RED GREEN GREEN_BRIGHT YELLOW YELLOW_BRIGHT BLUE MAGENTA CYAN GREY NC

################################################################################
# Gum Integration Helpers
################################################################################

gum_available() {
  # Check if gum is explicitly disabled via environment variable
  if [[ "${HUG_DISABLE_GUM:-}" == "true" ]]; then
    return 1
  fi
  # Check if gum command is available in PATH
  command -v gum >/dev/null 2>&1
}



# Advanced interactive file selection with multiple file types support
# Usage: select_files_with_status [OPTIONS]
# Options:
#   --multi              Allow multiple file selection (default: true)
#   --single             Single file selection (default: multi)
#   --staged             Include staged files
#   --unstaged           Include unstaged files
#   --untracked          Include untracked files
#   --ignored            Include ignored files
#   --no-status          Omit status column/formatting (plain file names)
#   --prompt <text>      Custom prompt text
# Output:
#   Selected file(s) to stdout, one per line
# Returns:
#   0 if files selected, 1 if cancelled or no selection
# Note:
#   Requires gum to be installed
# Defaults:
#   - Multi-selection enabled
#   - If no --staged/--unstaged/--untracked/--ignored provided, falls back to all tracked files via 'git ls-files' (displayed plainly)
select_files_with_status() {
  if ! gum_available; then
    error "Interactive file selection requires 'gum' to be installed.
Install: https://github.com/charmbracelet/gum"
  fi
  
  local multi=true
  local include_staged=false
  local include_unstaged=false
  local include_untracked=false
  local include_ignored=false
  local no_status=false
  local prompt="Select file(s)..."
  
  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --multi)
        multi=true
        shift
        ;;
      --single)
        multi=false
        shift
        ;;
      --staged)
        include_staged=true
        shift
        ;;
      --unstaged)
        include_unstaged=true
        shift
        ;;
      --untracked)
        include_untracked=true
        shift
        ;;
      --ignored)
        include_ignored=true
        shift
        ;;
      --no-status)
        no_status=true
        shift
        ;;
      --prompt)
        prompt="$2"
        shift 2
        ;;
      *)
        error "Unknown option for select_files_with_status: $1"
        ;;
    esac
  done
  
  local has_includes=false
  if $include_staged || $include_unstaged || $include_untracked || $include_ignored; then
    has_includes=true
  fi
  
  local use_status_formatting=false
  if $has_includes && ! $no_status; then
    use_status_formatting=true
  fi
  
  local -a files=()
  local -a formatted_options=()
  
  if ! $has_includes; then
    mapfile -t files < <(git ls-files 2>/dev/null || true)
    mapfile -t formatted_options < <(printf '%s\n' "${files[@]}")
  else
  
  # Collect files based on requested types
  if $include_staged; then
    while IFS= read -r file; do
      [[ -z "$file" ]] && continue
      local status
      status=$(git diff --cached --name-status "$file" 2>/dev/null | cut -f1 || echo "M")
      local status_text
      case "$status" in
        A)  status_text="${GREEN}S:Add ${NC}" ;;
        M)  status_text="${GREEN}S:${YELLOW}Mod ${NC}" ;;
        D)  status_text="${GREEN}S:${RED}Del ${NC}" ;;
        R*) status_text="${GREEN}S:${CYAN}Ren ${NC}" ;;
        C*) status_text="${GREEN}S:${BLUE}Copy${NC}" ;;
        *)  status_text="${GREEN}S     ${NC}" ;;
      esac
      files+=("$file")
      if $use_status_formatting; then
        formatted_options+=("${status_text} ${file}")
      else
        formatted_options+=("$file")
      fi
    done < <(git diff --cached --name-only 2>/dev/null || true)
  fi
  
  if $include_unstaged; then
    while IFS= read -r file; do
      [[ -z "$file" ]] && continue
      local status
      status=$(git diff --name-status "$file" 2>/dev/null | cut -f1 || echo "M")
      local status_text
      case "$status" in
        M) status_text="${RED}U:${YELLOW}Mod ${NC}" ;;
        D) status_text="${RED}U:Del ${NC}" ;;
        *) status_text="${RED}${NC}U     " ;;
      esac
      files+=("$file")
      if $use_status_formatting; then
        formatted_options+=("${status_text} ${file}")
      else
        formatted_options+=("$file")
      fi
    done < <(git diff --name-only 2>/dev/null || true)
  fi
  
  if $include_untracked; then
    while IFS= read -r -d '' entry; do
      [[ -z "$entry" ]] && continue
      local status="${entry:0:2}"
      local file="${entry:3}"
      if [[ "$status" == "??" ]]; then
        local status_text="${MAGENTA}UnTrck${NC}"
        files+=("$file")
        if $use_status_formatting; then
          formatted_options+=("${status_text} ${file}")
        else
          formatted_options+=("$file")
        fi
      fi
    done < <(git status --porcelain=v1 -z 2>/dev/null || true)
  fi
  
  if $include_ignored; then
    while IFS= read -r -d '' entry; do
      [[ -z "$entry" ]] && continue
      local status="${entry:0:2}"
      local file="${entry:3}"
      if [[ "$status" == "!!" ]]; then
        local status_text="${GREY}Ignore${NC}"
        files+=("$file")
        if $use_status_formatting; then
          formatted_options+=("${status_text} ${file}")
        else
          formatted_options+=("$file")
        fi
      fi
    done < <(git status --porcelain=v1 --ignored=matching -z 2>/dev/null || true)
  fi
  fi
  
  # Remove duplicates while preserving order
  local -A seen=()
  local -a unique_files=()
  local -a unique_formatted=()
  local i
  for i in "${!files[@]}"; do
    local file="${files[$i]}"
    if [[ -z "${seen[$file]+_}" ]]; then
      seen["$file"]=1
      unique_files+=("$file")
      unique_formatted+=("${formatted_options[$i]}")
    fi
  done
  
  if [[ ${#unique_files[@]} -eq 0 ]]; then
    return 1
  fi
  
  # Calculate height for gum
  local gum_height
  gum_height=$((${#unique_files[@]} < 13 ? ${#unique_files[@]} + 3 : 15))
  
  # Build gum command
  local -a gum_args=(
    "filter"
    "--no-strip-ansi"
    "--placeholder=$prompt"
    "--height=$gum_height"
    "--reverse"
  )
  
  if $multi; then
    gum_args+=("--no-limit")
  fi
  
  # Run gum and capture selection
  local selection
  selection=$(printf '%s\n' "${unique_formatted[@]}" | gum "${gum_args[@]}" || true)
  
  if [[ -z "$selection" ]]; then
    return 1
  fi
  
  # Extract file names from selection
  while IFS= read -r line; do
    [[ -z "$line" ]] && continue
    local file_name
    if $use_status_formatting; then
      file_name="${line#* }"
    else
      file_name="$line"
    fi
    printf '%s\n' "$file_name"
  done <<< "$selection"
  
  return 0
}

################################################################################
# Output and User Interaction Functions
################################################################################

# Prints an error message and exits the script
# Usage: error "message" [exit_code]
# Parameters:
#   $1 - Error message to display
#   $2 - (Optional) Exit code, defaults to 1
error() {
  gum_available && gum log -s --prefix=âŒ -l error "$@" || \
    printf "${RED}âŒ Error:${NC} %s\n" "$1" >&2
  exit "${2:-1}"
}

# Prints a warning message to stderr
# Usage: warning "message"
# Parameters:
#   $1 - Warning message to display
# Environment:
#   HUG_QUIET - If set, suppresses output
warning() {
  test "${HUG_QUIET:-}" && return
  gum_available && gum log -s --prefix=âš ï¸  -l warn "$@" || \
    printf "${YELLOW}âš ï¸  Warning:${NC} %s\n" "$1" >&2
}

# Alias for warning() function
# Usage: warn "message"
warn() { warning "$@"; }

# Prints an informational message to stderr
# Usage: info "message"
# Parameters:
#   $1 - Information message to display
# Environment:
#   HUG_QUIET - If set, suppresses output
info() {
  test "${HUG_QUIET:-}" && return
  gum_available && gum log -s --prefix=â„¹ï¸  -l info "$@" || \
    printf "${BLUE}â„¹ï¸  Info:${NC} %s\n" "$1" >&2
}

# Prints a tip message to stderr
# Usage: tip "message"
# Parameters:
#   $1 - Tip message to display
# Environment:
#   HUG_QUIET - If set, suppresses output
tip() {
  test "${HUG_QUIET:-}" && return
  printf "${CYAN}ðŸ’¡ Tip:${NC} %s\n" "$1" >&2
}

# Prints a success message to stderr
# Usage: success "message"
# Parameters:
#   $1 - Success message to display
# Environment:
#   HUG_QUIET - If set, suppresses output
success() {
  test "${HUG_QUIET:-}" && return
  printf "${GREEN}âœ… Success:${NC} %s\n" "$1" >&2
}

# Prompts user for confirmation, exits if not confirmed
# Usage: prompt_confirm ["custom prompt"]
# Parameters:
#   $1 - (Optional) Custom prompt text, defaults to "Proceed? [y/N]: "
# Environment:
#   HUG_FORCE - If true, automatically confirms without prompting
# Returns:
#   0 if confirmed (or HUG_FORCE is true)
#   Exits with code 1 if user declines or read fails
prompt_confirm() {
  if [[ ${HUG_FORCE:-} == true ]]; then
    return 0
  fi
  local prompt="${1:-Proceed? [y/N]: }"
  if gum_available; then
    local message="${prompt% }"
    if gum confirm "$message"; then
      return 0
    fi
    info "Cancelled."
    exit 1
  fi
  local response
  printf '%s' "$prompt" >&2
  if ! read -r response; then
    info "Cancelled."
    exit 1
  fi
  if [[ ! "$response" =~ ^[Yy]$ ]]; then
    info "Cancelled."
    exit 1
  fi
}

# Prints a standardized message when no changes are detected
# Usage: print_nothing_to_do "action" ["scope phrase"]
# Examples:
#   print_nothing_to_do "discard"
#   print_nothing_to_do "zap" "in the repository."
# The scope phrase should include any desired trailing punctuation.
print_nothing_to_do() {
  local action="$1"
  local scope="${2:-for the selected scope.}"
  info "Nothing to ${action}; repository already clean ${scope}"
}

# Prints an informational dry-run preview message (shared across commands)
# Usage: print_dry_run_preview "discarded" "from the specified paths."
print_dry_run_preview() {
  local action_phrase="$1"
  local scope="${2:-for the selected scope.}"
  info "Dry run: the following items would ${action_phrase} ${scope} (no changes applied)."
}

# Prints a warning preview message before executing a destructive action
# Usage: print_action_preview "discard the listed changes" "from the specified paths."
print_action_preview() {
  local action_phrase="$1"
  local scope="${2:-for the selected scope.}"
  warning "âš  About to ${action_phrase} ${scope} Review the list below."
}

################################################################################
# String Manipulation Functions
################################################################################

# Trims leading and trailing whitespace from a string
# Usage: result=$(trim_message "  text  ")
# Parameters:
#   $1 - String to trim
# Output:
#   Trimmed string to stdout
trim_message() {
  printf '%s' "$1" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//'
}

################################################################################
# Array Manipulation Functions
################################################################################

# Removes duplicate entries from an array in-place
# Usage: dedupe_array array_name
# Parameters:
#   $1 - Name of the array variable to deduplicate (nameref)
# Note:
#   Modifies the array in-place, preserving order of first occurrence
#   Empty strings are filtered out
dedupe_array() {
  local -n __array_ref=$1
  local -A __seen=()
  local -a __unique=()
  local item
  for item in "${__array_ref[@]}"; do
    [[ -z "$item" ]] && continue
    if [[ -z "${__seen[$item]+_}" ]]; then
      __seen["$item"]=1
      __unique+=("$item")
    fi
  done
  __array_ref=("${__unique[@]}")
}

# Prints a titled list of items
# Usage: print_list "Title" item1 item2 item3...
# Parameters:
#   $1 - Title for the list
#   $@ - Items to list (remaining arguments)
# Output:
#   Title with count, followed by indented items
print_list() {
  local title=$1
  shift
  printf '%s (%d):\n' "$title" "$#"
  local item
  for item in "$@"; do
    printf '  %s\n' "$item"
  done
}

################################################################################
# File System Utility Functions
################################################################################

# Checks if a local file path is a symlink
# Usage: if is_symlink "path/to/file"; then ...; fi
# Parameters:
#   $1 - Path to check
# Returns:
#   0 if path is a symbolic link, 1 otherwise
is_symlink() {
  local local_file="$1"
  [[ -L "$local_file" ]]
}

################################################################################
# Command Pattern Helpers
################################################################################

# Parses common option flags for command scripts
# Usage: eval "$(parse_common_flags "$@")"
# Recognizes flags:
#   --dry-run    Sets dry_run=true
#   -f, --force  Sets force=true, exports HUG_FORCE=true
#   --quiet      Exports HUG_QUIET=T
#   -h, --help   Calls usage or show_help function and exits
#   --           If last argument, sets HUG_INTERACTIVE_FILE_SELECTION=true and removes it
# Note:
#   Consumes recognized flags from arguments
#   Remaining args can be accessed via "$@" after eval
#   Handles empty remaining args without setting $@ to ("")
parse_common_flags() {
  local remaining_args=()
  local interactive_file_selection=false
  
  # Check if last argument is '--' before processing
  if [[ $# -gt 0 && "${!#}" = "--" ]]; then
    interactive_file_selection=true
    # Remove last argument by creating new array without it
    set -- "${@:1:$(($#-1))}"
  fi
  
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --dry-run)
        echo "dry_run=true"
        shift
        ;;
      -f|--force)
        echo "force=true"
        echo "export HUG_FORCE=true"
        shift
        ;;
      --quiet)
        echo "export HUG_QUIET=T"
        shift
        ;;
      -h|--help)
        echo "if declare -f show_help >/dev/null; then show_help; fi; exit 0"
        shift
        ;;
      --)
        shift
        remaining_args+=("$@")
        break
        ;;
      *)
        remaining_args+=("$1")
        shift
        ;;
    esac
  done
  
  # Export interactive file selection flag if detected
  if $interactive_file_selection; then
    echo "export HUG_INTERACTIVE_FILE_SELECTION=true"
  fi
  
  # Always output set -- to properly update $@ in the caller
  if [ ${#remaining_args[@]} -gt 0 ]; then
    printf 'set -- '
    printf '%q ' "${remaining_args[@]}"
    printf '\n'
  else
    printf 'set --\n'
  fi
}

# Validates minimum number of arguments
# Usage: require_args N ["error message"]
# Parameters:
#   $1 - Minimum number of arguments required
#   $2 - (Optional) Custom error message
# Environment:
#   Uses $# from caller's context
# Note:
#   This is meant to be called with: require_args N "$#" ["message"]
require_args() {
  local required="$1"
  local actual="$2"
  local message="${3:-this command requires at least $required argument(s)}"
  
  if [[ $actual -lt $required ]]; then
    error "$message"
  fi
}

# Confirms an action with a specific word
# Usage: confirm_action "action_word"
# Parameters:
#   $1 - Word that user must type to confirm
# Environment:
#   HUG_FORCE - If true, skips confirmation
# Returns:
#   0 if confirmed (or HUG_FORCE is true)
#   Exits with code 1 if user declines
confirm_action() {
  if [[ ${HUG_FORCE:-} == true ]]; then
    return 0
  fi

  local action="$1"
  if gum_available; then
    local gum_reply
    if ! gum_reply=$(gum input --prompt "â†’ " --placeholder "Type \"${action}\" to confirm" ); then
      info "Cancelled."
      exit 1
    fi
    gum_reply="$(trim_message "${gum_reply:-}")"
    if [[ "$gum_reply" == "$action" ]]; then
      return 0
    fi
    info "Cancelled."
    exit 1
  fi

  local reply
  printf 'Type "%s" to confirm: ' "$action" >&2
  if ! read -r reply; then
    info "Cancelled."
    exit 1
  fi
  if [[ "$reply" != "$action" ]]; then
    info "Cancelled."
    exit 1
  fi
}
