#!/b/bash
# shellcheck shell=dash
# This file is a library to be sourced by shell scripts

# Color codes for output
readonly RED=$(tput setaf 1)
readonly GREEN=$(tput setaf 2)
readonly GREEN_BRIGHT=$(tput setaf 10)
readonly YELLOW=$(tput setaf 3)
readonly YELLOW_BRIGHT=$(tput setaf 11)
readonly BLUE=$(tput setaf 4)
readonly MAGENTA=$(tput setaf 5)
readonly CYAN=$(tput setaf 6)
readonly GREY=$(tput setaf 8)
readonly NC=$(tput sgr0) # No Color

# Helper functions
error() {
  printf "${RED}❌ Error:${NC} %s\n" "$1" >&2
  exit "${2:-1}"
}

warning() {
    printf "${YELLOW}⚠️  Warning:${NC} %s\n" "$1" >&2
}

warn() { warning "$@"; }

info() {
    printf "${BLUE}ℹ️  Info:${NC} %s\n" "$1" >&2
}

success() {
    printf "${GREEN}✅ Success:${NC} %s\n" "$1" >&2
}

trim_message() {
  printf '%s' "$1" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//'
}

dedupe_array() {
  local -n __array_ref=$1
  local -A __seen=()
  local -a __unique=()
  local item
  for item in "${__array_ref[@]}"; do
    [[ -z "$item" ]] && continue
    if [[ -z "${__seen[$item]+_}" ]]; then
      __seen["$item"]=1
      __unique+=("$item")
    fi
  done
  __array_ref=("${__unique[@]}")
}

print_list() {
  local title=$1
  shift
  printf '%s (%d):\n' "$title" "$#"
  local item
  for item in "$@"; do
    printf '  %s\n' "$item"
  done
}

# Checks if a local file path is a symlink (returns true/false)
is_symlink() {
  local local_file="$1"
  [[ -L "$local_file" ]]
}
