#!/b/bash
# shellcheck shell=dash
# This file is a library to be sourced by shell scripts

# Check if we're in a git repository
check_git_repo() {
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        error "Not in a git repository"
    fi
    test "${GIT_PREFIX:-}" || GIT_PREFIX=$(git rev-parse --show-prefix 2>/dev/null || echo "")
}

# Validate commit exists
validate_commit() {
    local commit="$1"
    if ! git rev-parse --verify "$commit" >/dev/null 2>&1; then
        error "Commit '$commit' does not exist"
    fi
}

# Check if working tree is clean
check_working_tree_clean() {
    if ! git diff --quiet || ! git diff --cached --quiet; then
        local unstaged_count
        local staged_count
        unstaged_count=$(git diff --name-only | wc -l)
        staged_count=$(git diff --cached --name-only | wc -l)

        error "Working tree is not clean!
       Unstaged changes: $unstaged_count files
       Staged changes: $staged_count files

       Solutions:
       • Use 'git w-backup' to save changes first
       • Use 'git w-discard-all' to discard changes
       • Use 'git w-discard <file>' for specific files"
    fi
}

# Check file in target commit
check_file_in_commit() {
    local commit="$1"
    local file="$2"

    if ! git cat-file -e "$commit:$file" 2>/dev/null; then
        error "File '$file' does not exist in commit $commit"
    fi
}

# Preview changes for specific files
preview_file_changes() {
    local commit="$1"
    local file="$2"

    printf "─ %s ─\n" "$file" >&2
    if git diff --no-index -- "$file" <(git show "$commit:$file") 2>/dev/null | head -20 >&2; then
        printf "─ (showing first 20 lines) ─\n\n" >&2
    else
        printf "─ (binary file or no changes) ─\n\n" >&2
    fi
}

# Check file has staged changes
check_file_staged() {
    local file="$1"

    if ! git diff --cached --quiet "$file" 2>/dev/null; then
        error "File '$file' has staged changes
       Use 'git us $file' to unstage first"
    fi
}

# Check file has unstaged changes
check_file_unstaged() {
    local file="$1"

    if ! git diff --quiet "$file" 2>/dev/null; then
        error "File '$file' has unstaged changes
       Use 'git w-discard $file' to discard changes first"
    fi
}

# Detects if the staged changes for a file are binary (returns true/false)
is_binary_staged() {
  local file="$1"
  local added deleted
  local diff_numstat

  diff_numstat="$(git diff --cached --numstat -- "$file" 2>/dev/null || true)"
  if [[ -n $diff_numstat ]]; then
    IFS=$'\t' read -r added deleted _ <<<"$diff_numstat"
    [[ $added == "-" && $deleted == "-" ]]
  else
    false  # No staged changes, not binary
  fi
}

discard_all_unstaged() {
  local dry_run=false
  # Check for --dry-run flag (passed as first argument if present)
  if [[ "${1:-}" == "--dry-run" ]]; then
    dry_run=true
    shift  # Remove the flag
  fi

  # Ensure we're in a Git repo
  check_git_repo

  # Check if there are any unstaged changes (modified tracked files)
  local -a affected_files=()
  mapfile -t affected_files < <(git diff --name-only 2>/dev/null || true)
  dedupe_array affected_files

  if [[ ${#affected_files[@]} -eq 0 ]]; then
    printf 'No unstaged changes to discard in the repository.\n'
    return 0
  fi

  if $dry_run; then
    printf 'Dry run: Would discard unstaged changes from the following files:\n'
    print_list '  ' "${affected_files[@]}"
    return 0
  fi

  # Perform the discard: Restore working tree to index repo-wide (preserves staged)
  # Using git checkout for reliability; equivalent to git restore --source=: --worktree .
  if ! git checkout -- . 2>/dev/null; then  # Suppress per-file output; check exit code
    error "Failed to discard all unstaged changes. Check for submodules or permissions."
  fi

  printf 'Discarded all unstaged changes from the repository (preserving staged changes).\n'
  print_list 'Affected files:' "${affected_files[@]}"
}

discard_unstaged() {
  local -n paths_ref="$1"  # Nameref to capture the array passed as the first argument (e.g., unstaged_paths)
  shift  # Remove the array name from arguments, leaving any extras if needed (though not used here)

  if [[ ${#paths_ref[@]} -eq 0 ]]; then
    return 0  # Nothing to do; early exit
  fi

  check_git_repo

  if ! git checkout -- "${paths_ref[@]}" 2>/dev/null; then  # Discard unstaged: working tree to index; suppress warnings, check exit
    error "Failed to discard unstaged changes for the specified paths. Check for submodules or permissions."
  fi

  print_list 'Discarded unstaged changes from (preserving staged)' "${paths_ref[@]}"
}

discard_all_uncommitted_changes() {
  local dry_run=false
  # Optional first arg: --dry-run (for preview without changes)
  if [[ "${1:-}" == "--dry-run" ]]; then
    dry_run=true
  fi

  # Ensure we're in a Git repo
  check_git_repo

  # Collect unique affected files: staged + unstaged changes (tracked only)
  local -a affected_files=()
  mapfile -t affected_files < <(git diff --name-only --cached . 2>/dev/null || true)
  local -a unstaged_files=()
  mapfile -t unstaged_files < <(git diff --name-only . 2>/dev/null || true)
  # Union into affected_files
  affected_files+=("${unstaged_files[@]}")
  dedupe_array affected_files  # From your libraries; removes duplicates

  if [[ ${#affected_files[@]} -eq 0 ]]; then
    if ! $dry_run; then
      printf 'No uncommitted changes to discard in the repository.\n'
    fi
    return 0
  fi

  if $dry_run; then
    printf 'Dry run: Would discard all uncommitted changes from the following files:\n'
    print_list '  ' "${affected_files[@]}"
    return 0
  fi

  # Perform the full repo-wide discard (staged + unstaged) to HEAD
  if ! git reset --hard HEAD; then
    error "Failed to discard all uncommitted changes. If submodules are dirty, run: git submodule foreach --recursive git reset --hard HEAD"
  fi

  printf 'Successfully discarded all uncommitted changes in the repository.\n'
  print_list 'Affected files:' "${affected_files[@]}"
  return 0
}

discard_uncommitted_changes() {
  local -n target_files_ref="$1"  # Nameref to the array of target paths (caller provides union/deduped list)
  local dry_run=false
  # Optional second arg: --dry-run (for preview without changes)
  if [[ "${2:-}" == "--dry-run" ]]; then
    dry_run=true
  fi

  # Ensure we're in a Git repo
  check_git_repo

  if [[ ${#target_files_ref[@]} -eq 0 ]]; then
    if ! $dry_run; then
      printf 'No uncommitted changes to discard for the specified paths.\n'
    fi
    return 0
  fi

  if $dry_run; then
    printf 'Dry run: Would discard all uncommitted changes from the following paths:\n'
    print_list '  ' "${target_files_ref[@]}"
    return 0
  fi

  # Perform the full discard to HEAD (staged + unstaged)
  if ! git restore --source=HEAD --staged --worktree -- "${target_files_ref[@]}"; then
    error "Failed to discard uncommitted changes for the specified paths. Check for conflicts or submodules."
  fi

  print_list 'Discarded all uncommitted changes from' "${target_files_ref[@]}"
  return 0
}

# Discards staged changes for a file with no unstaged changes (simple case)
discard_staged_no_unstaged() {
  local file="$1"
  if ! git restore --source=HEAD --staged --worktree -- "$file"; then
    error "Failed to discard staged changes for '$file' (no unstaged)."
  fi
  printf 'Discarded staged changes from %s\n' "$file"
}

# Discards staged changes for a file with unstaged changes (non-binary, non-symlink)
# Generates unstaged patch pre-reset, resets to HEAD, applies with fallbacks (including fuzz patch).
# Params: file, repo_root, failed_patch (output var for failure paths, optional)
discard_staged_with_unstaged() {
  local file="$1"
  local repo_root="$2"
  local -n failed_patch_ref="$3"  # Nameref for output on failure (optional)

  local local_file="$repo_root/$file"
  local unstaged_patch sanitized_patch rej_file=""

  # Generate unstaged patch BEFORE any reset (from current index to WD)
  unstaged_patch=$(mktemp -t hug-unstaged.XXXXXX.patch)
  sanitized_patch=$(mktemp -t hug-unstaged-clean.XXXXXX.patch)  # Pre-create for consistency
  trap 'rm -f "'"$unstaged_patch"'" "'"$sanitized_patch"'" "$rej_file"' RETURN  # Cleanup on success

  if ! git diff -- "$file" > "$unstaged_patch"; then
    trap - RETURN
    rm -f "$unstaged_patch" "$sanitized_patch"
    error "Failed to capture unstaged patch for '$file'."
  fi

  # Sanitize patch (remove index line for relaxed fallbacks)
  awk 'NR==2 && /^index / {next} {print}' "$unstaged_patch" > "$sanitized_patch"

  # Reset both index and WD to HEAD (discard staged + temp WD to "1")
  if ! git restore --source=HEAD --staged --worktree -- "$file"; then
    trap - RETURN
    rm -f "$unstaged_patch" "$sanitized_patch"
    error "Failed to reset '$file' to HEAD."
  fi

  local success=false
  # Primary: Git 3-way apply (uses patch blob refs)
  if git apply --3way --ignore-whitespace --whitespace=nowarn "$unstaged_patch" 2>/dev/null; then
    success=true
  else
    # Fallback 1: Git 2-way with reject (native, but strict)
    if git apply --ignore-whitespace --whitespace=nowarn --reject "$sanitized_patch" 2>/dev/null; then
      # Check for .rej (rejected hunk)
      rej_file="${local_file}.rej"
      if [[ -f "$rej_file" ]]; then
        rm -f "$rej_file"
      else
        success=true
      fi
    else
      # Fallback 2: Standard 'patch' command with fuzz (forgiving for missing context)
      if command -v patch >/dev/null 2>&1; then
        if patch -p1 --forward --fuzz=3 --ignore-whitespace < "$sanitized_patch" 2>/dev/null; then
          # Check for .rej (rejected)
          rej_file="${local_file}.rej"
          if [[ -f "$rej_file" ]]; then
            rm -f "$rej_file"
          else
            success=true
          fi
        fi
      fi
    fi
  fi

  if $success; then
    trap - RETURN
    rm -f "$unstaged_patch" "$sanitized_patch" "$rej_file"
    printf 'Discarded staged changes from %s (unstaged preserved)\n' "$file"
    return 0
  else
    # Failure: Preserve files, print guidance (clean any markers if present)
    trap - RETURN
    # Clean conflict markers if inserted (simple regex replace)
    if grep -q '<<<<<<<' "$local_file" 2>/dev/null; then
      sed -i '/^<<<<<<< ours/,/^>>>>>>> theirs/d' "$local_file"  # Remove markers, keep original WD content
      printf 'Warning: Removed conflict markers from %s (manual resolution needed).\n' "$file" >&2
    fi
    if [[ -n "${failed_patch_ref+set}" ]]; then
      failed_patch_ref="$unstaged_patch"  # Provide original patch for manual
    fi
    printf 'Failed to preserve unstaged changes for %s.\n' "$file" >&2
    printf '  • Saved unstaged diff: %s\n' "$unstaged_patch" >&2
    printf '  • Sanitized patch: %s\n' "$sanitized_patch" >&2
    # Print sanitized patch contents for immediate inspection
    printf '\nSanitized patch contents (the unstaged changes that failed to be preserved):\n' >&2
    cat "$sanitized_patch" >&2
    printf '\n' >&2
    # If .rej exists (from --reject), explain and print it
    rej_file="${local_file}.rej"
    if [[ -f "$rej_file" ]]; then
      printf '  • Rejected hunk file: %s (contains parts of the patch that could not be applied automatically)\n' "$rej_file" >&2
      printf 'Rejected hunk contents:\n' >&2
      cat "$rej_file" >&2
      printf '\nTo resolve: Edit the rejected hunk into %s manually, then remove the .rej file.\n' "$local_file" >&2
    fi
    printf 'You can try manually after resetting:\n' >&2
    printf '  git restore --source=HEAD --staged --worktree -- "%s"\n' "$file" >&2
    printf '  git apply --3way --ignore-whitespace "%s"\n' "$unstaged_patch" >&2
    printf '  or patch -p1 --fuzz=3 --ignore-whitespace < "%s"\n' "$sanitized_patch" >&2
    printf 'If conflicts persist, resolve the .rej file manually.\n' >&2
    printf 'To restore original state (before command):\n' >&2
    printf '  git checkout HEAD -- "%s"  # or git restore --source=HEAD --staged --worktree -- "%s"\n' "$file" "$file" >&2
    printf '  Then re-stage and re-add unstaged manually.\n' >&2
    return 1
  fi
}

discard_all_staged() {
  local dry_run=false
  if [[ "${1:-}" == "--dry-run" ]]; then
    dry_run=true
    shift
  fi

  check_git_repo

  local -a staged_paths=()
  mapfile -t staged_paths < <(git diff --cached --name-only 2>/dev/null || true)
  dedupe_array staged_paths

  if [[ ${#staged_paths[@]} -eq 0 ]]; then
    if ! $dry_run; then
      printf 'No staged changes to discard in the repository.\n'
    fi
    return 0
  fi

  if $dry_run; then
    printf 'Dry run: Would discard staged changes from the following files (unstaged preserved):\n'
    for file in "${staged_paths[@]}"; do
      printf '  %s\n' "$file"
    done
    return 0
  fi

  local repo_root
  repo_root="$(git rev-parse --show-toplevel)"

  # Compute has_unstaged only for staged paths
  declare -A has_unstaged
  local -a temp_unstaged_paths=()
  mapfile -t temp_unstaged_paths < <(git diff --name-only -- "${staged_paths[@]}" 2>/dev/null || true)
  dedupe_array temp_unstaged_paths
  for file in "${temp_unstaged_paths[@]}"; do
    has_unstaged["$file"]=true
  done

  for file in "${staged_paths[@]}"; do
    local has_unstaged_flag=false
    if [[ -n "${has_unstaged[$file]+set}" ]]; then
      has_unstaged_flag=true
    fi

    # Early errors for unsafe cases
    if $has_unstaged_flag && is_binary_staged "$file"; then
      error "Cannot safely discard staged changes for binary path '$file' while preserving unstaged changes. Please stash or commit the unstaged content first."
    fi

    local local_file="$repo_root/$file"
    if $has_unstaged_flag && is_symlink "$local_file"; then
      error "Cannot safely discard staged changes for symbolic link '$file' while preserving unstaged changes. Please stash or commit the unstaged content first."
    fi

    if ! $has_unstaged_flag; then
      discard_staged_no_unstaged "$file"
      continue
    fi

    local failed_patch=""
    if ! discard_staged_with_unstaged "$file" "$repo_root" failed_patch; then
      exit 1
    fi
  done

  printf 'Successfully discarded all staged changes in the repository (unstaged preserved where applicable).\n'
  return 0
}

# Computes details for local branches: populates output arrays and scalars via namerefs
# Returns 0 if branches found, 1 if none
compute_local_branch_details() {
    local -n branches_ref="$1"
    local -n hashes_ref="$2"
    local -n subjects_ref="$3"
    local -n tracks_ref="$4"
    local -n max_len_ref="$5"
    local -n current_branch_ref="$6"

    # Clear outputs
    branches_ref=()
    hashes_ref=()
    subjects_ref=()
    tracks_ref=()

    # Get sorted list of local branches
    mapfile -t branches_ref < <(git for-each-ref --format='%(refname:short)' --sort=refname refs/heads/ 2>/dev/null || true)

    if [ ${#branches_ref[@]} -eq 0 ]; then
        return 1  # No branches
    fi

    current_branch_ref=$(git branch --show-current 2>/dev/null || echo "")

    # Compute max branch name length for alignment
    max_len_ref=0
    for branch in "${branches_ref[@]}"; do
        len=${#branch}
        (( len > max_len_ref )) && max_len_ref=$len
    done

    # Populate details arrays
    for branch in "${branches_ref[@]}"; do
        local hash subject track
        hash=$(git rev-parse --short "$branch" 2>/dev/null)
        subject=$(git log -1 --format='%s' "$branch" 2>/dev/null || echo "(no commit message)")
        track=$(git for-each-ref --format='%(upstream:track)' "refs/heads/$branch" 2>/dev/null || echo "")

        hashes_ref+=("$hash")
        subjects_ref+=("$subject")
        tracks_ref+=("$track")
    done

    return 0
}

# Prints non-interactive list of branches with details (used by git-bll)
print_branch_list() {
    local -n branches_ref="$1"
    local -n hashes_ref="$2"
    local -n subjects_ref="$3"
    local -n tracks_ref="$4"
    local max_len="$5"
    local current_branch="$6"

    for i in "${!branches_ref[@]}"; do
        local branch="${branches_ref[i]}"
        local hash="${hashes_ref[i]}"
        local subject="${subjects_ref[i]}"
        local track="${tracks_ref[i]}"

        if [ "$branch" = "$current_branch" ]; then
            if [ -n "$track" ]; then
                printf "${GREEN}* %-*s (%s) %s${NC}" $max_len "$branch" "$hash" "$track"
            else
                printf "${GREEN}* %-*s (%s)${NC}" $max_len "$branch" "$hash"
            fi
        else
            if [ -n "$track" ]; then
                printf "  %-*s (%s) %s" $max_len "$branch" "$hash" "$track"
            else
                printf "  %-*s (%s)" $max_len "$branch" "$hash"
            fi
        fi

        printf " %s\n" "$subject"
    done
}

# Prints interactive menu for branch selection and returns selected branch via nameref (used by git-b)
print_interactive_branch_menu() {
    local -n selected_ref="$1"
    local -n branches_ref="$2"
    local -n hashes_ref="$3"
    local -n subjects_ref="$4"
    local -n tracks_ref="$5"
    local max_len="$6"
    local current_branch="$7"

    printf "Select a branch to switch to:\n\n"

    for i in "${!branches_ref[@]}"; do
        local num=$((i + 1))
        local branch="${branches_ref[i]}"
        local hash="${hashes_ref[i]}"
        local subject="${subjects_ref[i]}"
        local track="${tracks_ref[i]}"

        if [ "$branch" = "$current_branch" ]; then
            if [ -n "$track" ]; then
                printf "%d) ${GREEN}* %-*s (%s) %s${NC}" "$num" $max_len "$branch" "$hash" "$track"
            else
                printf "%d) ${GREEN}* %-*s (%s)${NC}" "$num" $max_len "$branch" "$hash"
            fi
        else
            if [ -n "$track" ]; then
                printf "%d)   %-*s (%s) %s" "$num" $max_len "$branch" "$hash" "$track"
            else
                printf "%d)   %-*s (%s)" "$num" $max_len "$branch" "$hash"
            fi
        fi

        printf " %s\n" "$subject"
    done

    printf "Enter choice (1-%d): " "${#branches_ref[@]}"
    read -r choice

    while true; do
        if [[ "$choice" =~ ^[0-9]+$ ]] && [ "$choice" -ge 1 ] && [ "$choice" -le "${#branches_ref[@]}" ]; then
            selected_ref="${branches_ref[$((choice - 1))]}"
            return 0
        else
            printf "Invalid choice. Please enter a number between 1 and %d: " "${#branches_ref[@]}"
            read -r choice
        fi
    done
}
