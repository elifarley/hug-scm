#!/b/bash
# shellcheck shell=dash
# This file is a library to be sourced by shell scripts

# Check if we're in a git repository
check_git_repo() {
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        error "Not in a git repository"
    fi
}

# Validate commit exists
validate_commit() {
    local commit="$1"
    if ! git rev-parse --verify "$commit" >/dev/null 2>&1; then
        error "Commit '$commit' does not exist"
    fi
}

# Check if working tree is clean
check_working_tree_clean() {
    if ! git diff --quiet || ! git diff --cached --quiet; then
        local unstaged_count
        local staged_count
        unstaged_count=$(git diff --name-only | wc -l)
        staged_count=$(git diff --cached --name-only | wc -l)

        error "Working tree is not clean!
       Unstaged changes: $unstaged_count files
       Staged changes: $staged_count files

       Solutions:
       • Use 'git w-backup' to save changes first
       • Use 'git w-discard-all' to discard changes
       • Use 'git w-discard <file>' for specific files"
    fi
}

# Check file in target commit
check_file_in_commit() {
    local commit="$1"
    local file="$2"

    if ! git cat-file -e "$commit:$file" 2>/dev/null; then
        error "File '$file' does not exist in commit $commit"
    fi
}

# Preview changes for specific files
preview_file_changes() {
    local commit="$1"
    local file="$2"

    printf "─ %s ─\n" "$file" >&2
    if git diff --no-index -- "$file" <(git show "$commit:$file") 2>/dev/null | head -20 >&2; then
        printf "─ (showing first 20 lines) ─\n\n" >&2
    else
        printf "─ (binary file or no changes) ─\n\n" >&2
    fi
}

# Check file has staged changes
check_file_staged() {
    local file="$1"

    if ! git diff --cached --quiet "$file" 2>/dev/null; then
        error "File '$file' has staged changes
       Use 'git us $file' to unstage first"
    fi
}

# Check file has unstaged changes
check_file_unstaged() {
    local file="$1"

    if ! git diff --quiet "$file" 2>/dev/null; then
        error "File '$file' has unstaged changes
       Use 'git w-discard $file' to discard changes first"
    fi
}

# Detects if the staged changes for a file are binary (returns true/false)
is_binary_staged() {
  local file="$1"
  local added deleted
  local diff_numstat

  diff_numstat="$(git diff --cached --numstat -- "$file" 2>/dev/null || true)"
  if [[ -n $diff_numstat ]]; then
    IFS=$'\t' read -r added deleted _ <<<"$diff_numstat"
    [[ $added == "-" && $deleted == "-" ]]
  else
    false  # No staged changes, not binary
  fi
}

discard_all_unstaged() {
  local dry_run=false
  # Check for --dry-run flag (passed as first argument if present)
  if [[ "${1:-}" == "--dry-run" ]]; then
    dry_run=true
    shift  # Remove the flag
  fi

  # Ensure we're in a Git repo
  check_git_repo

  # Check if there are any unstaged changes (modified tracked files)
  local -a affected_files=()
  mapfile -t affected_files < <(git diff --name-only 2>/dev/null || true)
  dedupe_array affected_files

  if [[ ${#affected_files[@]} -eq 0 ]]; then
    printf 'No unstaged changes to discard in the repository.\n'
    return 0
  fi

  if $dry_run; then
    printf 'Dry run: Would discard unstaged changes from the following files:\n'
    print_list '  ' "${affected_files[@]}"
    return 0
  fi

  # Perform the discard: Restore working tree to index repo-wide (preserves staged)
  # Using git checkout for reliability; equivalent to git restore --source=: --worktree .
  if ! git checkout -- . 2>/dev/null; then  # Suppress per-file output; check exit code
    error "Failed to discard all unstaged changes. Check for submodules or permissions."
  fi

  printf 'Discarded all unstaged changes from the repository (preserving staged changes).\n'
  print_list 'Affected files:' "${affected_files[@]}"
}

discard_unstaged() {
  local -n paths_ref="$1"  # Nameref to capture the array passed as the first argument (e.g., unstaged_paths)
  shift  # Remove the array name from arguments, leaving any extras if needed (though not used here)

  if [[ ${#paths_ref[@]} -eq 0 ]]; then
    return 0  # Nothing to do; early exit
  fi

  check_git_repo

  if ! git checkout -- "${paths_ref[@]}" 2>/dev/null; then  # Discard unstaged: working tree to index; suppress warnings, check exit
    error "Failed to discard unstaged changes for the specified paths. Check for submodules or permissions."
  fi

  print_list 'Discarded unstaged changes from (preserving staged)' "${paths_ref[@]}"
}

discard_all_uncommitted_changes() {
  local dry_run=false
  # Optional first arg: --dry-run (for preview without changes)
  if [[ "${1:-}" == "--dry-run" ]]; then
    dry_run=true
  fi

  # Ensure we're in a Git repo
  check_git_repo

  # Collect unique affected files: staged + unstaged changes (tracked only)
  local -a affected_files=()
  mapfile -t affected_files < <(git diff --name-only --cached . 2>/dev/null || true)
  local -a unstaged_files=()
  mapfile -t unstaged_files < <(git diff --name-only . 2>/dev/null || true)
  # Union into affected_files
  affected_files+=("${unstaged_files[@]}")
  dedupe_array affected_files  # From your libraries; removes duplicates

  if [[ ${#affected_files[@]} -eq 0 ]]; then
    if ! $dry_run; then
      printf 'No uncommitted changes to discard in the repository.\n'
    fi
    return 0
  fi

  if $dry_run; then
    printf 'Dry run: Would discard all uncommitted changes from the following files:\n'
    print_list '  ' "${affected_files[@]}"
    return 0
  fi

  # Perform the full repo-wide discard (staged + unstaged) to HEAD
  if ! git reset --hard HEAD; then
    error "Failed to discard all uncommitted changes. If submodules are dirty, run: git submodule foreach --recursive git reset --hard HEAD"
  fi

  printf 'Successfully discarded all uncommitted changes in the repository.\n'
  print_list 'Affected files:' "${affected_files[@]}"
  return 0
}

discard_uncommitted_changes() {
  local -n target_files_ref="$1"  # Nameref to the array of target paths (caller provides union/deduped list)
  local dry_run=false
  # Optional second arg: --dry-run (for preview without changes)
  if [[ "${2:-}" == "--dry-run" ]]; then
    dry_run=true
  fi

  # Ensure we're in a Git repo
  check_git_repo

  if [[ ${#target_files_ref[@]} -eq 0 ]]; then
    if ! $dry_run; then
      printf 'No uncommitted changes to discard for the specified paths.\n'
    fi
    return 0
  fi

  if $dry_run; then
    printf 'Dry run: Would discard all uncommitted changes from the following paths:\n'
    print_list '  ' "${target_files_ref[@]}"
    return 0
  fi

  # Perform the full discard to HEAD (staged + unstaged)
  if ! git restore --source=HEAD --staged --worktree -- "${target_files_ref[@]}"; then
    error "Failed to discard uncommitted changes for the specified paths. Check for conflicts or submodules."
  fi

  print_list 'Discarded all uncommitted changes from' "${target_files_ref[@]}"
  return 0
}

# Discards staged changes for a file with no unstaged changes (simple case)
discard_staged_no_unstaged() {
  local file="$1"
  if ! git restore --source=HEAD --staged --worktree -- "$file"; then
    error "Failed to discard staged changes for '$file' (no unstaged)."
  fi
  printf 'Discarded staged changes from %s\n' "$file"
}

# Discards staged changes for a file with unstaged changes (non-binary, non-symlink)
# Generates unstaged patch pre-reset, resets to HEAD, applies patch to preserve unstaged.
# Params: file, repo_root, failed_patch (output var for failure paths, optional)
discard_staged_with_unstaged() {
  local file="$1"
  local repo_root="$2"
  local -n failed_patch_ref="$3"  # Nameref for output on failure (optional)

  local local_file="$repo_root/$file"
  local unstaged_patch sanitized_patch=""

  # Generate unstaged patch BEFORE any reset (from current index to WD)
  unstaged_patch=$(mktemp -t hug-unstaged.XXXXXX.patch)
  trap 'rm -f "'"$unstaged_patch"'" "'"$sanitized_patch"'"' RETURN  # Cleanup on success

  if ! git diff -- "$file" > "$unstaged_patch"; then
    trap - RETURN
    rm -f "$unstaged_patch"
    error "Failed to capture unstaged patch for '$file'."
  fi

  # Reset both index and WD to HEAD (discard staged + temp WD to "1")
  if ! git restore --source=HEAD --staged --worktree -- "$file"; then
    trap - RETURN
    rm -f "$unstaged_patch"
    error "Failed to reset '$file' to HEAD."
  fi

  local success=false
  # Apply unstaged patch to clean WD (handles missing staged context via 3way/fuzz)
  if git apply --3way --ignore-whitespace --whitespace=nowarn "$unstaged_patch" 2>/dev/null; then
    success=true
  else
    # Fallback: Sanitized (no index line) for relaxed matching
    sanitized_patch=$(mktemp -t hug-unstaged-clean.XXXXXX.patch)
    awk 'NR==2 && /^index / {next} {print}' "$unstaged_patch" > "$sanitized_patch"
    if git apply --ignore-whitespace --whitespace=nowarn --reject "$sanitized_patch" 2>/dev/null; then
      # Check for .rej files (conflicts); if any, clean and fail
      if [[ -f "${local_file}.rej" ]]; then
        rm -f "${local_file}.rej"
        success=false
      else
        success=true
      fi
    fi
  fi

  if $success; then
    trap - RETURN
    rm -f "$unstaged_patch"
    [[ -n $sanitized_patch ]] && rm -f "$sanitized_patch"
    printf 'Discarded staged changes from %s (unstaged preserved)\n' "$file"
    return 0
  else
    # Failure: Preserve files, print guidance
    trap - RETURN
    if [[ -n "${failed_patch_ref+set}" ]]; then
      failed_patch_ref="$unstaged_patch"  # Provide original patch for manual
    fi
    printf 'Failed to preserve unstaged changes for %s.\n' "$file" >&2
    printf '  • Saved unstaged diff: %s\n' "$unstaged_patch" >&2
    if [[ -n $sanitized_patch ]]; then
      printf '  • Sanitized patch: %s\n' "$sanitized_patch" >&2
    fi
    printf 'You can try manually after resetting:\n' >&2
    printf '  git restore --source=HEAD --staged --worktree -- "%s"\n' "$file" >&2
    printf '  git apply --3way --ignore-whitespace "%s"\n' "$unstaged_patch" >&2
    if [[ -n $sanitized_patch ]]; then
      printf '  or git apply --ignore-whitespace --reject "%s"\n' "$sanitized_patch" >&2
    fi
    printf 'To restore original state:\n' >&2
    printf '  git cherry-pick --abort  # or manual un-reset\n' "$file" >&2  # Approximate
    return 1
  fi
}
