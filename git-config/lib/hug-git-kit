#!/b/bash
# shellcheck shell=dash
# This file is a library to be sourced by shell scripts

# Check if we're in a git repository
check_git_repo() {
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        error "Not in a git repository"
    fi
}

# Validate commit exists
validate_commit() {
    local commit="$1"
    if ! git rev-parse --verify "$commit" >/dev/null 2>&1; then
        error "Commit '$commit' does not exist"
    fi
}

# Check if working tree is clean
check_working_tree_clean() {
    if ! git diff --quiet || ! git diff --cached --quiet; then
        local unstaged_count
        local staged_count
        unstaged_count=$(git diff --name-only | wc -l)
        staged_count=$(git diff --cached --name-only | wc -l)

        error "Working tree is not clean!
       Unstaged changes: $unstaged_count files
       Staged changes: $staged_count files

       Solutions:
       • Use 'git w-backup' to save changes first
       • Use 'git w-discard-all' to discard changes
       • Use 'git w-discard <file>' for specific files"
    fi
}

# Check file in target commit
check_file_in_commit() {
    local commit="$1"
    local file="$2"

    if ! git cat-file -e "$commit:$file" 2>/dev/null; then
        error "File '$file' does not exist in commit $commit"
    fi
}

# Preview changes for specific files
preview_file_changes() {
    local commit="$1"
    local file="$2"

    printf "─ %s ─\n" "$file" >&2
    if git diff --no-index -- "$file" <(git show "$commit:$file") 2>/dev/null | head -20 >&2; then
        printf "─ (showing first 20 lines) ─\n\n" >&2
    else
        printf "─ (binary file or no changes) ─\n\n" >&2
    fi
}

# Check file has staged changes
check_file_staged() {
    local file="$1"

    if ! git diff --cached --quiet "$file" 2>/dev/null; then
        error "File '$file' has staged changes
       Use 'git us $file' to unstage first"
    fi
}

# Check file has unstaged changes
check_file_unstaged() {
    local file="$1"

    if ! git diff --quiet "$file" 2>/dev/null; then
        error "File '$file' has unstaged changes
       Use 'git w-discard $file' to discard changes first"
    fi
}

# Detects if the staged changes for a file are binary (returns true/false)
is_binary_staged() {
  local file="$1"
  local added deleted
  local diff_numstat

  diff_numstat="$(git diff --cached --numstat -- "$file" 2>/dev/null || true)"
  if [[ -n $diff_numstat ]]; then
    IFS=$'\t' read -r added deleted _ <<<"$diff_numstat"
    [[ $added == "-" && $deleted == "-" ]]
  else
    false  # No staged changes, not binary
  fi
}

discard_all_unstaged() {
  local dry_run=false
  # Check for --dry-run flag (passed as first argument if present)
  if [[ "${1:-}" == "--dry-run" ]]; then
    dry_run=true
    shift  # Remove the flag
  fi

  # Ensure we're in a Git repo
  check_git_repo

  # Check if there are any unstaged changes (modified tracked files)
  local -a affected_files=()
  mapfile -t affected_files < <(git diff --name-only 2>/dev/null || true)
  dedupe_array affected_files

  if [[ ${#affected_files[@]} -eq 0 ]]; then
    printf 'No unstaged changes to discard in the repository.\n'
    return 0
  fi

  if $dry_run; then
    printf 'Dry run: Would discard unstaged changes from the following files:\n'
    print_list '  ' "${affected_files[@]}"
    return 0
  fi

  # Perform the discard: Restore working tree to index repo-wide (preserves staged)
  # Using git checkout for reliability; equivalent to git restore --source=: --worktree .
  if ! git checkout -- . 2>/dev/null; then  # Suppress per-file output; check exit code
    error "Failed to discard all unstaged changes. Check for submodules or permissions."
  fi

  printf 'Discarded all unstaged changes from the repository (preserving staged changes).\n'
  print_list 'Affected files:' "${affected_files[@]}"
}

discard_unstaged() {
  local -n paths_ref="$1"  # Nameref to capture the array passed as the first argument (e.g., unstaged_paths)
  shift  # Remove the array name from arguments, leaving any extras if needed (though not used here)

  if [[ ${#paths_ref[@]} -eq 0 ]]; then
    return 0  # Nothing to do; early exit
  fi

  check_git_repo

  if ! git checkout -- "${paths_ref[@]}" 2>/dev/null; then  # Discard unstaged: working tree to index; suppress warnings, check exit
    error "Failed to discard unstaged changes for the specified paths. Check for submodules or permissions."
  fi

  print_list 'Discarded unstaged changes from (preserving staged)' "${paths_ref[@]}"
}

discard_all_uncommitted_changes() {
  local dry_run=false
  # Optional first arg: --dry-run (for preview without changes)
  if [[ "${1:-}" == "--dry-run" ]]; then
    dry_run=true
  fi

  # Ensure we're in a Git repo
  check_git_repo

  # Collect unique affected files: staged + unstaged changes (tracked only)
  local -a affected_files=()
  mapfile -t affected_files < <(git diff --name-only --cached . 2>/dev/null || true)
  local -a unstaged_files=()
  mapfile -t unstaged_files < <(git diff --name-only . 2>/dev/null || true)
  # Union into affected_files
  affected_files+=("${unstaged_files[@]}")
  dedupe_array affected_files  # From your libraries; removes duplicates

  if [[ ${#affected_files[@]} -eq 0 ]]; then
    if ! $dry_run; then
      printf 'No uncommitted changes to discard in the repository.\n'
    fi
    return 0
  fi

  if $dry_run; then
    printf 'Dry run: Would discard all uncommitted changes from the following files:\n'
    print_list '  ' "${affected_files[@]}"
    return 0
  fi

  # Perform the full repo-wide discard (staged + unstaged) to HEAD
  if ! git reset --hard HEAD; then
    error "Failed to discard all uncommitted changes. If submodules are dirty, run: git submodule foreach --recursive git reset --hard HEAD"
  fi

  printf 'Successfully discarded all uncommitted changes in the repository.\n'
  print_list 'Affected files:' "${affected_files[@]}"
  return 0
}

discard_uncommitted_changes() {
  local -n target_files_ref="$1"  # Nameref to the array of target paths (caller provides union/deduped list)
  local dry_run=false
  # Optional second arg: --dry-run (for preview without changes)
  if [[ "${2:-}" == "--dry-run" ]]; then
    dry_run=true
  fi

  # Ensure we're in a Git repo
  check_git_repo

  if [[ ${#target_files_ref[@]} -eq 0 ]]; then
    if ! $dry_run; then
      printf 'No uncommitted changes to discard for the specified paths.\n'
    fi
    return 0
  fi

  if $dry_run; then
    printf 'Dry run: Would discard all uncommitted changes from the following paths:\n'
    print_list '  ' "${target_files_ref[@]}"
    return 0
  fi

  # Perform the full discard to HEAD (staged + unstaged)
  if ! git restore --source=HEAD --staged --worktree -- "${target_files_ref[@]}"; then
    error "Failed to discard uncommitted changes for the specified paths. Check for conflicts or submodules."
  fi

  print_list 'Discarded all uncommitted changes from' "${target_files_ref[@]}"
  return 0
}

# Discards staged changes for a file with no unstaged changes (simple case)
discard_staged_no_unstaged() {
  local file="$1"
  if ! git restore --source=HEAD --staged --worktree -- "$file"; then
    error "Failed to discard staged changes for '$file' (no unstaged)."
  fi
  printf 'Discarded staged changes from %s\n' "$file"
}

# Discards staged changes for a file with unstaged changes (non-binary, non-symlink)
# Uses 3-way merge to apply reverse staged (base=index to other=HEAD) to WD, favoring WD.
# Params: file, repo_root, failed_tmp (output var for failure, optional)
discard_staged_with_unstaged() {
  local file="$1"
  local repo_root="$2"
  local -n failed_tmp_ref="$3"  # Nameref for output on failure (optional)

  local local_file="$repo_root/$file"
  local current_tmp base_tmp other_tmp
  local status

  # Create temps
  current_tmp=$(mktemp -t hug-discard-current.XXXXXX)
  base_tmp=$(mktemp -t hug-discard-base.XXXXXX)
  other_tmp=$(mktemp -t hug-discard-other.XXXXXX)
  trap 'rm -f "'"$current_tmp"'" "'"$base_tmp"'" "'"$other_tmp"'"' RETURN  # Cleanup on success

  # Copy WD to current
  if ! cp "$local_file" "$current_tmp"; then
    trap - RETURN
    rm -f "$current_tmp" "$base_tmp" "$other_tmp"
    error "Failed to copy working tree for '$file'."
  fi

  # Base: Original index content (staged version)
  if ! git show ":$file" > "$base_tmp" 2>/dev/null; then
    : > "$base_tmp"  # Empty if no index entry (rare, but safe)
  fi

  # Other: HEAD content
  if git rev-parse --verify "HEAD:$file" >/dev/null 2>&1; then
    if ! git show "HEAD:$file" > "$other_tmp"; then
      trap - RETURN
      rm -f "$current_tmp" "$base_tmp" "$other_tmp"
      error "Failed to read HEAD content for '$file'."
    fi
  else
    : > "$other_tmp"  # Empty if new file
  fi

  # 3-way merge: Apply base→other (reverse staged) to current, favor current (--ours) on conflicts
  if ! git merge-file --ours --quiet "$current_tmp" "$base_tmp" "$other_tmp"; then
    status=$?
    if (( status > 1 )); then  # >1 = fatal error (e.g., I/O, format)
      trap - RETURN
      rm -f "$current_tmp" "$base_tmp" "$other_tmp"
      error "Failed to merge for '$file' (exit $status). Check file format or permissions."
    fi
    # Status 1 = conflicts, but --ours should auto-resolve; if not, warn but proceed (favoring WD)
    printf 'Warning: Conflicts resolved favoring working tree for %s.\n' "$file" >&2
  fi

  # Reset index to HEAD (discard staged)
  if ! git restore --source=HEAD --staged -- "$file"; then
    trap - RETURN
    rm -f "$current_tmp" "$base_tmp" "$other_tmp"
    error "Failed to reset staged changes for '$file'."
  fi

  # Overwrite WD with merged result (HEAD + unstaged)
  mkdir -p "$(dirname "$local_file")"
  if [[ -e "$local_file" && ! -f "$local_file" ]]; then  # Handle non-files (e.g., dirs, but rare)
    rm -f "$local_file"
  fi
  if [[ -s "$current_tmp" ]]; then
    cat "$current_tmp" > "$local_file"
  else
    rm -f "$local_file"  # Empty result
  fi

  # Cleanup and success
  trap - RETURN
  rm -f "$current_tmp" "$base_tmp" "$other_tmp"
  printf 'Discarded staged changes from %s (unstaged preserved)\n' "$file"
  return 0
}
