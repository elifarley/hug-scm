# shellcheck shell=bash
# This file is a library to be sourced by shell scripts
#
# HUG-GIT-KIT: Git-specific operations library
#
# This library provides high-level functions for git operations including:
# - Repository and commit validation
# - Working tree state management
# - File change operations (discard, wipe, purge)
# - Branch information and navigation
# - Commit history analysis
# - Upstream operation handlers
#
# All functions are designed to work with the hug-common library
# and follow consistent patterns for error handling and user feedback.

################################################################################
# Git Repository Validation Functions
################################################################################

# Checks if current directory is within a git repository
# Usage: check_git_repo
# Environment:
#   GIT_PREFIX - Set to git prefix path if not already set
# Exits:
#   With error if not in a git repository
check_git_repo() {
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        error "Not in a git repository"
    fi
    test "${GIT_PREFIX:-}" || GIT_PREFIX=$(git rev-parse --show-prefix 2>/dev/null || echo "")
}

################################################################################
# Commit Validation Functions
################################################################################

# Validates that a commit reference exists
# Usage: validate_commit "commit-ref"
# Parameters:
#   $1 - Commit reference to validate
# Exits:
#   With error if commit does not exist
validate_commit() {
    local commit="$1"
    if ! git rev-parse --verify "$commit" >/dev/null 2>&1; then
        error "Commit '$commit' does not exist"
    fi
}

# Ensures a reference can be resolved to a commit
# Usage: ensure_commit_exists "ref"
# Parameters:
#   $1 - Reference to validate (branch, tag, commit hash, etc.)
# Exits:
#   With error if reference is empty or cannot be resolved to a commit
ensure_commit_exists() {
    local ref="${1:-}"
    if [[ -z "$ref" ]]; then
        error "Reference is required."
    fi

    if ! git rev-parse --verify "${ref}^{commit}" >/dev/null 2>&1; then
        error "Unable to resolve reference '$ref' to a commit."
    fi
}

################################################################################
# Upstream Branch Functions
################################################################################

# Gets the commit hash of the upstream branch for the current HEAD
# Usage: commit=$(get_upstream_commit)
# Output:
#   Commit hash of the upstream branch to stdout
# Exits:
#   With error if upstream is not configured
get_upstream_commit() {
    local upstream_commit
    # SC1083 suppressed: @{u} is git syntax, not shell expansion
    # shellcheck disable=SC1083
    upstream_commit=$(git rev-parse --verify @{u} 2>/dev/null) || {
        error "No upstream branch configured for the current branch.
       Use 'git branch --set-upstream-to=<remote>/<branch>' to configure it."
        exit 1
    }
    echo "$upstream_commit"
}

################################################################################
# Commit Ancestry Functions
################################################################################

# Ensures a reference is an ancestor of HEAD
# Usage: ensure_ancestor_of_head "ref" ["reason"]
# Parameters:
#   $1 - Reference to check
#   $2 - (Optional) Additional context for error message
# Exits:
#   With error if reference is empty, doesn't exist, or is not an ancestor of HEAD
ensure_ancestor_of_head() {
    local ref="${1:-}"
    local reason="${2:-}"
    if [[ -z "$ref" ]]; then
        error "Reference is required."
    fi

    ensure_commit_exists "$ref"

    if ! git merge-base --is-ancestor "${ref}^{commit}" HEAD >/dev/null 2>&1; then
        if [[ -n "$reason" ]]; then
            error "Reference '$ref' is not an ancestor of HEAD; $reason"
        else
            error "Reference '$ref' is not an ancestor of HEAD."
        fi
    fi
}

# Resolves a HEAD target from user input
# Usage: target=$(resolve_head_target "arg" ["default"])
# Parameters:
#   $1 - User argument (empty, number 1-999, or commit reference)
#   $2 - (Optional) Default target if arg is empty, defaults to "HEAD~1"
# Output:
#   Resolved commit reference to stdout
# Examples:
#   resolve_head_target "" -> "HEAD~1" (or custom default)
#   resolve_head_target "3" -> "HEAD~3"
#   resolve_head_target "abc123" -> "abc123"
resolve_head_target() {
    local arg="${1:-}"
    local default_target="${2:-HEAD~1}"

    if [[ -z "$arg" ]]; then
        printf '%s\n' "$default_target"
    elif [[ "$arg" =~ ^[1-9][0-9]{0,2}$ ]]; then
        printf 'HEAD~%s\n' "$arg"
    else
        printf '%s\n' "$arg"
    fi
}

################################################################################
# Commit History Navigation Functions
################################################################################

# Gets the Nth commit hash in history, optionally for specific files
# Usage: commit=$(get_commit_n_back N [file1] [file2] ...)
# Parameters:
#   $1 - Number of commits to go back (0-99)
#   $@ - (Optional) Files to consider; if provided, counts only commits affecting those files
# Output:
#   Resolved commit hash to stdout
# Exits:
#   With error if N commits cannot be found in history
# Examples:
#   get_commit_n_back 3 -> HEAD~3
#   get_commit_n_back 5 src/main.c -> 5th commit that touched src/main.c
get_commit_n_back() {
    local n="$1"
    shift
    local files=("$@")

    if [[ ! "$n" =~ ^([0-9]|[1-9][0-9]?)$ ]]; then
        # This is an internal check, user input should be validated first
        error "Internal error: N must be an integer between 0 and 99."
        exit 1
    fi

    local target_commit

    if [ ${#files[@]} -eq 0 ]; then
        # No files specified, go back N commits in overall history.
        target_commit="HEAD~$n"
    else
        # Files specified, find the commit N steps back from their last change.
        if [ "$n" -eq 0 ]; then
            # N=0 means reset to HEAD.
            target_commit="HEAD"
        else
            # N > 0 means go back N commits BEFORE the last change.
            # We skip N commits from the list of file changes and take the next one.
            target_commit=$(git rev-list --skip=$((n)) -1 HEAD -- "${files[@]}" 2>/dev/null)
            if [ -z "$target_commit" ]; then
                local file_list
                printf -v file_list "%s " "${files[@]}"
                error "Could not find $n commits in the history of: ${file_list% }"
                exit 1
            fi
        fi
    fi

    echo "$target_commit"
}

################################################################################
# Working Tree State Functions
################################################################################

# Checks if there are any pending changes (staged, unstaged, or untracked)
# Usage: if has_pending_changes; then ...; fi
# Returns:
#   0 if there are pending changes, 1 if working tree is clean
has_pending_changes() {
  git status --porcelain=2 --untracked-files=normal | grep -q '.'
}

# Checks if working tree is clean (no uncommitted changes)
# Usage: check_working_tree_clean
# Exits:
#   With error if there are uncommitted changes (staged or unstaged)
#   Error message includes counts and suggested solutions
check_working_tree_clean() {
    if ! git diff --quiet || ! git diff --cached --quiet; then
        local unstaged_count
        local staged_count
        unstaged_count=$(git diff --name-only | wc -l)
        staged_count=$(git diff --cached --name-only | wc -l)

        error "Working tree is not clean!
       Unstaged changes: $unstaged_count files
       Staged changes: $staged_count files

       Solutions:
       • Use 'git w-backup' to save changes first
       • Use 'git w-discard-all' to discard changes
       • Use 'git w-discard <file>' for specific files"
    fi
}

# Checks if specific files are clean (no staged or unstaged changes)
# Usage: check_files_clean file1 file2 ...
# Parameters:
#   $@ - Files to check
# Exits:
#   With error if any of the specified files have uncommitted changes
#   Error message includes affected files and suggested solutions
check_files_clean() {
    local -a files=("$@")
    if [ ${#files[@]} -eq 0 ]; then
        return 0 # No files to check
    fi

    # Optimization: use a single git command to check all files at once
    local -a files_with_changes=()
    mapfile -t files_with_changes < <(git diff --name-only -- "${files[@]}" 2>/dev/null || true)
    mapfile -t -O "${#files_with_changes[@]}" files_with_changes < <(git diff --cached --name-only -- "${files[@]}" 2>/dev/null || true)
    
    # Remove duplicates from the combined list
    dedupe_array files_with_changes

    if [ ${#files_with_changes[@]} -gt 0 ]; then
        error "Cannot proceed because some affected files have uncommitted changes.
       Affected files:
         $(printf "%s\n" "${files_with_changes[@]}" | sed 's/^/         /')

       Solutions:
       • Use 'hug w discard-all' to discard changes
       • Use 'hug w discard <file>' for specific files"
        exit 1
    fi
}

################################################################################
# File State Checking Functions
################################################################################

# Checks if a file exists in a specific commit
# Usage: check_file_in_commit "commit" "file"
# Parameters:
#   $1 - Commit reference
#   $2 - File path (relative to current directory)
# Environment:
#   GIT_PREFIX - Git prefix path (set automatically if not present)
# Exits:
#   With error if file does not exist in the specified commit
check_file_in_commit() {
    test "${GIT_PREFIX:-}" || GIT_PREFIX=$(git rev-parse --show-prefix 2>/dev/null || echo "")
    local commit="$1"
    local file="${GIT_PREFIX}$2"
    if ! git cat-file -e "$commit:$file" 2>/dev/null; then
        error "File '$file' does not exist in commit $commit"
    fi
}

# Previews changes for specific files
# Usage: preview_file_changes "commit" "file"
# Parameters:
#   $1 - Commit reference
#   $2 - File path (relative to current directory)
# Environment:
#   GIT_PREFIX - Git prefix path (set automatically if not present)
# Output:
#   Diff preview (first 20 lines) to stderr
preview_file_changes() {
  test "${GIT_PREFIX:-}" || GIT_PREFIX=$(git rev-parse --show-prefix 2>/dev/null || echo "")
  local commit="$1"
  local file="${GIT_PREFIX}$2"

  printf "─ %s ─\n" "$file" >&2
  if git diff --no-index -- "$file" <(git show "$commit:$file") 2>/dev/null | head -20 >&2; then
    printf "─ (showing first 20 lines) ─\n\n" >&2
  else
    printf "─ (binary file or no changes) ─\n\n" >&2
  fi
}

# Checks if a file has staged changes
# Usage: check_file_staged "file"
# Parameters:
#   $1 - File path (relative to current directory)
# Environment:
#   GIT_PREFIX - Git prefix path (set automatically if not present)
# Exits:
#   With error if file has staged changes
check_file_staged() {
  test "${GIT_PREFIX:-}" || GIT_PREFIX=$(git rev-parse --show-prefix 2>/dev/null || echo "")
  local file="${GIT_PREFIX}$1"

  if ! git diff --cached --quiet -- "$file" 2>/dev/null; then
    error "File '$file' has staged changes
    Use 'hug us $file' to unstage first"
  fi
}

# Checks if a file has unstaged changes
# Usage: check_file_unstaged "file"
# Parameters:
#   $1 - File path (relative to current directory)
# Environment:
#   GIT_PREFIX - Git prefix path (set automatically if not present)
# Exits:
#   With error if file has unstaged changes
check_file_unstaged() {
  test "${GIT_PREFIX:-}" || GIT_PREFIX=$(git rev-parse --show-prefix 2>/dev/null || echo "")
  local file="${GIT_PREFIX}$1"

  if ! git diff --quiet -- "$file" 2>/dev/null; then
    error "File '$file' has unstaged changes
    Use 'git w-discard $file' to discard changes first"
  fi
}

# Detects if the staged changes for a file are binary
# Usage: if is_binary_staged "file"; then ...; fi
# Parameters:
#   $1 - File path (relative to current directory)
# Environment:
#   GIT_PREFIX - Git prefix path (set automatically if not present)
# Returns:
#   0 if file has binary staged changes, 1 otherwise
is_binary_staged() {
  test "${GIT_PREFIX:-}" || GIT_PREFIX=$(git rev-parse --show-prefix 2>/dev/null || echo "")
  local file="${GIT_PREFIX}$1"
  local added deleted
  local diff_numstat

  diff_numstat="$(git diff --cached --numstat -- "$file" 2>/dev/null || true)"
  if [[ -n $diff_numstat ]]; then
    IFS=$'\t' read -r added deleted _ <<<"$diff_numstat"
    [[ $added == "-" && $deleted == "-" ]]
  else
    false  # No staged changes, not binary
  fi
}

################################################################################
# Discard Operations - Unstaged Changes
################################################################################

# Discards all unstaged changes in the repository
# Usage: discard_all_unstaged [--dry-run]
# Parameters:
#   $1 - (Optional) --dry-run flag for preview mode
# Effects:
#   Restores working tree to index state (preserves staged changes)
# Output:
#   Status message and list of affected files
discard_all_unstaged() {
  local dry_run=false
  # Check for --dry-run flag (passed as first argument if present)
  if [[ "${1:-}" == "--dry-run" ]]; then
    dry_run=true
    shift  # Remove the flag
  fi

  # Ensure we're in a Git repo
  check_git_repo

  # Check if there are any unstaged changes (modified tracked files)
  local -a affected_files=()
  mapfile -t affected_files < <(git diff --name-only 2>/dev/null || true)
  dedupe_array affected_files

  if [[ ${#affected_files[@]} -eq 0 ]]; then
    printf 'No unstaged changes to discard in the repository.\n'
    return 0
  fi

  if $dry_run; then
    printf 'Dry run: Would discard unstaged changes from the following files:\n'
    print_list '  ' "${affected_files[@]}"
    return 0
  fi

  # Perform the discard: Restore working tree to index repo-wide (preserves staged)
  # Using git checkout for reliability; equivalent to git restore --source=: --worktree .
  if ! git checkout -- . 2>/dev/null; then  # Suppress per-file output; check exit code
    error "Failed to discard all unstaged changes. Check for submodules or permissions."
  fi

  printf 'Discarded all unstaged changes from the repository (preserving staged changes).\n'
  print_list 'Affected files:' "${affected_files[@]}"
}

# Discards unstaged changes for specific paths
# Usage: discard_unstaged array_name
# Parameters:
#   $1 - Name of array containing paths to discard (nameref)
# Effects:
#   Restores working tree to index state for specified paths
# Output:
#   List of affected paths
discard_unstaged() {
  local -n paths_ref="$1"  # Nameref to capture the array passed as the first argument (e.g., unstaged_paths)
  shift  # Remove the array name from arguments, leaving any extras if needed (though not used here)

  if [[ ${#paths_ref[@]} -eq 0 ]]; then
    return 0  # Nothing to do; early exit
  fi

  check_git_repo

  if ! git checkout -- "${paths_ref[@]}" 2>/dev/null; then  # Discard unstaged: working tree to index; suppress warnings, check exit
    error "Failed to discard unstaged changes for the specified paths. Check for submodules or permissions."
  fi

  print_list 'Discarded unstaged changes from (preserving staged)' "${paths_ref[@]}"
}

################################################################################
# Discard Operations - All Uncommitted Changes
################################################################################

# Discards all uncommitted changes (staged and unstaged) in the repository
# Usage: discard_all_uncommitted_changes [--dry-run]
# Parameters:
#   $1 - (Optional) --dry-run flag for preview mode
# Effects:
#   Hard resets working tree and index to HEAD
# Output:
#   Status message and list of affected files
discard_all_uncommitted_changes() {
  local dry_run=false
  # Optional first arg: --dry-run (for preview without changes)
  if [[ "${1:-}" == "--dry-run" ]]; then
    dry_run=true
  fi

  # Ensure we're in a Git repo
  check_git_repo

  # Collect unique affected files: staged + unstaged changes (tracked only)
  local -a affected_files=()
  mapfile -t affected_files < <(git diff --name-only --cached -- . 2>/dev/null || true)
  local -a unstaged_files=()
  mapfile -t unstaged_files < <(git diff --name-only -- . 2>/dev/null || true)
  # Union into affected_files
  affected_files+=("${unstaged_files[@]}")
  dedupe_array affected_files  # From your libraries; removes duplicates

  if [[ ${#affected_files[@]} -eq 0 ]]; then
    if ! $dry_run; then
      printf 'No uncommitted changes to discard in the repository.\n'
    fi
    return 0
  fi

  if $dry_run; then
    printf 'Dry run: Would discard all uncommitted changes from the following files:\n'
    print_list '  ' "${affected_files[@]}"
    return 0
  fi

  # Perform the full repo-wide discard (staged + unstaged) to HEAD
  if ! git reset --hard HEAD; then
    error "Failed to discard all uncommitted changes. If submodules are dirty, run: git submodule foreach --recursive git reset --hard HEAD"
  fi

  printf 'Successfully discarded all uncommitted changes in the repository.\n'
  print_list 'Affected files:' "${affected_files[@]}"
  return 0
}

# Discards all uncommitted changes for specific paths
# Usage: discard_uncommitted_changes array_name [--dry-run]
# Parameters:
#   $1 - Name of array containing paths (nameref)
#   $2 - (Optional) --dry-run flag for preview mode
# Effects:
#   Resets working tree and index to HEAD for specified paths
# Output:
#   List of affected paths
discard_uncommitted_changes() {
  local -n target_files_ref="$1"  # Nameref to the array of target paths (caller provides union/deduped list)
  local dry_run=false
  # Optional second arg: --dry-run (for preview without changes)
  if [[ "${2:-}" == "--dry-run" ]]; then
    dry_run=true
  fi

  # Ensure we're in a Git repo
  check_git_repo

  if [[ ${#target_files_ref[@]} -eq 0 ]]; then
    if ! $dry_run; then
      printf 'No uncommitted changes to discard for the specified paths.\n'
    fi
    return 0
  fi

  if $dry_run; then
    printf 'Dry run: Would discard all uncommitted changes from the following paths:\n'
    print_list '  ' "${target_files_ref[@]}"
    return 0
  fi

  # Perform the full discard to HEAD (staged + unstaged)
  if ! git restore --source=HEAD --staged --worktree -- "${target_files_ref[@]}"; then
    error "Failed to discard uncommitted changes for the specified paths. Check for conflicts or submodules."
  fi

  print_list 'Discarded all uncommitted changes from' "${target_files_ref[@]}"
  return 0
}

################################################################################
# Discard Operations - Staged Changes Only
################################################################################

# Discards staged changes for a file with no unstaged changes
# Usage: discard_staged_no_unstaged "file"
# Parameters:
#   $1 - File path
# Effects:
#   Resets file to HEAD state (removes from staging)
# Output:
#   Status message
discard_staged_no_unstaged() {
  local file="$1"
  if ! git restore --source=HEAD --staged --worktree -- "$file"; then
    error "Failed to discard staged changes for '$file' (no unstaged)."
  fi
  printf 'Discarded staged changes from %s\n' "$file"
}

# Discards staged changes for a file with unstaged changes
# Usage: discard_staged_with_unstaged "file" "repo_root" failed_patch_var
# Parameters:
#   $1 - File path
#   $2 - Repository root path
#   $3 - Name of variable to store failed patch path (nameref, optional output)
# Effects:
#   Attempts to preserve unstaged changes while discarding staged changes
#   Uses multiple fallback strategies (3-way merge, reject files, fuzz patching)
# Returns:
#   0 on success, 1 on failure (with guidance printed to stderr)
# Note:
#   This is a complex operation that may fail for conflicting changes
#   On failure, provides detailed guidance and preserves patch files for manual resolution
# Params: file, repo_root, failed_patch (output var for failure paths, optional)
discard_staged_with_unstaged() {
  local file="$1"
  local repo_root="$2"
  local -n failed_patch_ref="$3"  # Nameref for output on failure (optional)

  local local_file="$repo_root/$file"
  local unstaged_patch sanitized_patch rej_file=""

  # Generate unstaged patch BEFORE any reset (from current index to WD)
  unstaged_patch=$(mktemp -t hug-unstaged.XXXXXX.patch)
  sanitized_patch=$(mktemp -t hug-unstaged-clean.XXXXXX.patch)  # Pre-create for consistency
  trap 'rm -f "'"$unstaged_patch"'" "'"$sanitized_patch"'" "$rej_file"' RETURN  # Cleanup on success

  if ! git diff -- "$file" > "$unstaged_patch"; then
    trap - RETURN
    rm -f "$unstaged_patch" "$sanitized_patch"
    error "Failed to capture unstaged patch for '$file'."
  fi

  # Sanitize patch (remove index line for relaxed fallbacks)
  awk 'NR==2 && /^index / {next} {print}' "$unstaged_patch" > "$sanitized_patch"

  # Reset both index and WD to HEAD (discard staged + temp WD to "1")
  if ! git restore --source=HEAD --staged --worktree -- "$file"; then
    trap - RETURN
    rm -f "$unstaged_patch" "$sanitized_patch"
    error "Failed to reset '$file' to HEAD."
  fi

  local success=false
  # Primary: Git 3-way apply (uses patch blob refs)
  if git apply --3way --ignore-whitespace --whitespace=nowarn "$unstaged_patch" 2>/dev/null; then
    success=true
  else
    # Fallback 1: Git 2-way with reject (native, but strict)
    if git apply --ignore-whitespace --whitespace=nowarn --reject "$sanitized_patch" 2>/dev/null; then
      # Check for .rej (rejected hunk)
      rej_file="${local_file}.rej"
      if [[ -f "$rej_file" ]]; then
        rm -f "$rej_file"
      else
        success=true
      fi
    else
      # Fallback 2: Standard 'patch' command with fuzz (forgiving for missing context)
      if command -v patch >/dev/null 2>&1; then
        if patch -p1 --forward --fuzz=3 --ignore-whitespace < "$sanitized_patch" 2>/dev/null; then
          # Check for .rej (rejected)
          rej_file="${local_file}.rej"
          if [[ -f "$rej_file" ]]; then
            rm -f "$rej_file"
          else
            success=true
          fi
        fi
      fi
    fi
  fi

  if $success; then
    trap - RETURN
    rm -f "$unstaged_patch" "$sanitized_patch" "$rej_file"
    printf 'Discarded staged changes from %s (unstaged preserved)\n' "$file"
    return 0
  else
    # Failure: Preserve files, print guidance (clean any markers if present)
    trap - RETURN
    # Clean conflict markers if inserted (simple regex replace)
    if grep -q '<<<<<<<' "$local_file" 2>/dev/null; then
      sed -i '/^<<<<<<< ours/,/^>>>>>>> theirs/d' "$local_file"  # Remove markers, keep original WD content
      printf 'Warning: Removed conflict markers from %s (manual resolution needed).\n' "$file" >&2
    fi
    if [[ -n "${failed_patch_ref+set}" ]]; then
      failed_patch_ref="$unstaged_patch"  # Provide original patch for manual
    fi
    printf 'Failed to preserve unstaged changes for %s.\n' "$file" >&2
    printf '  • Saved unstaged diff: %s\n' "$unstaged_patch" >&2
    printf '  • Sanitized patch: %s\n' "$sanitized_patch" >&2
    # Print sanitized patch contents for immediate inspection
    printf '\nSanitized patch contents (the unstaged changes that failed to be preserved):\n' >&2
    cat "$sanitized_patch" >&2
    printf '\n' >&2
    # If .rej exists (from --reject), explain and print it
    rej_file="${local_file}.rej"
    if [[ -f "$rej_file" ]]; then
      printf '  • Rejected hunk file: %s (contains parts of the patch that could not be applied automatically)\n' "$rej_file" >&2
      printf 'Rejected hunk contents:\n' >&2
      cat "$rej_file" >&2
      printf '\nTo resolve: Edit the rejected hunk into %s manually, then remove the .rej file.\n' "$local_file" >&2
    fi
    printf 'You can try manually after resetting:\n' >&2
    printf '  git restore --source=HEAD --staged --worktree -- "%s"\n' "$file" >&2
    printf '  git apply --3way --ignore-whitespace "%s"\n' "$unstaged_patch" >&2
    printf '  or patch -p1 --fuzz=3 --ignore-whitespace < "%s"\n' "$sanitized_patch" >&2
    printf 'If conflicts persist, resolve the .rej file manually.\n' >&2
    printf 'To restore original state (before command):\n' >&2
    printf '  git checkout HEAD -- "%s"  # or git restore --source=HEAD --staged --worktree -- "%s"\n' "$file" "$file" >&2
    printf '  Then re-stage and re-add unstaged manually.\n' >&2
    return 1
  fi
}

# Discards all staged changes in the repository
# Usage: discard_all_staged [--dry-run]
# Parameters:
#   $1 - (Optional) --dry-run flag for preview mode
# Effects:
#   Discards staged changes while attempting to preserve unstaged changes
#   Handles binary files and symlinks with appropriate error messages
# Output:
#   Status messages and list of affected files
# Note:
#   Cannot safely handle binary files or symlinks with both staged and unstaged changes
discard_all_staged() {
  local dry_run=false
  if [[ "${1:-}" == "--dry-run" ]]; then
    dry_run=true
    shift
  fi

  check_git_repo

  local -a staged_paths=()
  mapfile -t staged_paths < <(git diff --cached --name-only 2>/dev/null || true)
  dedupe_array staged_paths

  if [[ ${#staged_paths[@]} -eq 0 ]]; then
    if ! $dry_run; then
      printf 'No staged changes to discard in the repository.\n'
    fi
    return 0
  fi

  if $dry_run; then
    printf 'Dry run: Would discard staged changes from the following files (unstaged preserved):\n'
    for file in "${staged_paths[@]}"; do
      printf '  %s\n' "$file"
    done
    return 0
  fi

  local repo_root
  repo_root="$(git rev-parse --show-toplevel)"

  # Compute has_unstaged only for staged paths
  declare -A has_unstaged
  local -a temp_unstaged_paths=()
  mapfile -t temp_unstaged_paths < <(git diff --name-only -- "${staged_paths[@]}" 2>/dev/null || true)
  dedupe_array temp_unstaged_paths
  for file in "${temp_unstaged_paths[@]}"; do
    has_unstaged["$file"]=true
  done

  for file in "${staged_paths[@]}"; do
    local has_unstaged_flag=false
    if [[ -n "${has_unstaged[$file]+set}" ]]; then
      has_unstaged_flag=true
    fi

    # Early errors for unsafe cases
    if $has_unstaged_flag && is_binary_staged "$file"; then
      error "Cannot safely discard staged changes for binary path '$file' while preserving unstaged changes. Please stash or commit the unstaged content first."
    fi

    local local_file="$repo_root/$file"
    if $has_unstaged_flag && is_symlink "$local_file"; then
      error "Cannot safely discard staged changes for symbolic link '$file' while preserving unstaged changes. Please stash or commit the unstaged content first."
    fi

    if ! $has_unstaged_flag; then
      discard_staged_no_unstaged "$file"
      continue
    fi

    # SC2034: failed_patch is assigned via nameref in discard_staged_with_unstaged
    # shellcheck disable=SC2034
    local failed_patch=""
    if ! discard_staged_with_unstaged "$file" "$repo_root" failed_patch; then
      exit 1
    fi
  done

  printf 'Successfully discarded all staged changes in the repository (unstaged preserved where applicable).\n'
  return 0
}

################################################################################
# Branch Information Functions
################################################################################

# Computes details for local branches and populates output arrays
# Usage: compute_local_branch_details branches hashes subjects tracks max_len current_branch
# Parameters (all namerefs to output variables):
#   $1 - Array to receive branch names
#   $2 - Array to receive commit hashes
#   $3 - Array to receive commit subjects
#   $4 - Array to receive tracking information
#   $5 - Scalar to receive max branch name length
#   $6 - Scalar to receive current branch name
# Returns:
#   0 if branches found, 1 if no branches exist
# Note:
#   Arrays are cleared before population. Branches are sorted by name.
compute_local_branch_details() {
    local -n branches_ref="$1"
    local -n hashes_ref="$2"
    local -n subjects_ref="$3"
    local -n tracks_ref="$4"
    local -n max_len_ref="$5"
    local -n current_branch_ref="$6"

    # Clear outputs
    branches_ref=()
    hashes_ref=()
    subjects_ref=()
    tracks_ref=()

    # Get sorted list of local branches
    mapfile -t branches_ref < <(git for-each-ref --format='%(refname:short)' --sort=refname refs/heads/ 2>/dev/null || true)

    if [ ${#branches_ref[@]} -eq 0 ]; then
        return 1  # No branches
    fi

    # SC2034: current_branch_ref is assigned via nameref (output parameter)
    # shellcheck disable=SC2034
    current_branch_ref=$(git branch --show-current 2>/dev/null || echo "")

    # Compute max branch name length for alignment
    max_len_ref=0
    for branch in "${branches_ref[@]}"; do
        len=${#branch}
        (( len > max_len_ref )) && max_len_ref=$len
    done

    # Populate details arrays
    for branch in "${branches_ref[@]}"; do
        local hash subject track
        hash=$(git rev-parse --short "$branch" 2>/dev/null)
        subject=$(git log -1 --format='%s' "$branch" 2>/dev/null || echo "(no commit message)")
        track=$(git for-each-ref --format='%(upstream:track)' "refs/heads/$branch" 2>/dev/null || echo "")

        hashes_ref+=("$hash")
        subjects_ref+=("$subject")
        tracks_ref+=("$track")
    done

    return 0
}

# Prints a non-interactive list of branches with details
# Usage: print_branch_list branches hashes subjects tracks max_len current_branch
# Parameters (namerefs to arrays/scalars):
#   $1 - Array of branch names
#   $2 - Array of commit hashes
#   $3 - Array of commit subjects  
#   $4 - Array of tracking information
#   $5 - Maximum branch name length (for alignment)
#   $6 - Current branch name
# Output:
#   Formatted branch list to stdout, with current branch highlighted in green
# SC2178: These nameref declarations are intentional and correct
# shellcheck disable=SC2178
print_branch_list() {
    local -n branches_ref="$1"
    local -n hashes_ref="$2"
    local -n subjects_ref="$3"
    local -n tracks_ref="$4"
    local max_len="$5"
    local current_branch="$6"

    for i in "${!branches_ref[@]}"; do
        local branch="${branches_ref[i]}"
        local hash="${hashes_ref[i]}"
        local subject="${subjects_ref[i]}"
        local track="${tracks_ref[i]}"

        if [ "$branch" = "$current_branch" ]; then
            if [ -n "$track" ]; then
                printf "${GREEN}* %-*s (%s) %s${NC}" "$max_len" "$branch" "$hash" "$track"
            else
                printf "${GREEN}* %-*s (%s)${NC}" "$max_len" "$branch" "$hash"
            fi
        else
            if [ -n "$track" ]; then
                printf "  %-*s (%s) %s" "$max_len" "$branch" "$hash" "$track"
            else
                printf "  %-*s (%s)" "$max_len" "$branch" "$hash"
            fi
        fi

        printf " %s\n" "$subject"
    done
}

# Prints an interactive menu for branch selection
# Usage: print_interactive_branch_menu selected branches hashes subjects tracks max_len current_branch
# Parameters (namerefs):
#   $1 - Output variable to receive selected branch name
#   $2 - Array of branch names
#   $3 - Array of commit hashes
#   $4 - Array of commit subjects
#   $5 - Array of tracking information
#   $6 - Maximum branch name length (for alignment)
#   $7 - Current branch name
# Effects:
#   Displays numbered menu and prompts for selection
#   Loops until valid selection is made
# Output:
#   Selected branch name via nameref parameter
# SC2178: These nameref declarations are intentional and correct
# shellcheck disable=SC2178
print_interactive_branch_menu() {
    local -n selected_ref="$1"
    local -n branches_ref="$2"
    local -n hashes_ref="$3"
    local -n subjects_ref="$4"
    local -n tracks_ref="$5"
    local max_len="$6"
    local current_branch="$7"

    printf "Select a branch to switch to:\n\n"

    for i in "${!branches_ref[@]}"; do
        local num=$((i + 1))
        local branch="${branches_ref[i]}"
        local hash="${hashes_ref[i]}"
        local subject="${subjects_ref[i]}"
        local track="${tracks_ref[i]}"

        if [ "$branch" = "$current_branch" ]; then
            if [ -n "$track" ]; then
                printf "%d) ${GREEN}* %-*s (%s) %s${NC}" "$num" "$max_len" "$branch" "$hash" "$track"
            else
                printf "%d) ${GREEN}* %-*s (%s)${NC}" "$num" "$max_len" "$branch" "$hash"
            fi
        else
            if [ -n "$track" ]; then
                printf "%d)   %-*s (%s) %s" "$num" "$max_len" "$branch" "$hash" "$track"
            else
                printf "%d)   %-*s (%s)" "$num" "$max_len" "$branch" "$hash"
            fi
        fi

        printf " %s\n" "$subject"
    done

    printf "Enter choice (1-%d): " "${#branches_ref[@]}"
    read -r choice

    while true; do
        if [[ "$choice" =~ ^[0-9]+$ ]] && [ "$choice" -ge 1 ] && [ "$choice" -le "${#branches_ref[@]}" ]; then
            # SC2034: selected_ref is a nameref that assigns to caller's variable
            # shellcheck disable=SC2034
            selected_ref="${branches_ref[$((choice - 1))]}"
            return 0
        else
            printf "Invalid choice. Please enter a number between 1 and %d: " "${#branches_ref[@]}"
            read -r choice
        fi
    done
}

################################################################################
# Commit Range Analysis Functions
################################################################################

# Counts commits in a range
# Usage: count=$(count_commits_in_range "start" ["end"])
# Parameters:
#   $1 - Start commit (exclusive)
#   $2 - (Optional) End commit (inclusive), defaults to HEAD
# Output:
#   Number of commits in range to stdout
count_commits_in_range() {
    local start="$1"
    local end="${2:-HEAD}"

    git rev-list --count "$start..$end" 2>/dev/null || echo 0
}

# Prints a list of commits in a given range
# Usage: print_commit_list_in_range "start" ["end"]
# Parameters:
#   $1 - Start commit (exclusive)
#   $2 - (Optional) End commit (inclusive), defaults to HEAD
# Output:
#   Formatted commit list to stdout (typically redirected to stderr for prompts)
# Note:
#   This is the standard utility for displaying commit lists to users
#   Uses 'hug ll' command for consistent formatting
print_commit_list_in_range() {
    local start="$1"
    local end="${2:-HEAD}"

    hug ll "$start..$end"
}

# Lists changed files in a commit range
# Usage: files=$(list_changed_files_in_range "start" ["end"])
# Parameters:
#   $1 - Start commit (exclusive)
#   $2 - (Optional) End commit (inclusive), defaults to HEAD
# Output:
#   Sorted unique list of changed file paths to stdout
list_changed_files_in_range() {
    local start="$1"
    local end="${2:-HEAD}"

    git log --name-only --pretty=format: "$start..$end" | sed '/^$/d' | sort -u
}

# Counts changed files in a commit range
# Usage: count=$(count_changed_files_in_range "start" ["end"])
# Parameters:
#   $1 - Start commit (exclusive)
#   $2 - (Optional) End commit (inclusive), defaults to HEAD
# Output:
#   Number of unique changed files to stdout
count_changed_files_in_range() {
    local start="$1"
    local end="${2:-HEAD}"

    list_changed_files_in_range "$start" "$end" | wc -l | awk '{print $1}'
}

################################################################################
# Upstream Operation Handlers
################################################################################

# Handles upstream validation, preview, and confirmation for operations
# Usage: target=$(handle_upstream_operation "action_name")
# Parameters:
#   $1 - Action description verb (e.g., "rewinding", "squashing")
# Output:
#   Upstream commit hash to stdout
# Environment:
#   HUG_QUIET - If not "T", displays preview and confirmation prompts
# Exits:
#   With info message if already synced to upstream
# Note:
#   This helper is read-only: never mutates commits, index, or working tree
#   After gathering preview information and confirmation, echoes upstream commit
handle_upstream_operation() {
    local action_name="$1"

    local target
    target=$(get_upstream_commit) # This will exit if no upstream

    local local_commits
    local_commits=$(count_commits_in_range "$target" HEAD)

    if [ "$local_commits" -eq 0 ]; then
        info "Already synced to upstream ($(git rev-parse --short "$target"))."
        exit 0
    fi

    if [[ ${HUG_QUIET:-} != T ]]; then
        local upstream_short upstream_branch
        upstream_short=$(git rev-parse --short "$target")
        upstream_branch=$(git for-each-ref --format='%(upstream:short)' "$(git symbolic-ref HEAD)" 2>/dev/null || echo "upstream")

        printf 'Commits to be affected:\n' >&2
        print_commit_list_in_range "$target" HEAD >&2

        local range_for_diff
        range_for_diff="$target..HEAD"

        # Check if there are any file changes to show stats for
        if git diff --quiet "$range_for_diff"; then
            printf '\nPreview: no file changes in %d local commits to %s (%s).\n' >&2 \
                "$local_commits" "$upstream_short" "$upstream_branch"
        else
            printf '\nPreview: changes in %d local commits to %s (%s):\n' >&2 \
                "$local_commits" "$upstream_short" "$upstream_branch"
            git diff --stat "$range_for_diff" >&2
        fi

        printf '\n⚠️  This action involves %s to upstream.\n' "$action_name" >&2
        prompt_confirm "Proceed with $action_name to upstream? [y/N]: "
    fi

    echo "$target"
}

# Handles validation, preview, and confirmation for standard local operations
# Usage: handle_standard_operation "action_name" "target_commit"
# Parameters:
#   $1 - Action description verb (e.g., "soft resetting", "rewinding")
#   $2 - Target commit to reset/move to
# Environment:
#   HUG_QUIET - If not "T", displays preview information
# Exits:
#   With info message if already at target
# Note:
#   This helper is read-only: never mutates commits, index, or working tree
#   Displays commit list and file change statistics for the operation
handle_standard_operation() {
    local action_name="$1"
    local target="$2"

    local commits_to_affected
    commits_to_affected=$(count_commits_in_range "$target" HEAD)

    if [ "$commits_to_affected" -eq 0 ]; then
        info "Already at target $(git rev-parse --short "$target"). No action taken."
        exit 0
    fi

    if [[ ${HUG_QUIET:-} != T ]]; then
        local range_for_diff
        range_for_diff="$target..HEAD"
        local commit_word="commit"
        if [ "$commits_to_affected" -gt 1 ]; then
            commit_word="commits"
        fi

        printf 'Commits to be affected:\n' >&2
        print_commit_list_in_range "$target" HEAD >&2

        if git diff --quiet "$range_for_diff"; then
            printf '\nPreview: no file changes in %d %s.\n' >&2 \
                "$commits_to_affected" "$commit_word"
        else
            printf '\nPreview: changes in %d %s:\n' >&2 \
                "$commits_to_affected" "$commit_word"
            git diff --stat "$range_for_diff" >&2
        fi
    fi
}
