# shellcheck shell=bash
# Library: HUG array utilities
#
# Provides helpers for working with Bash arrays inside hug commands.
# Functions:
#   - dedupe_array: remove duplicate entries while preserving order.
#   - print_list: render a titled list with a count.
#   - search_items_by_fields: universal multi-field search functionality.
#   - search_worktree: specialized worktree search (path + branch).
#   - search_branch_line: branch line search (matches whole output line).


################################################################################
# Array Manipulation Functions
################################################################################

# Removes duplicate entries from an array in-place
# Usage: dedupe_array array_name
# Parameters:
#   $1 - Name of the array variable to deduplicate (nameref)
# Note:
#   Modifies the array in-place, preserving order of first occurrence
#   Empty strings are filtered out
dedupe_array() {
  local -n __array_ref=$1
  local -A __seen=()
  local -a __unique=()
  local item
  for item in "${__array_ref[@]}"; do
    [[ -z "$item" ]] && continue
    if [[ -z "${__seen[$item]+_}" ]]; then
      __seen["$item"]=1
      __unique+=("$item")
    fi
  done
  __array_ref=("${__unique[@]}")
}

# Prints a titled list of items
# Usage: print_list "Title" item1 item2 item3...
# Parameters:
#   $1 - Title for the list
#   $@ - Items to list (remaining arguments)
# Output:
#   Title with count, followed by indented items
print_list() {
  local title=$1
  shift
  printf '%s (%d):\n' "$title" "$#"
  local item
  for item in "$@"; do
    printf '  %s\n' "$item"
  done
}

################################################################################
# Universal Search Functions
################################################################################

# Core universal search function for multi-field matching
# Usage: search_items_by_fields "search_terms" "logic_type" field1 field2 ...
# Parameters:
#   $1 - Search terms (space-separated, case-insensitive)
#   $2 - Logic type: "OR" (any term matches) or "AND" (all terms match)
#   $@+ - Field values to search against
# Returns: 0 if match found according to logic, 1 otherwise
#
# Feature Flag:
#   Set HUG_USE_PYTHON_SEARCH=false to use Bash implementation instead of Python.
#   This allows for easy rollback if issues arise with the Python module.
search_items_by_fields() {
  local search_terms="$1"
  local logic_type="${2:-OR}"
  shift 2

  # Early return if no search terms provided
  if [[ -z "$search_terms" ]]; then
    return 0  # No search terms means match everything
  fi

  # Use Python implementation if feature flag is enabled (default)
  if [[ "${HUG_USE_PYTHON_SEARCH:-true}" == "true" ]]; then
    # Declare local variables before eval to prevent nameref conflicts
    local -i _search_matched
    local _search_logic
    local -a _search_terms=()

    # Build fields string for Python (space-separated)
    local fields_string
    fields_string=$(printf '%s ' "$@")

    # Call Python module and eval its output
    eval "$(python3 "${HUG_HOME:-$HOME}/git-config/lib/python/git/search.py" \
              search --terms "$search_terms" --logic "$logic_type" --fields "$fields_string")"

    # Return based on Python's result (0=match, 1=no match)
    return "$_search_matched"
  fi

  # Bash fallback implementation
  # Split search terms into array
  local -a terms=($search_terms)
  local term_count=${#terms[@]}

  # For OR logic: return true if any term matches any field
  if [[ "$logic_type" == "OR" ]]; then
    local term
    for term in "${terms[@]}"; do
      local field
      for field in "$@"; do
        if [[ "${field,,}" == *"${term,,}"* ]]; then
          return 0  # Match found
        fi
      done
    done
    return 1  # No matches found
  fi

  # For AND logic: all terms must match at least one field each
  local term
  for term in "${terms[@]}"; do
    local term_matched=false
    local field
    for field in "$@"; do
      if [[ "${field,,}" == *"${term,,}"* ]]; then
        term_matched=true
        break
      fi
    done

    if [[ "$term_matched" == "false" ]]; then
      return 1  # This term didn't match any field
    fi
  done

  return 0  # All terms matched
}

# Specialized worktree search (path + branch fields)
# Usage: search_worktree "path" "branch" "search_terms" "logic_type"
# Parameters:
#   $1 - Worktree path
#   $2 - Worktree branch name
#   $3 - Search terms (space-separated)
#   $4 - Logic type (optional, defaults to "OR")
# Returns: 0 if worktree matches search criteria, 1 otherwise
search_worktree() {
  local path="$1"
  local branch="$2"
  local search_terms="$3"
  local logic_type="${4:-OR}"

  search_items_by_fields "$search_terms" "$logic_type" "$path" "$branch"
}

# Branch line search (matches whole output line)
# Usage: search_branch_line "branch_line" "search_terms" "logic_type"
# Parameters:
#   $1 - Full branch output line to search
#   $2 - Search terms (space-separated)
#   $3 - Logic type (optional, defaults to "OR")
# Returns: 0 if branch line matches search criteria, 1 otherwise
search_branch_line() {
  local branch_line="$1"
  local search_terms="$2"
  local logic_type="${3:-OR}"

  search_items_by_fields "$search_terms" "$logic_type" "$branch_line"
}
