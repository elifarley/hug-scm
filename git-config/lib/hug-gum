# shellcheck shell=bash
# Library: HUG gum integration helpers
# REQUIRES hug-output
#
# Detects whether charmbracelet/gum is available for enhanced UX.
# Functions:
#   - gum_available: return success when gum can be used.
#   - gum_calculate_height: calculate appropriate height for gum filter
#   - normalize_selection: normalize gum selection (strip markers, whitespace, etc.)
#   - gum_invoke_filter: low-level gum filter invocation with standard flags
#   - gum_filter_select: wrapper for gum filter with standard flags
#   - gum_filter_by_index: select items and return 0-based indices for flexible extraction

################################################################################
# Gum Integration Helpers
################################################################################

gum_available() {
  # Check if gum is explicitly disabled via environment variable
  if [[ "${HUG_DISABLE_GUM:-}" == "true" ]]; then
    return 1
  fi
  # Check if gum command is available in PATH
  command -v gum >/dev/null 2>&1
}

gum_log() {
  test "${HUG_QUIET:-}" && return
  local prefix="$1"; shift
  gum_available && gum log -s --prefix="$prefix" -- "$@" || \
    printf "%s: %s\n" "$prefix" "$@" >&2
}

# Calculate optimal height for gum filter based on number of items
# Usage: gum_calculate_height <num_items>
# Returns: height value suitable for --height flag
gum_calculate_height() {
  local num_items="$1"
  # Use + 3 for proper spacing (placeholder + 2 lines padding)
  # Cap at 15 for reasonable screen usage
  echo $((num_items < 13 ? num_items + 3 : 15))
}

# Normalize a gum filter selection by stripping markers and whitespace
# Usage: normalize_selection <selection_string>
# Returns: normalized string to stdout
# 
# Removes:
#   - ANSI color codes (e.g., \x1b[33m, \x1b[0m)
#   - Leading `* ` or `*` markers (current branch indicator)
#   - Leading/trailing whitespace
#   - Arrows (→) and text after them
#   - Parentheses and text after them (for formats like "branch (hash)")
#   - Upstream status indicators (e.g., "[origin/feat: ahead 2]")
normalize_selection() {
  local selection="$1"
  
  # Strip ANSI color codes first
  selection=$(sed 's/\033\[[0-9;]*[a-zA-Z]//g' <<< "$selection")
  
  # Strip leading `* ` or `*` marker
  if [[ "$selection" == \** ]]; then
    selection="${selection#\* }"
    selection="${selection#\*}"
  fi
  
  # Strip leading whitespace
  selection="${selection#"${selection%%[![:space:]]*}"}"
  
  # Strip trailing whitespace
  local trailing_whitespace="${selection##*[![:space:]]}"
  selection="${selection%"$trailing_whitespace"}"
  
  # Strip upstream status indicators like ": ahead N" or ": behind N" BEFORE other extractions
  # This is more precise than stripping all colons and preserves valid colons in branch names
  if [[ "$selection" == *": ahead "* ]]; then
    selection="${selection%%: ahead *}"
  elif [[ "$selection" == *": behind "* ]]; then
    selection="${selection%%: behind *}"
  elif [[ "$selection" == *": gone "* ]]; then
    selection="${selection%%: gone *}"
  fi
  
  # If selection contains " → ", extract everything before it
  if [[ "$selection" == *" → "* ]]; then
    selection="${selection%% → *}"
  # If selection contains " (", extract everything before it
  elif [[ "$selection" == *" ("* ]]; then
    selection="${selection%% (*}"
  # Otherwise, just take the first word
  else
    selection="${selection%% *}"
  fi
  
  echo "$selection"
}

# Low-level gum filter invocation with standard flags
# Usage: gum_invoke_filter <options_array_name> <placeholder> [--no-limit]
# Parameters:
#   $1 - Name of array containing options (nameref)
#   $2 - Placeholder text for gum prompt
#   $3 - Optional: --no-limit for multi-select
# Output:
#   Selected line(s) to stdout (one per line if multi-select)
# Returns:
#   0 if selection made, 1 if cancelled or no options
gum_invoke_filter() {
  local -n options_ref="$1"
  local placeholder="$2"
  local no_limit=""
  
  # Check for --no-limit flag
  if [[ "${3:-}" == "--no-limit" ]]; then
    no_limit="--no-limit"
  fi
  
  if [ ${#options_ref[@]} -eq 0 ]; then
    return 1
  fi
  
  local height
  height=$(gum_calculate_height "${#options_ref[@]}")
  
  # Build gum args
  local -a gum_args=(
    --placeholder="$placeholder"
    --height="$height"
    --no-strip-ansi
  )
  
  # When --no-limit is present, we should NOT use --reverse because even though we would expect Gum
  # to reverse the movement caused by the <TAB> key (it should go up instead of down), it's still the same
  # downward movement, making it harder to select multiple items.
  [ -n "$no_limit" ] && gum_args+=(--no-limit) || gum_args+=(--reverse)
  
  local selection
  selection=$(printf '%s\n' "${options_ref[@]}" | gum filter "${gum_args[@]}" || true)
  
  if [ -z "$selection" ]; then
    return 1
  fi
  
  printf '%s\n' "$selection"
  return 0
}

# Wrapper for gum filter with common flags
# Usage: gum_filter_select <placeholder> [additional_flags...]
# Reads options from stdin, outputs selection to stdout
# Returns: 0 if selection made, 1 if cancelled
gum_filter_select() {
  local placeholder="$1"
  shift
  
  # Read input into array
  local -a options=()
  mapfile -t options
  
  # Use gum_invoke_filter for the actual invocation
  gum_invoke_filter options "$placeholder" "$@"
}

# Gum filter with index-based returns for flexible extraction
# Usage: gum_filter_by_index <options_array_name> <placeholder> [--no-limit]
#
# Arguments:
#   $1 - Name of array containing formatted options for display (nameref)
#   $2 - Placeholder text for gum prompt
#   --no-limit - Optional: Allow multi-selection
#
# Output:
#   0-based index or indices (one per line) of selected items
#
# Returns:
#   0 if items selected, 1 if cancelled or no match found
#
# Examples:
#   # Simple index return (matches against formatted_options exactly)
#   index=$(gum_filter_by_index formatted_options "Select item...")
#   selected="${values[$index]}"
#
#   # Multi-select
#   gum_filter_by_index formatted_options "Select files..." --no-limit
#
gum_filter_by_index() {
  local options_array_name="$1"
  local -n options_ref="$options_array_name"
  local placeholder="$2"
  shift 2
  
  # Parse optional flags
  local no_limit=""
  
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --no-limit)
        no_limit="--no-limit"
        shift
        ;;
      *)
        shift
        ;;
    esac
  done
  
  if [ ${#options_ref[@]} -eq 0 ]; then
    return 1
  fi
  
  # Use gum_invoke_filter for the actual invocation
  local selection
  if [ -n "$no_limit" ]; then
    selection=$(gum_invoke_filter "$options_array_name" "$placeholder" "$no_limit")
  else
    selection=$(gum_invoke_filter "$options_array_name" "$placeholder")
  fi
  
  if [ -z "$selection" ]; then
    test "${HUG_QUIET:-}" || info "No selection made." >&2
    return 1
  fi
  
  # Process each selected line and find its index via exact match
  local -a result_indices=()
  while IFS= read -r line; do
    [[ -z "$line" ]] && continue
    
    local found=false
    local i
    for i in "${!options_ref[@]}"; do
      if [[ "${options_ref[i]}" == "$line" ]]; then
        result_indices+=("$i")
        found=true
        break
      fi
    done
    
    # Warn if we couldn't match this selection
    if [[ "$found" == false ]]; then
      test "${HUG_QUIET:-}" || warn "Skipped invalid selection: $line" >&2
    fi
  done <<< "$selection"
  
  if [ ${#result_indices[@]} -eq 0 ]; then
    test "${HUG_QUIET:-}" || info "No valid selection." >&2
    return 1
  fi
  
  printf '%s\n' "${result_indices[@]}"
  return 0
}
