# shellcheck shell=bash
# Library: HUG gum integration helpers
# REQUIRES hug-output
#
# Detects whether charmbracelet/gum is available for enhanced UX.
# Functions:
#   - gum_available: return success when gum can be used.
#   - gum_calculate_height: calculate appropriate height for gum filter
#   - normalize_selection: normalize gum selection (strip markers, whitespace, etc.)
#   - gum_invoke_filter: low-level gum filter invocation with standard flags
#   - gum_filter_select: wrapper for gum filter with standard flags
#   - gum_filter_extract: select items and extract specific field from each
#   - gum_filter_by_index: select items and return 0-based indices for flexible extraction

################################################################################
# Gum Integration Helpers
################################################################################

gum_available() {
  # Check if gum is explicitly disabled via environment variable
  if [[ "${HUG_DISABLE_GUM:-}" == "true" ]]; then
    return 1
  fi
  # Check if gum command is available in PATH
  command -v gum >/dev/null 2>&1
}

gum_log() {
  test "${HUG_QUIET:-}" && return
  local prefix="$1"; shift
  gum_available && gum log -s --prefix="$prefix" -- "$@" || \
    printf "%s: %s\n" "$prefix" "$@" >&2
}

# Calculate optimal height for gum filter based on number of items
# Usage: gum_calculate_height <num_items>
# Returns: height value suitable for --height flag
gum_calculate_height() {
  local num_items="$1"
  # Use + 3 for proper spacing (placeholder + 2 lines padding)
  # Cap at 15 for reasonable screen usage
  echo $((num_items < 13 ? num_items + 3 : 15))
}

# Normalize a gum filter selection by stripping markers and whitespace
# Usage: normalize_selection <selection_string>
# Returns: normalized string to stdout
# 
# Removes:
#   - Leading `* ` or `*` markers (current branch indicator)
#   - Leading/trailing whitespace
#   - Arrows (→) and text after them
#   - Parentheses and text after them (for formats like "branch (hash)")
normalize_selection() {
  local selection="$1"
  
  # Strip leading `* ` or `*` marker
  if [[ "$selection" == \** ]]; then
    selection="${selection#\* }"
    selection="${selection#\*}"
  fi
  
  # Strip leading whitespace
  selection="${selection#"${selection%%[![:space:]]*}"}"
  
  # Strip trailing whitespace
  local trailing_whitespace="${selection##*[![:space:]]}"
  selection="${selection%"$trailing_whitespace"}"
  
  # If selection contains " → ", extract everything before it
  if [[ "$selection" == *" → "* ]]; then
    selection="${selection%% → *}"
  # If selection contains " (", extract everything before it
  elif [[ "$selection" == *" ("* ]]; then
    selection="${selection%% (*}"
  # Otherwise, just take the first word
  else
    selection="${selection%% *}"
  fi
  
  echo "$selection"
}

# Low-level gum filter invocation with standard flags
# Usage: gum_invoke_filter <options_array_name> <placeholder> [--no-limit]
# Parameters:
#   $1 - Name of array containing options (nameref)
#   $2 - Placeholder text for gum prompt
#   $3 - Optional: --no-limit for multi-select
# Output:
#   Selected line(s) to stdout (one per line if multi-select)
# Returns:
#   0 if selection made, 1 if cancelled or no options
gum_invoke_filter() {
  local -n options_ref="$1"
  local placeholder="$2"
  local no_limit=""
  
  # Check for --no-limit flag
  if [[ "${3:-}" == "--no-limit" ]]; then
    no_limit="--no-limit"
  fi
  
  if [ ${#options_ref[@]} -eq 0 ]; then
    return 1
  fi
  
  local height
  height=$(gum_calculate_height "${#options_ref[@]}")
  
  # Build gum args
  local -a gum_args=(
    --placeholder="$placeholder"
    --height="$height"
    --no-strip-ansi
  )
  
  # When --no-limit is present, we should NOT use --reverse because even though we would expect Gum
  # to reverse the movement caused by the <TAB> key (it should go up instead of down), it's still the same
  # downward movement, making it harder to select multiple items.
  [ -n "$no_limit" ] && gum_args+=(--no-limit) || gum_args+=(--reverse)
  
  local selection
  selection=$(printf '%s\n' "${options_ref[@]}" | gum filter "${gum_args[@]}" || true)
  
  if [ -z "$selection" ]; then
    return 1
  fi
  
  printf '%s\n' "$selection"
  return 0
}

# Wrapper for gum filter with common flags
# Usage: gum_filter_select <placeholder> [additional_flags...]
# Reads options from stdin, outputs selection to stdout
# Returns: 0 if selection made, 1 if cancelled
gum_filter_select() {
  local placeholder="$1"
  shift
  
  # Read input into array
  local -a options=()
  mapfile -t options
  
  # Use gum_invoke_filter for the actual invocation
  gum_invoke_filter options "$placeholder" "$@"
}

# Enhanced gum filter with automatic field extraction
# Usage: gum_filter_extract <placeholder> <cancel_message> <extractor_function> [--no-limit] < formatted_options
# 
# Arguments:
#   placeholder: Text to show in gum filter placeholder
#   cancel_message: Message to display when user cancels or no items selected (e.g., "No files selected")
#   extractor_function: Function name to extract desired field from each selected line
#                       The function receives one line as argument and should output the extracted value
#   --no-limit: Optional flag to allow multi-selection
#
# Returns: 
#   0 if items selected (outputs extracted values, one per line)
#   1 if cancelled or no items selected
#
# Example extractor functions:
#   extract_first_word() { echo "${1%% *}"; }
#   extract_second_word() { local line="$1"; echo "${line#* }" | cut -d' ' -f1; }
#
gum_filter_extract() {
  local placeholder="$1"
  local cancel_message="$2"
  local extractor_function="$3"
  shift 3
  
  # Check for --no-limit flag
  local no_limit=""
  if [[ "$1" == "--no-limit" ]]; then
    no_limit="--no-limit"
    shift
  fi
  
  # Read input into array
  local -a options=()
  mapfile -t options
  
  if [ ${#options[@]} -eq 0 ]; then
    return 1
  fi
  
  # Use gum_invoke_filter for the actual invocation
  local selection
  if ! selection=$(gum_invoke_filter options "$placeholder" $no_limit); then
    info "$cancel_message"
    return 1
  fi
  
  # Extract field from each selected line
  local -a extracted=()
  while IFS= read -r line; do
    [[ -z "$line" ]] && continue
    local extracted_value
    extracted_value=$("$extractor_function" "$line")
    [[ -n "$extracted_value" ]] && extracted+=("$extracted_value")
  done <<< "$selection"
  
  if [ ${#extracted[@]} -eq 0 ]; then
    info "$cancel_message"
    return 1
  fi
  
  printf '%s\n' "${extracted[@]}"
  return 0
}

# Gum filter with index-based returns for flexible extraction
# Usage: gum_filter_by_index <options_array_name> <placeholder> [--match-keys <keys_array_name>] [--no-limit]
#
# Arguments:
#   $1 - Name of array containing formatted options for display (nameref)
#   $2 - Placeholder text for gum prompt
#   --match-keys <array_name> - Optional: Name of array containing keys for matching (e.g., branch names)
#                               If provided, will try to match normalized selection against keys first
#   --no-limit - Optional: Allow multi-selection
#
# Output:
#   0-based index or indices (one per line) of selected items
#
# Returns:
#   0 if items selected, 1 if cancelled or no match found
#
# Examples:
#   # Simple index return (matches formatted_options)
#   index=$(gum_filter_by_index formatted_options "Select item...")
#   selected="${values[$index]}"
#
#   # With match keys for reliable extraction
#   indices=$(gum_filter_by_index formatted_options "Select branches..." --match-keys branches)
#   for idx in $indices; do
#     echo "Selected: ${branches[$idx]}"
#   done
#
#   # Multi-select
#   gum_filter_by_index formatted_options "Select files..." --no-limit
#
gum_filter_by_index() {
  local options_array_name="$1"
  local -n options_ref="$options_array_name"
  local placeholder="$2"
  shift 2
  
  # Parse optional flags
  local match_keys_array_name=""
  local no_limit=""
  local have_match_keys=false
  
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --match-keys)
        if [[ -n "${2:-}" ]]; then
          match_keys_array_name="$2"
          have_match_keys=true
          shift 2
        else
          return 1
        fi
        ;;
      --no-limit)
        no_limit="--no-limit"
        shift
        ;;
      *)
        shift
        ;;
    esac
  done
  
  if [ ${#options_ref[@]} -eq 0 ]; then
    return 1
  fi
  
  # Use gum_invoke_filter for the actual invocation
  local selection
  if ! selection=$(gum_invoke_filter "$options_array_name" "$placeholder" $no_limit); then
    return 1
  fi
  
  # Process each selected line and find its index
  local -a result_indices=()
  while IFS= read -r line; do
    [[ -z "$line" ]] && continue
    
    # Try exact match first
    local i
    for i in "${!options_ref[@]}"; do
      if [[ "${options_ref[i]}" == "$line" ]]; then
        result_indices+=("$i")
        continue 2  # Skip to next line
      fi
    done
    
    # If no exact match and we have match keys, try normalized matching
    if [[ "$have_match_keys" == true ]]; then
      local -n match_keys_ref="$match_keys_array_name"
      local normalized_key
      normalized_key=$(normalize_selection "$line")
      
      for i in "${!match_keys_ref[@]}"; do
        if [[ "${match_keys_ref[i]}" == "$normalized_key" ]]; then
          result_indices+=("$i")
          break
        fi
      done
    fi
  done <<< "$selection"
  
  if [ ${#result_indices[@]} -eq 0 ]; then
    return 1
  fi
  
  printf '%s\n' "${result_indices[@]}"
  return 0
}
