# shellcheck shell=bash
# Library: HUG gum integration helpers
#
# Detects whether charmbracelet/gum is available for enhanced UX.
# Functions:
#   - gum_available: return success when gum can be used.
#   - gum_calculate_height: calculate appropriate height for gum filter
#   - gum_filter_select: wrapper for gum filter with standard flags
#   - gum_filter_extract: select items and extract specific field from each

################################################################################
# Gum Integration Helpers
################################################################################

gum_available() {
  # Check if gum is explicitly disabled via environment variable
  if [[ "${HUG_DISABLE_GUM:-}" == "true" ]]; then
    return 1
  fi
  # Check if gum command is available in PATH
  command -v gum >/dev/null 2>&1
}

gum_log() {
  test "${HUG_QUIET:-}" && return
  local prefix="$1"; shift
  gum_available && gum log -s --prefix="$prefix" -- "$@" || \
    printf "%s: %s\n" "$prefix" "$@" >&2
}

# Calculate optimal height for gum filter based on number of items
# Usage: gum_calculate_height <num_items>
# Returns: height value suitable for --height flag
gum_calculate_height() {
  local num_items="$1"
  # Use + 3 for proper spacing (placeholder + 2 lines padding)
  # Cap at 15 for reasonable screen usage
  echo $((num_items < 13 ? num_items + 3 : 15))
}

# Wrapper for gum filter with common flags
# Usage: gum_filter_select <placeholder> [additional_flags...]
# Reads options from stdin, outputs selection to stdout
# Returns: 0 if selection made, 1 if cancelled
gum_filter_select() {
  local placeholder="$1"
  shift
  
  # Read input into array to calculate height
  local -a options=()
  mapfile -t options
  
  if [ ${#options[@]} -eq 0 ]; then
    return 1
  fi
  
  local height
  height=$(gum_calculate_height "${#options[@]}")
  
  # Output options and run gum filter with standard flags
  local selection
  selection=$(printf '%s\n' "${options[@]}" | \
    gum filter --placeholder="$placeholder" \
                --height="$height" \
                --no-strip-ansi \
                --reverse \
                "$@" || true)
  
  if [ -z "$selection" ]; then
    return 1
  fi
  
  printf '%s\n' "$selection"
  return 0
}

# Helper function to display info message (with fallback)
_gum_filter_info() {
  local message="$1"
  # Source hug-output for info function if not already available
  if [[ -n "${HUG_HOME:-}" ]] && [[ -f "$HUG_HOME/git-config/lib/hug-output" ]]; then
    # shellcheck source=git-config/lib/hug-output
    . "$HUG_HOME/git-config/lib/hug-output"
    info "$message"
  else
    # Fallback if hug-output not available
    printf "%s\n" "$message" >&2
  fi
}

# Enhanced gum filter with automatic field extraction
# Usage: gum_filter_extract <placeholder> <cancel_message> <extractor_function> [--no-limit] < formatted_options
# 
# Arguments:
#   placeholder: Text to show in gum filter placeholder
#   cancel_message: Message to display when user cancels or no items selected (e.g., "No files selected")
#   extractor_function: Function name to extract desired field from each selected line
#                       The function receives one line as argument and should output the extracted value
#   --no-limit: Optional flag to allow multi-selection
#
# Returns: 
#   0 if items selected (outputs extracted values, one per line)
#   1 if cancelled or no items selected
#
# Example extractor functions:
#   extract_first_word() { echo "${1%% *}"; }
#   extract_second_word() { local line="$1"; echo "${line#* }" | cut -d' ' -f1; }
#
gum_filter_extract() {
  local placeholder="$1"
  local cancel_message="$2"
  local extractor_function="$3"
  shift 3
  
  # Check for --no-limit flag
  local no_limit=""
  if [[ "$1" == "--no-limit" ]]; then
    no_limit="--no-limit"
    shift
  fi
  
  # Read input into array to calculate height
  local -a options=()
  mapfile -t options
  
  if [ ${#options[@]} -eq 0 ]; then
    return 1
  fi
  
  local height
  height=$(gum_calculate_height "${#options[@]}")
  
  # Run gum filter with standard flags
  local selection
  if [ -n "$no_limit" ]; then
    selection=$(printf '%s\n' "${options[@]}" | \
      gum filter --placeholder="$placeholder" \
                  --height="$height" \
                  --no-strip-ansi \
                  --reverse \
                  --no-limit || true)
  else
    selection=$(printf '%s\n' "${options[@]}" | \
      gum filter --placeholder="$placeholder" \
                  --height="$height" \
                  --no-strip-ansi \
                  --reverse || true)
  fi
  
  if [ -z "$selection" ]; then
    _gum_filter_info "$cancel_message"
    return 1
  fi
  
  # Extract field from each selected line
  local -a extracted=()
  while IFS= read -r line; do
    [[ -z "$line" ]] && continue
    local extracted_value
    extracted_value=$("$extractor_function" "$line")
    [[ -n "$extracted_value" ]] && extracted+=("$extracted_value")
  done <<< "$selection"
  
  if [ ${#extracted[@]} -eq 0 ]; then
    _gum_filter_info "$cancel_message"
    return 1
  fi
  
  printf '%s\n' "${extracted[@]}"
  return 0
}
