# shellcheck shell=bash
# Library: HUG interactive file selection
#
# Implements gum-powered file selection with git status annotations.
# Depends on: hug-gum, hug-output, hug-terminal, hug-git-files (for list_* functions), hug-git-priorities.
# Functions:
#   - list_files_with_status: list staged/unstaged/untracked files with color-coded status (non-interactive).
#   - select_files_with_status: filter staged/unstaged/untracked files interactively.

# Non-interactive file listing with status annotations
# Usage: list_files_with_status [OPTIONS] [PATHSPECS...]
# Options:
#   --staged             Include staged files
#   --unstaged           Include unstaged files
#   --untracked          Include untracked files
#   --ignored            Include ignored files
#   --cwd                Scope file listing to current directory and subdirectories only
#   PATHSPECS...          Pathspecs to filter files (wildcards, directories, file patterns)
# Output:
#   Formatted file list to stdout, one per line, with color-coded status prefix
#   Format: "<status_label> <filename>"
#   Examples:
#     S:Add  staged.txt
#     U:Mod  README.md
#     untrcK untracked.txt
# Returns:
#   0 if files found and listed, 1 if no files found
# Defaults:
#   - If no --staged/--unstaged/--untracked/--ignored provided, falls back to all tracked files via 'git ls-files' (displayed plainly)
#   - Without --cwd, lists files across entire repository
#   - Without PATHSPECS, lists all files of the requested types

# Helper function: Format staged file status
# Input: $status - Git status code (A, M, D, R*, C*, U)
# Output: Tab-delimited "status_text<tab>status_code"
# Usage: IFS=$'\t' read -r status_text status_code <<< "$(_format_staged_status "$status")"
_format_staged_status() {
  local status="$1"
  local status_text status_code

  case "$status" in
    A)  status_text="${GREEN}S:Add ${NC}"; status_code="S:Add" ;;
    M)  status_text="${GREEN}S:${YELLOW}Mod ${NC}"; status_code="S:Mod" ;;
    D)  status_text="${GREEN}S:${RED}Del ${NC}"; status_code="S:Del" ;;
    R*) status_text="${GREEN}S:${CYAN}Ren ${NC}"; status_code="S:Ren" ;;
    C*) status_text="${GREEN}S:${BLUE}Copy${NC}"; status_code="S:Copy" ;;
    U)  status_text="${YELLOW}Cnflt ${NC}"; status_code="S:Cnflt" ;;
    *)  status_text="${GREEN}S     ${NC}"; status_code="S:Unk" ;;
  esac

  printf '%s\t%s' "$status_text" "$status_code"
}

# Helper function: Format unstaged file status
# Input: $status - Git status code (M, D, U)
# Output: Tab-delimited "status_text<tab>status_code"
# Usage: IFS=$'\t' read -r status_text status_code <<< "$(_format_unstaged_status "$status")"
_format_unstaged_status() {
  local status="$1"
  local status_text status_code

  case "$status" in
    M) status_text="${RED}U:${YELLOW}Mod ${NC}"; status_code="U:Mod" ;;
    D) status_text="${RED}U:Del ${NC}"; status_code="U:Del" ;;
    U) status_text="${YELLOW}Cnflt${NC}"; status_code="U:Cnflt" ;;
    *) status_text="${RED}U     ${NC}"; status_code="U:Unk" ;;
  esac

  printf '%s\t%s' "$status_text" "$status_code"
}

# Helper function: Format untracked file status
# Input: none
# Output: Tab-delimited "status_text<tab>status_code"
# Usage: IFS=$'\t' read -r status_text status_code <<< "$(_format_untracked_status)"
_format_untracked_status() {
  local status_text="${MAGENTA}untrcK${NC}"
  local status_code="untrcK"
  printf '%s\t%s' "$status_text" "$status_code"
}

# Helper function: Format ignored file status
# Input: none
# Output: Tab-delimited "status_text<tab>status_code"
# Usage: IFS=$'\t' read -r status_text status_code <<< "$(_format_ignored_status)"
_format_ignored_status() {
  local status_text="${GREY}Ignore${NC}"
  local status_code="Ignore"
  printf '%s\t%s' "$status_text" "$status_code"
}

# Helper function: Handle "no files found" case
# Input: $scope_cwd - Boolean indicating if scoped to current directory
# Output: Prints info message if scoped
# Returns: 1 (failure)
_handle_no_files_found() {
  local scope_cwd="$1"
  if $scope_cwd; then
    info "No relevant files in current directory."
  fi
  return 1
}

# Helper function: Parse tab-delimited status formatter output with validation
# Input: $1 - Raw output from _format_*_status function
# Output: Two space-separated values: status_text status_code
# Returns: 0 on success, 1 if malformed (prints error and returns)
# Usage: IFS=' ' read -r status_text status_code <<< "$(parse_tab_delimited_status "$raw_output")"
parse_tab_delimited_status() {
  local raw_output="$1"

  # Check for tab delimiter
  if [[ "$raw_output" != *$'\t'* ]]; then
    error "Internal error: Status output missing tab delimiter"
    return 1
  fi

  # Split and validate
  local status_text status_code
  IFS=$'\t' read -r status_text status_code <<< "$raw_output"

  # Validate status_code is not empty
  if [[ -z "$status_code" ]]; then
    error "Internal error: Status code is empty in formatter output"
    return 1
  fi

  # Output space-separated (safe because status_text contains ANSI codes, status_code is plain)
  printf '%s %s' "$status_text" "$status_code"
}

list_files_with_status() {
  # Source priority definitions for sorting
  if [[ -f "${HUG_LIB_DIR}/hug-git-priorities" ]]; then
    source "${HUG_LIB_DIR}/hug-git-priorities"
  else
    # Fallback if priorities file is not found
    declare -A STATUS_PRIORITY=()
    get_status_priority() { echo "0"; }
  fi

  local include_staged=false
  local include_unstaged=false
  local include_untracked=false
  local include_ignored=false
  local scope_cwd=false
  local -a pathspecs=()

  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --staged)
        include_staged=true
        shift
        ;;
      --unstaged)
        include_unstaged=true
        shift
        ;;
      --untracked)
        include_untracked=true
        shift
        ;;
      --ignored)
        include_ignored=true
        shift
        ;;
      --cwd)
        scope_cwd=true
        shift
        ;;
      *)
        # Treat remaining arguments as pathspecs
        pathspecs+=("$1")
        shift
        ;;
    esac
  done

  local has_includes=false
  if $include_staged || $include_unstaged || $include_untracked || $include_ignored; then
    has_includes=true
  fi

  local -a files=()
  local -a formatted_options=()
  local -a status_codes=()  # Store status codes for sorting

  # Build flag array for list functions
  local -a list_flags=()
  if $scope_cwd; then
    list_flags+=("--cwd")
  fi

  if ! $has_includes; then
    # No specific includes, list all tracked files plainly
    mapfile -t files < <(list_tracked_files "${list_flags[@]}")
    for file in "${files[@]}"; do
      [[ -z "$file" ]] && continue
      printf '%s\n' "$file"
    done
  else
    # Collect files based on requested types
    if $include_staged; then
      local -a status_flags=("${list_flags[@]}" "--status")
      while IFS= read -r line; do
        [[ -z "$line" ]] && continue
        local status file
        IFS=$'\t' read -r status file <<< "$line"
        local status_text status_code
        IFS=$'\t' read -r status_text status_code <<< "$(_format_staged_status "$status")"
        files+=("$file")
        formatted_options+=("${status_text} ${file}")
        status_codes+=("$status_code")
      done < <(list_staged_files "${status_flags[@]}" "${pathspecs[@]}")
    fi

    if $include_unstaged; then
      local -a status_flags=("${list_flags[@]}" "--status")
      while IFS= read -r line; do
        [[ -z "$line" ]] && continue
        local status file
        IFS=$'\t' read -r status file <<< "$line"
        local status_text status_code
        IFS=$'\t' read -r status_text status_code <<< "$(_format_unstaged_status "$status")"
        files+=("$file")
        formatted_options+=("${status_text} ${file}")
        status_codes+=("$status_code")
      done < <(list_unstaged_files "${status_flags[@]}" "${pathspecs[@]}")
    fi

    if $include_untracked; then
      mapfile -t untracked_files < <(list_untracked_files "${list_flags[@]}" "${pathspecs[@]}")
      for file in "${untracked_files[@]}"; do
        [[ -z "$file" ]] && continue
        local status_text status_code
        IFS=$'\t' read -r status_text status_code <<< "$(_format_untracked_status)"
        files+=("$file")
        formatted_options+=("${status_text} ${file}")
        status_codes+=("$status_code")
      done
    fi

    if $include_ignored; then
      mapfile -t ignored_files < <(list_ignored_files "${list_flags[@]}" "${pathspecs[@]}")
      for file in "${ignored_files[@]}"; do
        [[ -z "$file" ]] && continue
        local status_text status_code
        IFS=$'\t' read -r status_text status_code <<< "$(_format_ignored_status)"
        files+=("$file")
        formatted_options+=("${status_text} ${file}")
        status_codes+=("$status_code")
      done
    fi

    # Sort files by priority (ascending), then by file path (ascending)
    # Create array of tuples: (priority, status_code, file, formatted_option)
    local -a sorted_entries=()
    local i
    for i in "${!files[@]}"; do
      local file="${files[$i]}"
      local status_code="${status_codes[$i]}"
      local priority
      priority=$(get_status_priority "$status_code")
      sorted_entries+=("$priority|$status_code|$file|${formatted_options[$i]}")
    done

    # Sort by priority (ascending, -n), then by file path (ascending)
    IFS=$'\n' sorted_entries=($(sort -t'|' -k1,1n -k3,3 <<<"${sorted_entries[*]}"))

    # Remove duplicates while preserving sorted order
    local -A seen=()
    local -a unique_files=()
    local -a unique_formatted=()
    for entry in "${sorted_entries[@]}"; do
      IFS='|' read -r _ _ file formatted <<< "$entry"
      if [[ -z "${seen[$file]+_}" ]] && [[ -n "$file" ]]; then
        seen["$file"]=1
        unique_files+=("$file")
        unique_formatted+=("$formatted")
      fi
    done

    if [[ ${#unique_files[@]} -eq 0 ]]; then
      _handle_no_files_found "$scope_cwd"
      return $?
    fi

    # Print the formatted list in sorted order
    printf '%s\n' "${unique_formatted[@]}"
  fi
  
  return 0
}

# Advanced interactive file selection with multiple file types support
# Usage: select_files_with_status [OPTIONS]
# Options:
#   --multi              Allow multiple file selection (default: true)
#   --single             Single file selection (default: multi)
#   --staged             Include staged files
#   --unstaged           Include unstaged files
#   --untracked          Include untracked files
#   --ignored            Include ignored files
#   --no-status          Omit status column/formatting (plain file names)
#   --cwd                Scope file listing to current directory and subdirectories only
#   --prompt <text>      Custom prompt text
# Output:
#   Selected file(s) to stdout, one per line
# Returns:
#   0 if files selected, 1 if cancelled or no selection
# Dependencies:
#   - Requires _format_*_status functions to output tab-delimited "status_text<tab>status_code"
#   - parse_tab_delimited_status validates the format and fails fast on errors
# Note:
#   Requires gum to be installed
# Defaults:
#   - Multi-selection enabled
#   - If no --staged/--unstaged/--untracked/--ignored provided, falls back to all tracked files via 'git ls-files' (displayed plainly)
#   - Without --cwd, lists files across entire repository
select_files_with_status() {
  if ! gum_available; then
    error "Interactive file selection requires 'gum' to be installed.
Install: https://github.com/charmbracelet/gum"
  fi
  
  local multi=true
  local include_staged=false
  local include_unstaged=false
  local include_untracked=false
  local include_ignored=false
  local no_status=false
  local scope_cwd=false
  local prompt="Select file(s)..."
  
  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --multi)
        multi=true
        shift
        ;;
      --single)
        multi=false
        shift
        ;;
      --staged)
        include_staged=true
        shift
        ;;
      --unstaged)
        include_unstaged=true
        shift
        ;;
      --untracked)
        include_untracked=true
        shift
        ;;
      --ignored)
        include_ignored=true
        shift
        ;;
      --no-status)
        no_status=true
        shift
        ;;
      --cwd)
        scope_cwd=true
        shift
        ;;
      --prompt)
        prompt="$2"
        shift 2
        ;;
      *)
        error "Unknown option for select_files_with_status: $1"
        ;;
    esac
  done
  
  # Adjust prompt if scoped to current directory
  if $scope_cwd; then
    # If custom prompt doesn't already mention directory scope
    if [[ "$prompt" != *"current directory"* ]]; then
      prompt="${prompt% (current directory)*}" # Remove any existing suffix
      prompt="${prompt%...}" # Remove trailing ...
      prompt="$prompt (current directory)..."
    fi
  fi
  
  local has_includes=false
  if $include_staged || $include_unstaged || $include_untracked || $include_ignored; then
    has_includes=true
  fi
  
  local use_status_formatting=false
  if $has_includes && ! $no_status; then
    use_status_formatting=true
  fi
  
  local -a files=()
  local -a formatted_options=()
  
  # Build flag array for list functions
  local -a list_flags=()
  if $scope_cwd; then
    list_flags+=("--cwd")
  fi
  
  if ! $has_includes; then
    mapfile -t files < <(list_tracked_files "${list_flags[@]}")
    mapfile -t formatted_options < <(printf '%s\n' "${files[@]}")
  else
  
  # Collect files based on requested types
  if $include_staged; then
    local -a status_flags=("${list_flags[@]}")
    if $use_status_formatting; then
      status_flags+=("--status")
    fi
    if $use_status_formatting; then
      while IFS= read -r line; do
        [[ -z "$line" ]] && continue
        local status file
        IFS=$'\t' read -r status file <<< "$line"
        local status_text status_code
        IFS=' ' read -r status_text status_code <<< "$(parse_tab_delimited_status "$(_format_staged_status "$status")")"
        files+=("$file")
        formatted_options+=("${status_text} ${file}")
      done < <(list_staged_files "${status_flags[@]}")
    else
      mapfile -t staged_files < <(list_staged_files "${list_flags[@]}")
      files+=("${staged_files[@]}")
      formatted_options+=("${staged_files[@]}")
    fi
  fi
  
  if $include_unstaged; then
    local -a status_flags=("${list_flags[@]}")
    if $use_status_formatting; then
      status_flags+=("--status")
    fi
    if $use_status_formatting; then
      while IFS= read -r line; do
        [[ -z "$line" ]] && continue
        local status file
        IFS=$'\t' read -r status file <<< "$line"
        local status_text status_code
        IFS=' ' read -r status_text status_code <<< "$(parse_tab_delimited_status "$(_format_unstaged_status "$status")")"
        files+=("$file")
        formatted_options+=("${status_text} ${file}")
      done < <(list_unstaged_files "${status_flags[@]}")
    else
      mapfile -t unstaged_files < <(list_unstaged_files "${list_flags[@]}")
      files+=("${unstaged_files[@]}")
      formatted_options+=("${unstaged_files[@]}")
    fi
  fi
  
  if $include_untracked; then
    mapfile -t untracked_files < <(list_untracked_files "${list_flags[@]}")
    for file in "${untracked_files[@]}"; do
      [[ -z "$file" ]] && continue
      local status_text status_code
      if $use_status_formatting; then
        IFS=' ' read -r status_text status_code <<< "$(parse_tab_delimited_status "$(_format_untracked_status)")"
        formatted_options+=("${status_text} ${file}")
      else
        formatted_options+=("$file")
      fi
      files+=("$file")
    done
  fi
  
  if $include_ignored; then
    mapfile -t ignored_files < <(list_ignored_files "${list_flags[@]}")
    for file in "${ignored_files[@]}"; do
      [[ -z "$file" ]] && continue
      local status_text status_code
      if $use_status_formatting; then
        IFS=' ' read -r status_text status_code <<< "$(parse_tab_delimited_status "$(_format_ignored_status)")"
        formatted_options+=("${status_text} ${file}")
      else
        formatted_options+=("$file")
      fi
      files+=("$file")
    done
  fi
  fi
  
  # Remove duplicates while preserving order
  local -A seen=()
  local -a unique_files=()
  local -a unique_formatted=()
  local i
  for i in "${!files[@]}"; do
    local file="${files[$i]}"
    if [[ -z "${seen[$file]+_}" ]]; then
      seen["$file"]=1
      unique_files+=("$file")
      unique_formatted+=("${formatted_options[$i]}")
    fi
  done
  
  if [[ ${#unique_files[@]} -eq 0 ]]; then
    _handle_no_files_found "$scope_cwd"
    return $?
  fi
  
  # Calculate height for gum
  local gum_height
  gum_height=$((${#unique_files[@]} < 13 ? ${#unique_files[@]} + 3 : 15))
  
  # Build gum command
  local -a gum_args=(
    "filter"
    "--no-strip-ansi"
    "--placeholder=$prompt"
    "--height=$gum_height"
  )
  
  if $multi; then
    # When selecting multiple items, better not to reverse the order,
    # bacause Gum doesn't reverse the movement caused by the <TAB> key
    gum_args+=("--no-limit")
  else
    gum_args+=("--reverse")
  fi
  
  # Run gum and capture selection
  local selection
  selection=$(printf '%s\n' "${unique_formatted[@]}" | gum "${gum_args[@]}" || true)
  
  if [[ -z "$selection" ]]; then
    return 1
  fi
  
  # Extract file names from selection
  while IFS= read -r line; do
    [[ -z "$line" ]] && continue
    local file_name
    if $use_status_formatting; then
      # Strip ANSI codes before extracting filename
      # This handles selections from gum with --no-strip-ansi
      local stripped_line
      stripped_line=$(printf '%s' "$line" | sed $'s/\033\[[0-9;]*m//g')
      # Extract filename after status prefix (after first space)
      file_name="${stripped_line#* }"
      # Trim leading and trailing whitespace
      file_name="${file_name#"${file_name%%[![:space:]]*}"}"
      file_name="${file_name%"${file_name##*[![:space:]]}"}"
    else
      file_name="$line"
    fi
    printf '%s\n' "$file_name"
  done <<< "$selection"
  
  return 0
}
