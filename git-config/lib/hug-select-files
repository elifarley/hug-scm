# shellcheck shell=bash
# Library: HUG interactive file selection
#
# Implements gum-powered file selection with git status annotations.
# Depends on: hug-gum, hug-output, hug-terminal.
# Functions:
#   - select_files_with_status: filter staged/unstaged/untracked files interactively.

# Advanced interactive file selection with multiple file types support
# Usage: select_files_with_status [OPTIONS]
# Options:
#   --multi              Allow multiple file selection (default: true)
#   --single             Single file selection (default: multi)
#   --staged             Include staged files
#   --unstaged           Include unstaged files
#   --untracked          Include untracked files
#   --ignored            Include ignored files
#   --no-status          Omit status column/formatting (plain file names)
#   --cwd                Scope file listing to current directory and subdirectories only
#   --prompt <text>      Custom prompt text
# Output:
#   Selected file(s) to stdout, one per line
# Returns:
#   0 if files selected, 1 if cancelled or no selection
# Note:
#   Requires gum to be installed
# Defaults:
#   - Multi-selection enabled
#   - If no --staged/--unstaged/--untracked/--ignored provided, falls back to all tracked files via 'git ls-files' (displayed plainly)
#   - Without --cwd, lists files across entire repository
select_files_with_status() {
  if ! gum_available; then
    error "Interactive file selection requires 'gum' to be installed.
Install: https://github.com/charmbracelet/gum"
  fi
  
  local multi=true
  local include_staged=false
  local include_unstaged=false
  local include_untracked=false
  local include_ignored=false
  local no_status=false
  local scope_cwd=false
  local prompt="Select file(s)..."
  
  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --multi)
        multi=true
        shift
        ;;
      --single)
        multi=false
        shift
        ;;
      --staged)
        include_staged=true
        shift
        ;;
      --unstaged)
        include_unstaged=true
        shift
        ;;
      --untracked)
        include_untracked=true
        shift
        ;;
      --ignored)
        include_ignored=true
        shift
        ;;
      --no-status)
        no_status=true
        shift
        ;;
      --cwd)
        scope_cwd=true
        shift
        ;;
      --prompt)
        prompt="$2"
        shift 2
        ;;
      *)
        error "Unknown option for select_files_with_status: $1"
        ;;
    esac
  done
  
  # Adjust prompt if scoped to current directory
  if $scope_cwd; then
    # If custom prompt doesn't already mention directory scope
    if [[ "$prompt" != *"current directory"* ]]; then
      prompt="${prompt% (current directory)*}" # Remove any existing suffix
      prompt="${prompt%...}" # Remove trailing ...
      prompt="$prompt (current directory)..."
    fi
  fi
  
  local has_includes=false
  if $include_staged || $include_unstaged || $include_untracked || $include_ignored; then
    has_includes=true
  fi
  
  local use_status_formatting=false
  if $has_includes && ! $no_status; then
    use_status_formatting=true
  fi
  
  local -a files=()
  local -a formatted_options=()
  
  # Build flag array for list functions
  local -a list_flags=()
  if $scope_cwd; then
    list_flags+=("--cwd")
  fi
  
  if ! $has_includes; then
    mapfile -t files < <(list_tracked_files "${list_flags[@]}")
    mapfile -t formatted_options < <(printf '%s\n' "${files[@]}")
  else
  
  # Collect files based on requested types
  if $include_staged; then
    local -a status_flags=("${list_flags[@]}")
    if $use_status_formatting; then
      status_flags+=("--status")
    fi
    if $use_status_formatting; then
      while IFS= read -r line; do
        [[ -z "$line" ]] && continue
        local status file
        IFS=$'\t' read -r status file <<< "$line"
        local status_text
        case "$status" in
          A)  status_text="${GREEN}S:Add ${NC}" ;;
          M)  status_text="${GREEN}S:${YELLOW}Mod ${NC}" ;;
          D)  status_text="${GREEN}S:${RED}Del ${NC}" ;;
          R*) status_text="${GREEN}S:${CYAN}Ren ${NC}" ;;
          C*) status_text="${GREEN}S:${BLUE}Copy${NC}" ;;
          *)  status_text="${GREEN}S     ${NC}" ;;
        esac
        files+=("$file")
        formatted_options+=("${status_text} ${file}")
      done < <(list_staged_files "${status_flags[@]}")
    else
      mapfile -t staged_files < <(list_staged_files "${list_flags[@]}")
      files+=("${staged_files[@]}")
      formatted_options+=("${staged_files[@]}")
    fi
  fi
  
  if $include_unstaged; then
    local -a status_flags=("${list_flags[@]}")
    if $use_status_formatting; then
      status_flags+=("--status")
    fi
    if $use_status_formatting; then
      while IFS= read -r line; do
        [[ -z "$line" ]] && continue
        local status file
        IFS=$'\t' read -r status file <<< "$line"
        local status_text
        case "$status" in
          M) status_text="${RED}U:${YELLOW}Mod ${NC}" ;;
          D) status_text="${RED}U:Del ${NC}" ;;
          *) status_text="${RED}${NC}U     " ;;
        esac
        files+=("$file")
        formatted_options+=("${status_text} ${file}")
      done < <(list_unstaged_files "${status_flags[@]}")
    else
      mapfile -t unstaged_files < <(list_unstaged_files "${list_flags[@]}")
      files+=("${unstaged_files[@]}")
      formatted_options+=("${unstaged_files[@]}")
    fi
  fi
  
  if $include_untracked; then
    mapfile -t untracked_files < <(list_untracked_files "${list_flags[@]}")
    for file in "${untracked_files[@]}"; do
      [[ -z "$file" ]] && continue
      local status_text="${MAGENTA}UnTrck${NC}"
      files+=("$file")
      if $use_status_formatting; then
        formatted_options+=("${status_text} ${file}")
      else
        formatted_options+=("$file")
      fi
    done
  fi
  
  if $include_ignored; then
    mapfile -t ignored_files < <(list_ignored_files "${list_flags[@]}")
    for file in "${ignored_files[@]}"; do
      [[ -z "$file" ]] && continue
      local status_text="${GREY}Ignore${NC}"
      files+=("$file")
      if $use_status_formatting; then
        formatted_options+=("${status_text} ${file}")
      else
        formatted_options+=("$file")
      fi
    done
  fi
  fi
  
  # Remove duplicates while preserving order
  local -A seen=()
  local -a unique_files=()
  local -a unique_formatted=()
  local i
  for i in "${!files[@]}"; do
    local file="${files[$i]}"
    if [[ -z "${seen[$file]+_}" ]]; then
      seen["$file"]=1
      unique_files+=("$file")
      unique_formatted+=("${formatted_options[$i]}")
    fi
  done
  
  if [[ ${#unique_files[@]} -eq 0 ]]; then
    if $scope_cwd; then
      info "No relevant files in current directory."
    fi
    return 1
  fi
  
  # Calculate height for gum
  local gum_height
  gum_height=$((${#unique_files[@]} < 13 ? ${#unique_files[@]} + 3 : 15))
  
  # Build gum command
  local -a gum_args=(
    "filter"
    "--no-strip-ansi"
    "--placeholder=$prompt"
    "--height=$gum_height"
    "--reverse"
  )
  
  if $multi; then
    gum_args+=("--no-limit")
  fi
  
  # Run gum and capture selection
  local selection
  selection=$(printf '%s\n' "${unique_formatted[@]}" | gum "${gum_args[@]}" || true)
  
  if [[ -z "$selection" ]]; then
    return 1
  fi
  
  # Extract file names from selection
  while IFS= read -r line; do
    [[ -z "$line" ]] && continue
    local file_name
    if $use_status_formatting; then
      # Strip ANSI codes before extracting filename
      # This handles selections from gum with --no-strip-ansi
      local stripped_line
      stripped_line=$(printf '%s' "$line" | sed $'s/\033\[[0-9;]*m//g')
      # Extract filename after status prefix (after first space)
      file_name="${stripped_line#* }"
      # Trim leading and trailing whitespace
      file_name="${file_name#"${file_name%%[![:space:]]*}"}"
      file_name="${file_name%"${file_name##*[![:space:]]}"}"
    else
      file_name="$line"
    fi
    printf '%s\n' "$file_name"
  done <<< "$selection"
  
  return 0
}
