# shellcheck shell=bash
# Library: HUG confirmation prompts
#
# Reusable confirmation helpers for interactive hug commands.
# Depends on: hug-gum for charmbracelet integration, hug-output for messaging,
#             hug-strings for input trimming.
# Functions:
#   - prompt_confirm_warn: yes/no confirmation with NO default for destructive operations.
#   - confirm_action_danger: exact-word confirmation gate for dangerous operations.
#   - prompt_confirm_safe: yes/no confirmation with YES default for safe operations.

# Prompts user for confirmation with NO default (for destructive operations), exits if not confirmed
# Usage: prompt_confirm_warn ["custom prompt"]
# Parameters:
#   $1 - (Optional) Custom prompt text, defaults to "Proceed? [y/N]: "
# Environment:
#   HUG_FORCE - If true, automatically confirms without prompting
#   HUG_NONINTERACTIVE - If true, automatically cancels without prompting
# Returns:
#   0 if confirmed (or HUG_FORCE is true)
#   Exits with code 1 if user declines or read fails
prompt_confirm_warn() {
  if [[ ${HUG_FORCE:-} == true ]]; then
    return 0
  fi
  local prompt="${1:-Proceed? [y/N]: }"
  if gum_available; then
    local message="${prompt% }"
    # Set default to No (--default=false) for safety in destructive operations
    if gum confirm --default=false "$message"; then
      return 0
    fi
    info "Cancelled."
    exit 1
  fi
  # Check if we're in a non-interactive environment (no TTY)
  if [[ ! -t 0 ]] || [[ ! -t 1 ]]; then
    # In test mode, allow input simulation
    if [[ "${HUG_TEST_MODE:-}" == "true" ]]; then
      # Continue to input reading in test mode
      :
    else
      info "Non-interactive environment: cancelled."
      exit 1
    fi
  fi
  local response
  printf '%s' "$prompt" >&2
  if ! read -r response; then
    info "Cancelled."
    exit 1
  fi
  if [[ ! "$response" =~ ^[Yy]$ ]]; then
    info "Cancelled."
    exit 1
  fi
}

# Confirms a dangerous action with a specific word that must be typed exactly
# Usage: confirm_action_danger "action_word"
# Parameters:
#   $1 - Word that user must type to confirm
# Environment:
#   HUG_FORCE - If true, skips confirmation
# Returns:
#   0 if confirmed (or HUG_FORCE is true)
#   Exits with code 1 if user declines
confirm_action_danger() {
  if [[ ${HUG_FORCE:-} == true ]]; then
    return 0
  fi

  local action="$1"
  if gum_available; then
    local gum_reply
    if ! gum_reply=$(gum input --prompt "→ " --placeholder "Type \"${action}\" to confirm" ); then
      info "Cancelled."
      exit 1
    fi
    gum_reply="$(trim_message "${gum_reply:-}")"
    if [[ "$gum_reply" == "$action" ]]; then
      return 0
    fi
    info "Cancelled."
    exit 1
  fi

  # Check if we're in a non-interactive environment (no TTY)
  if [[ ! -t 0 ]] || [[ ! -t 1 ]]; then
    # In test mode, allow input simulation
    if [[ "${HUG_TEST_MODE:-}" == "true" ]]; then
      # Continue to input reading in test mode
      :
    else
      info "Non-interactive environment: cancelled."
      exit 1
    fi
  fi

  local reply
  printf 'Type "%s" to confirm: ' "$action" >&2
  if ! read -r reply; then
    info "Cancelled."
    exit 1
  fi
  if [[ "$reply" != "$action" ]]; then
    info "Cancelled."
    exit 1
  fi
}

# Confirmation dialog for safe, non-destructive operations
#
# This function provides user confirmation for ADDITIVE operations that create new resources
# without modifying or deleting existing data. These operations are inherently safe and can be
# easily undone if needed.
#
# Design Philosophy:
# - Safe operations default to YES to reduce friction for productive workflows
# - Warning operations (prompt_confirm_warn) default to NO for safety
# - Dangerous operations (confirm_action_danger) require explicit typing for maximum safety
#
# When to use this function:
# ✓ Creating branches, worktrees, tags, or other new resources
# ✓ Operations that add without removing or modifying existing data
# ✓ Operations that are easily reversible
#
# When NOT to use this function:
# ✗ Deleting, pruning, or removing resources (use prompt_confirm_warn)
# ✗ Overwriting or modifying existing data (use prompt_confirm_warn)
# ✗ Irreversible or high-impact operations (use confirm_action_danger)
#
# Usage: prompt_confirm_safe "Create worktree for branch 'feature' at '../repo-worktrees/feature'?"
#
# Returns: 0 if user confirms, 1 if cancelled (exits by default in non-interactive mode)
#
# Examples:
#   prompt_confirm_safe "Create new branch 'feature-auth'?"    # Defaults to Yes
#   prompt_confirm_safe "Tag commit 'abc123' as 'v1.0'?"      # Defaults to Yes
#
# Compare with other confirmation functions:
#   prompt_confirm_warn "Delete branch 'old-feature'?"        # Defaults to No (destructive)
#   confirm_action_danger "Type 'reset' to reset repository"  # Requires typing (dangerous)
prompt_confirm_safe() {
  if [[ ${HUG_FORCE:-} == true ]]; then
    return 0
  fi
  local prompt="${1:-Proceed?}"
  if gum_available; then
    local message="${prompt% }"
    # Default to Yes for safe/non-destructive operations
    if gum confirm --default=true "$message"; then
      return 0
    fi
    info "Cancelled."
    exit 1
  fi
  # Check if we're in a non-interactive environment (no TTY)
  if [[ ! -t 0 ]] || [[ ! -t 1 ]]; then
    # In test mode, allow input simulation
    if [[ "${HUG_TEST_MODE:-}" == "true" ]]; then
      # Continue to input reading in test mode
      :
    else
      info "Non-interactive environment: cancelled."
      exit 1
    fi
  fi

  local reply
  printf '%s [Y/n]: ' "$prompt" >&2
  if ! read -r reply; then
    info "Cancelled."
    exit 1
  fi
  # Default to Yes for safe operations
  reply="${reply:-Y}"
  reply="${reply:0:1}"
  reply="${reply,,}"  # Convert to lowercase
  if [[ "$reply" != "y" ]]; then
    info "Cancelled."
    exit 1
  fi
}

# Simple input prompt with default value
# Usage: prompt_input "Prompt text" ["default_value"]
# Returns: The user input (or default if user just hit enter)
prompt_input() {
  local prompt="$1"
  local default="${2:-}"
  local result

  if gum_available; then
    if ! result=$(gum input --header "$prompt" --placeholder "$default"); then
      return 1  # User cancelled (Ctrl+C/ESC)
    fi
  else
    # Visually indicate the default value in standard text mode.
    # Otherwise, the user has to guess that pressing Enter yields a value.
    local display_prompt="$prompt"
    if [[ -n "$default" ]]; then
      display_prompt="$display_prompt [$default]"
    fi

    printf '%s: ' "$display_prompt" >&2
    read -r result
  fi

  # Dependency: hug-strings
  result="$(trim_message "${result:-}")"

  # Logic: If input is empty, fallback to default.
  if [[ -z "$result" && -n "$default" ]]; then
    result="$default"
  fi

  echo "$result"
}
