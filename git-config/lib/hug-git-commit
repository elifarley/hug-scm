# shellcheck shell=bash
# This file is a library to be sourced by shell scripts
#
# HUG-GIT-COMMIT: Git commit range analysis and preview functions
#
# This library provides functions for:
# - Counting commits in ranges
# - Listing commits and changed files
# - Preview summaries and headers
#
# All functions are designed to work with the hug-common library
# and follow consistent patterns for error handling and user feedback.

################################################################################
# Temporal Functions
################################################################################

# Resolves a temporal specification to the earliest commit at or after that time
# Usage: commit=$(resolve_temporal_to_commit "time_spec" ["reference_time"])
# Parameters:
#   $1 - Time specification (relative like "3 days ago", "1 week ago" or absolute like "2024-01-15")
#   $2 - (Optional) Reference commit for relative time, defaults to HEAD
# Output:
#   Commit hash of the first commit at or after the specified time to stdout
# Exits:
#   With error if no commits exist at or after the specified time
# Examples:
#   resolve_temporal_to_commit "3 days ago"        # First commit from 3 days ago
#   resolve_temporal_to_commit "1 week ago" HEAD   # First commit from 1 week ago relative to HEAD
#   resolve_temporal_to_commit "2024-01-15"        # First commit on or after 2024-01-15
resolve_temporal_to_commit() {
    local time_spec="$1"
    local reference="${2:-HEAD}"
    
    # Get the reference time (commit time of reference commit)
    local reference_time
    reference_time=$(git log -1 --format="%ct" "$reference" 2>/dev/null) || {
        error "Unable to determine time for reference '$reference'"
        return 1
    }
    
    # Calculate the target time based on the time specification
    local target_time
    if [[ "$time_spec" =~ ^[0-9]+\ (second|minute|hour|day|week|month|year)s?\ ago$ ]]; then
        # Relative time specification
        # Convert to seconds and subtract from reference time
        local amount unit
        amount=$(echo "$time_spec" | awk '{print $1}')
        unit=$(echo "$time_spec" | awk '{print $2}' | sed 's/s$//')
        
        local seconds_offset
        case "$unit" in
            second) seconds_offset=$((amount)) ;;
            minute) seconds_offset=$((amount * 60)) ;;
            hour)   seconds_offset=$((amount * 3600)) ;;
            day)    seconds_offset=$((amount * 86400)) ;;
            week)   seconds_offset=$((amount * 604800)) ;;
            month)  seconds_offset=$((amount * 2592000)) ;;  # Approximation: 30 days
            year)   seconds_offset=$((amount * 31536000)) ;; # Approximation: 365 days
            *)
                error "Invalid time unit in '$time_spec'"
                return 1
                ;;
        esac
        
        target_time=$((reference_time - seconds_offset))
    else
        # Absolute time specification - use git's date parsing directly
        # Git understands various date formats and is cross-platform
        # We'll use --since with the time spec and let git parse it
        local commit
        commit=$(git log --format="%H" --since="$time_spec" "$reference" --reverse 2>/dev/null | head -n 1)
        
        if [[ -z "$commit" ]]; then
            error "Unable to parse time specification '$time_spec' or no commits found after that time"
            return 1
        fi
        
        echo "$commit"
        return 0
    fi
    
    # Find the first commit at or after the target time
    # We use --since with the target time and --reverse to get the oldest first
    local commit
    commit=$(git log --format="%H" --since="@$target_time" "$reference" --reverse 2>/dev/null | head -n 1)
    
    if [[ -z "$commit" ]]; then
        error "No commits found at or after '$time_spec' (relative to $reference)"
        return 1
    fi
    
    echo "$commit"
}

# Parse temporal flag from command line arguments
# Usage: eval "$(parse_temporal_flag "$@")"
# Recognizes flags:
#   -t, --temporal TIME    Sets temporal_spec="TIME" and consumes the argument
# Output:
#   Shell assignments to be eval'd by caller:
#   - temporal_spec: The time specification string
#   - Remaining args after consuming temporal flags
# Example:
#   eval "$(parse_temporal_flag "$@")"
#   # Now $temporal_spec is set and $@ contains remaining arguments
parse_temporal_flag() {
    local temporal_value=""
    local -a remaining_args=()
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -t|--temporal)
                if [[ $# -lt 2 || "$2" == -* ]]; then
                    echo "echo 'Error: -t/--temporal requires a time specification (e.g., \"3 days ago\", \"1 week ago\", \"2024-01-15\")' >&2"
                    echo "exit 1"
                    return
                fi
                temporal_value="$2"
                shift 2
                ;;
            *)
                remaining_args+=("$1")
                shift
                ;;
        esac
    done
    
    # Output the assignments
    echo "temporal_spec='${temporal_value}'"
    
    # Output remaining args
    if [[ ${#remaining_args[@]} -gt 0 ]]; then
        printf "set -- "
        printf "'%s' " "${remaining_args[@]}"
        printf "\n"
    else
        echo "set --"
    fi
}

# Resolve target commit from upstream, temporal, or explicit target
# This is a DRY helper for h commands that support -u, -t, and N|COMMIT arguments
# Usage: target=$(resolve_target_with_temporal "upstream_flag" "temporal_spec" "target_arg" "default_target")
# Parameters:
#   $1 - upstream flag (true/false)
#   $2 - temporal specification (empty string if not used)
#   $3 - target argument (N or COMMIT, empty string if not provided)
#   $4 - default target if no upstream, temporal, or target_arg (e.g., 'HEAD~1')
# Output:
#   Resolved commit hash to stdout
# Exits:
#   With error if invalid combination or unable to resolve
# Example:
#   target=$(resolve_target_with_temporal "$upstream" "$temporal_spec" "$target_arg" 'HEAD~1')
resolve_target_with_temporal() {
    local upstream="$1"
    local temporal_spec="$2"
    local target_arg="$3"
    local default_target="$4"
    
    # Validate mutually exclusive options
    if [[ "$upstream" == "true" ]] && [[ -n "$target_arg" ]]; then
        error "Cannot specify both --upstream and a target (N|COMMIT)."
        return 1
    fi
    
    if [[ "$upstream" == "true" ]] && [[ -n "$temporal_spec" ]]; then
        error "Cannot specify both --upstream and --temporal."
        return 1
    fi
    
    if [[ -n "$temporal_spec" ]] && [[ -n "$target_arg" ]]; then
        error "Cannot specify both --temporal and a target (N|COMMIT)."
        return 1
    fi
    
    local target
    
    if [[ "$upstream" == "true" ]]; then
        target=$(get_upstream_commit) || return 1
    elif [[ -n "$temporal_spec" ]]; then
        target=$(resolve_temporal_to_commit "$temporal_spec" HEAD) || return 1
        if ! git rev-parse --verify "$target" >/dev/null 2>&1; then
            error "Unable to resolve temporal specification '${temporal_spec}' to a valid commit"
            return 1
        fi
    else
        local target_input="${target_arg:-}"
        local target_ref
        target_ref=$(resolve_head_target "$target_input" "$default_target")
        # Try to resolve to commit hash, but don't error if it fails
        # Let handle_standard_operation check if there are commits in range
        target=$(git rev-parse --verify "$target_ref" 2>/dev/null || echo "$target_ref")
    fi
    
    echo "$target"
}

################################################################################
# Commit Range Analysis Functions
################################################################################

# Counts commits in a range
# Usage: count=$(count_commits_in_range "start" ["end"])
# Parameters:
#   $1 - Start commit (exclusive)
#   $2 - (Optional) End commit (inclusive), defaults to HEAD
# Output:
#   Number of commits in range to stdout
count_commits_in_range() {
    local start="$1"
    local end="${2:-HEAD}"

    git rev-list --count "$start..$end" 2>/dev/null || echo 0
}

# Prints a list of commits in a given range
# Usage: print_commit_list_in_range "start" ["end"]
# Parameters:
#   $1 - Start commit (exclusive)
#   $2 - (Optional) End commit (inclusive), defaults to HEAD
# Output:
#   Formatted commit list to stdout (typically redirected to stderr for prompts)
# Note:
#   This is the standard utility for displaying commit lists to users
#   Uses 'hug ll' command for consistent formatting
print_commit_list_in_range() {
    local start="$1"
    local end="${2:-HEAD}"

    hug ll "$start..$end"
}

# Lists changed files in a commit range
# Usage: files=$(list_changed_files_in_range "start" ["end"])
# Parameters:
#   $1 - Start commit (exclusive)
#   $2 - (Optional) End commit (inclusive), defaults to HEAD
# Output:
#   Sorted unique list of changed file paths to stdout
list_changed_files_in_range() {
    local start="$1"
    local end="${2:-HEAD}"

    git diff --name-only "$start..$end" | sort -u
}

# Counts changed files in a commit range
# Usage: count=$(count_changed_files_in_range "start" ["end"])
# Parameters:
#   $1 - Start commit (exclusive)
#   $2 - (Optional) End commit (inclusive), defaults to HEAD
# Output:
#   Number of unique changed files to stdout
count_changed_files_in_range() {
    local start="$1"
    local end="${2:-HEAD}"

    git diff --name-only "$start..$end" | wc -l
}

################################################################################
# Preview Helper Functions
################################################################################

# Prints preview summary (ðŸ“Š section): commit count and diff stat
# Usage: print_preview_summary num_commits commit_word target_short range
# Parameters:
#   $1 - Number of commits
#   $2 - "commit" or "commits"
#   $3 - Short commit hash of target
#   $4 - Range for diff (e.g., "target..HEAD")
# Output: ðŸ“Š summary and diff stat to stderr
print_preview_summary() {
    local num_commits="$1"
    local commit_word="$2"
    local target_short="$3"
    local range="$4"
    printf 'ðŸ“Š %d %s since %s:\n' "$num_commits" "$commit_word" "$target_short" >&2
    if git diff --quiet "$range"; then
        printf 'No file changes.\n' >&2
    else
        git diff --stat "$range" >&2
    fi
}

# Prints commit list header (ðŸ“¤ section)
# Usage: print_commit_list_header header_type target_name is_new include_commits
# Parameters:
#   $1 - Header type (e.g., "moving", "Outgoing")
#   $2 - Target name (e.g., branch or "upstream")
#   $3 - "true" if new branch, "false" otherwise
#   $4 - "true" to include "commits" in header, "false" otherwise
# Output: ðŸ“¤ header to stderr
print_commit_list_header() {
    local header_type="$1"
    local target_name="$2"
    local is_new="$3"
    local include_commits="$4"
    local suffix=""
    if [[ "$is_new" == "true" ]]; then
        suffix=" (new branch)"
    fi
    if [[ -n "$target_name" ]]; then
        local commits_text=""
        if [[ "$include_commits" == "true" ]]; then
            commits_text=" commits"
        fi
        printf '\nðŸ“¤ %s%s to %s%s:\n' "$header_type" "$commits_text" "$target_name" "$suffix" >&2
    else
        local commits_text=" commits"
        if [[ "$include_commits" != "true" ]]; then
            commits_text=""
        fi
        printf '\nðŸ“¤ %s%s:\n' "$header_type" "$commits_text" >&2
    fi
}
