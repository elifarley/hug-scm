# shellcheck shell=bash
# Library: HUG output and messaging
#
# Renders consistent, colorized log messages for hug commands.
# Depends on: hug-terminal for color constants, hug-gum for optional styling.
# Functions:
#   - error: print an error and exit.
#   - warning / warn: display non-fatal warnings.
#   - info: emit informational messages.
#   - tip: highlight tips.
#   - success: announce successful operations.
#   - print_nothing_to_do: standard "nothing changed" message.
#   - print_dry_run_preview: describe dry-run behavior.
#   - print_action_preview: caution before destructive actions.

################################################################################
# Output and User Interaction Functions
################################################################################

# Prints an error message and exits the script
# Usage: error "message" [exit_code]
# Parameters:
#   $1 - Error message to display
#   $2 - (Optional) Exit code, defaults to 1
error() {
  HUG_QUIET='' gum_log "${RED}‚ùå Error$NC" "$@"
  exit "${2:-1}"
}

# Prints a warning message to stderr
# Usage: warning "message"
# Parameters:
#   $1 - Warning message to display
# Environment:
#   HUG_QUIET - If set, suppresses output
warning() {
  gum_log "${YELLOW}‚ö†Ô∏è Warning$NC" "$@"
}

# Alias for warning() function
# Usage: warn "message"
warn() { warning "$@"; }

# Prints an informational message to stderr
# Usage: info "message"
# Parameters:
#   $1 - Information message to display
# Environment:
#   HUG_QUIET - If set, suppresses output
info() {
  gum_log "${BLUE}‚ÑπÔ∏è Info$NC" "$@"
}

# Prints a tip message to stderr
# Usage: tip "message"
# Parameters:
#   $1 - Tip message to display
# Environment:
#   HUG_QUIET - If set, suppresses output
tip() {
  gum_log "${CYAN}üí° Tip$NC" "$@"
}

# Prints a success message to stderr
# Usage: success "message"
# Parameters:
#   $1 - Success message to display
# Environment:
#   HUG_QUIET - If set, suppresses output
success() {
  gum_log "${GREEN}‚úÖ Success$NC" "$@"
}

# Prints a standardized message when no changes are detected
# Usage: print_nothing_to_do "action" ["scope phrase"]
# Examples:
#   print_nothing_to_do "discard"
#   print_nothing_to_do "zap" "in the repository."
# The scope phrase should include any desired trailing punctuation.
print_nothing_to_do() {
  local action="$1"
  local scope="${2:-for the selected scope.}"
  info "Nothing to ${action}; repository already clean ${scope}"
}

# Prints an informational dry-run preview message (shared across commands)
# Usage: print_dry_run_preview "discarded" "from the specified paths."
print_dry_run_preview() {
  local action_phrase="$1"
  local scope="${2:-for the selected scope.}"
  info "Dry run: the following items would ${action_phrase} ${scope} (no changes applied)."
}

# Prints a warning preview message before executing a destructive action
# Usage: print_action_preview "discard the listed changes" "from the specified paths."
print_action_preview() {
  local action_phrase="$1"
  local scope="${2:-for the selected scope.}"
  warning "‚ö† About to ${action_phrase} ${scope} Review the list below."
}

# Prints staged and unstaged path lists with appropriate labels
# Usage: print_staged_unstaged_paths staged_paths_array unstaged_paths_array target_staged target_unstaged
# Parameters:
#   $1 - Name of array containing staged paths
#   $2 - Name of array containing unstaged paths
#   $3 - Boolean: whether staged changes are targeted
#   $4 - Boolean: whether unstaged changes are targeted
# Notes:
#   - Displays appropriate labels based on what is being targeted
#   - Adds contextual note when both staged and unstaged are targeted
print_staged_unstaged_paths() {
  local -n staged_ref="$1"
  local -n unstaged_ref="$2"
  local target_staged="$3"
  local target_unstaged="$4"
  
  if [[ ${#staged_ref[@]} -gt 0 ]]; then
    if $target_staged && ! $target_unstaged; then
      printf '  Staged paths (unstaged changes in these files would be preserved):\n'
    else
      printf '  Staged paths:\n'
    fi
    print_list '    ' "${staged_ref[@]}"
  fi
  
  if [[ ${#unstaged_ref[@]} -gt 0 ]]; then
    printf '  Unstaged paths:\n'
    print_list '    ' "${unstaged_ref[@]}"
  fi
  
  if $target_staged && $target_unstaged; then
    printf '  (Both staged and unstaged would be fully discarded for affected paths)\n'
  fi
}

# Prints untracked and ignored path lists with appropriate labels
# Usage: print_untracked_ignored_paths untracked_paths_array ignored_paths_array target_untracked target_ignored
# Parameters:
#   $1 - Name of array containing untracked paths
#   $2 - Name of array containing ignored paths
#   $3 - Boolean: whether untracked files are targeted
#   $4 - Boolean: whether ignored files are targeted
# Notes:
#   - Only displays paths that are targeted
print_untracked_ignored_paths() {
  local -n untracked_ref="$1"
  local -n ignored_ref="$2"
  local target_untracked="$3"
  local target_ignored="$4"
  
  if $target_untracked && [[ ${#untracked_ref[@]} -gt 0 ]]; then
    print_list '  Untracked' "${untracked_ref[@]}"
  fi
  
  if $target_ignored && [[ ${#ignored_ref[@]} -gt 0 ]]; then
    print_list '  Ignored' "${ignored_ref[@]}"
  fi
}
