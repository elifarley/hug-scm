# shellcheck shell=bash
# Library: HUG CLI flag parsing utilities
#
# Shared argument parsing and validation helpers for hug commands.
# Depends on: hug-output for consistent error reporting.
# Requires: GNU getopt
# Functions:
#   - parse_common_flags: expand shared flags into shell assignments.
#   - require_args: enforce minimum argument counts.
#
# Implementation:
#   Uses GNU getopt for robust option parsing (required dependency).

################################################################################
# Command Pattern Helpers
################################################################################

# Parses common option flags for command scripts using GNU getopt
# Usage: eval "$(parse_common_flags "$@")"
# Recognizes flags:
#   --dry-run      Sets dry_run=true
#   -f, --force    Sets force=true, exports HUG_FORCE=true
#   -q, --quiet    Exports HUG_QUIET=T
#   --browse-root  Sets browse_root=true, ALWAYS triggers interactive mode (errors if paths provided)
#   -h, --help     Calls usage or show_help function and exits
#   --             If last argument, sets HUG_INTERACTIVE_FILE_SELECTION=true and removes it
# 
# Benefits of GNU getopt:
#   - Combined short options (e.g., -fq for --force --quiet)
#   - Standard --option=value syntax support
#   - Better error messages for invalid options
#   - Proper handling of edge cases
# 
# Note:
#   Consumes recognized flags from arguments
#   Remaining args can be accessed via "$@" after eval
#   Handles empty remaining args without setting $@ to ("")
#   --browse-root ALWAYS triggers interactive mode and errors if paths are provided
parse_common_flags() {
  local interactive_file_selection=false
  local browse_root_flag=false
  
  # Check if last argument is '--' before processing (for interactive file selection)
  if [[ $# -gt 0 && "${!#}" = "--" ]]; then
    interactive_file_selection=true
    # Remove last argument by creating new array without it
    set -- "${@:1:$(($#-1))}"
  fi
  
  # Verify GNU getopt is available (required dependency)
  if ! { getopt --test >/dev/null 2>&1; [ $? -eq 4 ]; }; then
    echo "echo 'Error: GNU getopt is required but not found. Please install util-linux package.' >&2" >&2
    echo "exit 1"
    return 1
  fi
  
  # Use GNU getopt for enhanced parsing
  local parsed
  # Use -q to suppress getopt error messages, we'll handle them ourselves
  parsed=$(getopt -q --options hfq --longoptions help,force,quiet,dry-run,browse-root --name "parse_common_flags" -- "$@")
  local getopt_status=$?
  
  # If getopt failed (status 1 = error in parameters), it means unknown options
  # This allows commands to use additional options beyond common flags
  if [ $getopt_status -ne 0 ]; then
    # For commands with additional options, they need to handle their own parsing
    # Just pass through everything as remaining args
    local remaining_args=()
    
    while [[ $# -gt 0 ]]; do
      case "$1" in
        --dry-run)
          echo "dry_run=true"
          shift
          ;;
        -f|--force)
          echo "force=true"
          echo "export HUG_FORCE=true"
          shift
          ;;
        -q|--quiet)
          echo "export HUG_QUIET=T"
          shift
          ;;
        --browse-root)
          echo "browse_root=true"
          browse_root_flag=true
          shift
          ;;
        -h|--help)
          echo "if declare -f show_help >/dev/null; then show_help; fi; exit 0"
          shift
          ;;
        --)
          shift
          remaining_args+=("$@")
          break
          ;;
        *)
          remaining_args+=("$1")
          shift
          ;;
      esac
    done
    
    # Export interactive file selection flag if detected via '--' at end
    if $interactive_file_selection; then
      echo "export HUG_INTERACTIVE_FILE_SELECTION=true"
    fi
    
    # --browse-root ALWAYS triggers interactive mode
    if $browse_root_flag; then
      echo "export HUG_INTERACTIVE_FILE_SELECTION=true"
      # Error if paths are provided with --browse-root
      if [ ${#remaining_args[@]} -gt 0 ]; then
        echo "error '--browse-root cannot be used with explicit paths. Use --browse-root alone for interactive file selection.'"
        echo "exit 1"
      fi
    fi
    
    # Always output set -- to properly update $@ in the caller
    if [ ${#remaining_args[@]} -gt 0 ]; then
      printf 'set -- '
      printf '%q ' "${remaining_args[@]}"
      printf '\n'
    else
      printf 'set --\n'
    fi
    return 0
  fi
  
  eval set -- "$parsed"
  
  # Process parsed options
  while true; do
    case "$1" in
      -h|--help)
        echo "if declare -f show_help >/dev/null; then show_help; fi; exit 0"
        shift
        ;;
      -f|--force)
        echo "force=true"
        echo "export HUG_FORCE=true"
        shift
        ;;
      -q|--quiet)
        echo "export HUG_QUIET=T"
        shift
        ;;
      --dry-run)
        echo "dry_run=true"
        shift
        ;;
      --browse-root)
        echo "browse_root=true"
        browse_root_flag=true
        shift
        ;;
      --)
        shift
        break
        ;;
      *)
        echo "echo 'Internal error in parse_common_flags: unexpected argument \"$(printf %q "$1")\"' >&2" >&2
        echo "exit 1"
        return 1
        ;;
    esac
  done
  
  # Export interactive file selection flag if detected via '--' at end
  if $interactive_file_selection; then
    echo "export HUG_INTERACTIVE_FILE_SELECTION=true"
  fi
  
  # --browse-root ALWAYS triggers interactive mode
  if $browse_root_flag; then
    echo "export HUG_INTERACTIVE_FILE_SELECTION=true"
    # Error if paths are provided with --browse-root
    if [ $# -gt 0 ]; then
      echo "error '--browse-root cannot be used with explicit paths. Use --browse-root alone for interactive file selection.'"
      echo "exit 1"
    fi
  fi
  
  # Output remaining arguments
  if [ $# -gt 0 ]; then
    printf 'set -- '
    printf '%q ' "$@"
    printf '\n'
  else
    printf 'set --\n'
  fi
}

# Validates minimum number of arguments
# Usage: require_args N ["error message"]
# Parameters:
#   $1 - Minimum number of arguments required
#   $2 - (Optional) Custom error message
# Environment:
#   Uses $# from caller's context
# Note:
#   This is meant to be called with: require_args N "$#" ["message"]
require_args() {
  local required="$1"
  local actual="$2"
  local message="${3:-this command requires at least $required argument(s)}"
  
  if [[ $actual -lt $required ]]; then
    error "$message"
  fi
}

# Checks that --browse-root is not used with explicit paths
# Usage: check_browse_root_no_paths browse_root_flag has_paths
# Parameters:
#   $1 - Boolean value of browse_root flag
#   $2 - Boolean indicating if paths are provided (true if $# > 0 after flag parsing)
# Effects:
#   Exits with error if browse_root is true and paths are provided
check_browse_root_no_paths() {
  local browse_root="$1"
  local has_paths="$2"
  
  if $browse_root && $has_paths; then
    error "--browse-root cannot be used with explicit paths. Either use --browse-root alone to browse files, or specify paths directly."
  fi
}

