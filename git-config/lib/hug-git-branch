# shellcheck shell=bash
# This file is a library to be sourced by shell scripts
#
# HUG-GIT-BRANCH: Git branch information, display, and selection functions
#
# This library provides functions for:
# - Computing branch details and metadata
# - Printing branch lists and menus
# - Interactive branch selection
#
# All functions are designed to work with the hug-common library
# and follow consistent patterns for error handling and user feedback.
################################################################################
# Branch Information Functions
################################################################################

# Computes details for local branches and populates output arrays
# Usage: compute_local_branch_details current_branch max_len hashes branches tracks subjects [include_subjects]
# Parameters (all namerefs to output variables):
#   $1 - Scalar to receive current branch name
#   $2 - Scalar to receive max branch name length
#   $3 - Array to receive commit hashes
#   $4 - Array to receive branch names
#   $5 - Array to receive tracking information
#   $6 - Array to receive commit subjects
#   $7 - (Optional) Boolean to include subjects (default: true); if false, skips subject computation and leaves subjects empty
# Returns:
#   0 if branches found, 1 if no branches exist
# Note:
#   Arrays are cleared before population. Branches are sorted by name. Tracking info mimics 'git branch -vv' format.
compute_local_branch_details() {
    local -n current_branch_ref="$1"
    local -n max_len_ref="$2"
    local -n hashes_ref="$3"
    local -n branches_ref="$4"
    local -n tracks_ref="$5"
    local -n subjects_ref="$6"
    local include_subjects="${7:-false}"

    # Clear outputs
    current_branch_ref=""
    max_len_ref=0
    branches_ref=()
    hashes_ref=()
    subjects_ref=()
    tracks_ref=()

    #
    # --- ROBUST SANITIZATION: CURRENT BRANCH ---
    # Get the current branch and aggressively strip any trailing newline or
    # carriage return characters to ensure string comparisons work correctly.
    local current_branch_raw
    current_branch_raw=$(git branch --show-current 2>/dev/null || echo "")
    current_branch_ref=$(printf '%s' "$current_branch_raw" | tr -d '\n\r')

    # Build format: Include upstream:short separately for reliable name resolution
    local format='%(refname:short)%00%(objectname:short)'
    if [[ "$include_subjects" == "true" ]]; then
        format+='%00%(subject)'
    fi
    format+='%00%(upstream:short)%00'

    # Use mapfile for robust, atomic parsing of null-delimited data.
    local -a git_output=()
    mapfile -t -d '' git_output < <(git for-each-ref \
        --format="$format" \
        --sort=refname refs/heads/)

    # Iterate through the flat array in chunks of 3 or 4.
    local i
    local increment=3
    local chunk_limit=2
    if [[ "$include_subjects" == "true" ]]; then
        increment=4
        chunk_limit=3
    fi
    for ((i = 0; i + chunk_limit < ${#git_output[@]}; i += increment)); do
        #
        # --- ROBUST SANITIZATION: BRANCH AND SUBJECT (if included) ---
        # Read the raw values and then pipe them through 'tr' to delete any
        # hidden \n or \r characters. This is the critical fix.
        #
        local branch_raw="${git_output[i]}"
        local branch
        branch=$(printf '%s' "$branch_raw" | tr -d '\n\r')
        
        # Skip backup branches (internal implementation detail)
        # Backup branches follow the pattern: hug-backups/**
        if [[ "$branch" == hug-backups/* ]]; then
            continue
        fi

        local hash="${git_output[i+1]}"

        local subject=""
        if [[ "$include_subjects" == "true" ]]; then
            local subject_raw="${git_output[i+2]}"
            subject=$(printf '%s' "$subject_raw" | tr -d '\n\r')
        fi

        local upstream_name="${git_output[i + increment - 1]}"
        upstream_name=$(printf '%s' "$upstream_name" | tr -d '\n\r' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')  # Trim whitespace

        # Compute divergence status to mimic 'git branch -vv' (ahead/behind)
        local status=""
        if [[ -n "$upstream_name" ]]; then
            local divergence
            divergence=$(git rev-list --left-right --count "$branch...$upstream_name" 2>/dev/null || echo "")
            if [[ -n "$divergence" ]]; then
                local ahead behind
                IFS='	' read -r ahead behind <<< "$divergence"
                if [[ "$ahead" != "0" && "$behind" != "0" ]]; then
                    status="[ahead $ahead behind $behind]"
                elif [[ "$ahead" != "0" ]]; then
                    status="[ahead $ahead]"
                elif [[ "$behind" != "0" ]]; then
                    status="[behind $behind]"
                fi
            fi
        fi

        # Build track string: [upstream: status] like 'git branch -vv'
        local track=""
        if [[ -n "$upstream_name" ]]; then
            track="$CYAN[$upstream_name"
            if [[ -n "$status" ]]; then
                track+=": $BLUE$(echo $status | tr -d '[]')$CYAN"
            fi
            track+="]"
        elif [[ -n "$status" ]]; then
            # Fallback if name empty but status computable (rare)
            track="$status"
        fi

        # Operate directly on the nameref to update the max length.
        #
        if (( ${#branch} > max_len_ref )); then
            max_len_ref=${#branch}
        fi

        branches_ref+=("$branch")
        hashes_ref+=("$hash")
        if [[ "$include_subjects" == "true" ]]; then
            subjects_ref+=("$GREY${subject:-(no commit message)}$NC")
        fi
        tracks_ref+=("$track")
    done

    # Check if any branches were found
    if [ ${#branches_ref[@]} -eq 0 ]; then
        return 1
    fi

    return 0
}

# Batched version of compute_local_branch_details for optimized performance
# Replaces per-branch git rev-list calls with single batched operation
# Usage: compute_local_branch_details_batched current_branch max_len hashes branches tracks subjects
# Parameters (all namerefs to output variables):
#   $1 - Scalar to receive current branch name
#   $2 - Scalar to receive max branch name length
#   $3 - Array to receive commit hashes
#   $4 - Array to receive branch names
#   $5 - Array to receive tracking information
#   $6 - Array to receive commit subjects
# Returns:
#   0 if branches found, 1 if no branches exist
compute_local_branch_details_batched() {
    local -n current_branch_ref="$1"
    local -n max_len_ref="$2"
    local -n hashes_ref="$3"
    local -n branches_ref="$4"
    local -n tracks_ref="$5"
    local -n subjects_ref="$6"

    # Clear outputs
    current_branch_ref=""
    max_len_ref=0
    branches_ref=()
    hashes_ref=()
    subjects_ref=()
    tracks_ref=()

    # Get all branches with their upstream refs in a single call
    # Format: branch, hash, subject, upstream, upstream:track
    # We use null delimiters (%00) for all fields to handle special chars safely
    local format='%(refname:short)%00%(objectname:short)%00%(subject)%00%(upstream:short)%00%(upstream:track)%00'

    local -a git_output=()
    mapfile -t -d '' git_output < <(git for-each-ref --format="$format" refs/heads/ 2>/dev/null)

    if [[ ${#git_output[@]} -eq 0 ]]; then
        return 1
    fi

    # Get current branch
    # Rename local variable to avoid nameref collision if caller passed 'current_branch'
    local curr_branch
    curr_branch=$(git branch --show-current 2>/dev/null || echo "detached HEAD")
    current_branch_ref="$curr_branch"

    # Extract branch names and upstreams for batch divergence calculation
    local -a branch_names=()
    local -a upstream_names=()
    local -a divergence_commands=()

    # Iterate through flat array in chunks of 5
    local i
    for ((i = 0; i + 4 < ${#git_output[@]}; i += 5)); do
        local branch_raw="${git_output[i]}"
        local branch
        branch=$(printf '%s' "$branch_raw" | tr -d '\n\r')

        # Skip backup branches (internal implementation detail)
        if [[ "$branch" == hug-backups/* ]]; then
            continue
        fi

        local hash="${git_output[i+1]}"
        hash=$(printf '%s' "$hash" | tr -d '\n\r')

        local subject="${git_output[i+2]}"
        subject=$(printf '%s' "$subject" | tr -d '\n\r')

        local upstream="${git_output[i+3]}"
        upstream=$(printf '%s' "$upstream" | tr -d '\n\r')

        local track_info="${git_output[i+4]}" # Not used directly in divergence calc but preserved if we need it later

        branch_names+=("$branch")
        branches_ref+=("$branch")  # Fix: Populate the output array
        upstream_names+=("$upstream")
        hashes_ref+=("$hash")
        subjects_ref+=("$GREY${subject:-(no commit message)}$NC")

        # Update max length
        if (( ${#branch} > max_len_ref )); then
            max_len_ref=${#branch}
        fi

        # Build divergence command arguments if upstream exists
        if [[ -n "$upstream" ]]; then
            divergence_commands+=("$branch...$upstream")
        else
            divergence_commands+=("")
        fi
    done

    # Batch compute divergence for all branches with upstreams
    local -a divergence_results=()
    if [[ ${#divergence_commands[@]} -gt 0 ]]; then
        # Create a single git command for all divergence calculations
        while IFS= read -r line; do
            divergence_results+=("$line")
        done < <({
            # Generate left-right commands for all branches
            for divergence in "${divergence_commands[@]}"; do
                if [[ -n "$divergence" ]]; then
                    echo "$divergence"
                fi
            done | \
            # Run them in parallel with xargs if available, otherwise sequentially
            if command -v xargs >/dev/null 2>&1 && [[ ${#divergence_commands[@]} -gt 5 ]]; then
                xargs -I {} -P 4 git rev-list --left-right --count "{}" 2>/dev/null
            else
                while IFS= read -r divergence; do
                    [[ -n "$divergence" ]] && git rev-list --left-right --count "$divergence" 2>/dev/null || echo "0	0"
                done
            fi
        })
    fi

    # Build tracking strings with divergence results
    local divergence_index=0
    for i in "${!branch_names[@]}"; do
        local branch="${branch_names[i]}"
        local hash="${hashes_ref[i]}"
        local subject="${subjects_ref[i]}"
        local upstream="${upstream_names[i]}"

        local track=""
        if [[ -n "$upstream" ]]; then
            track="$CYAN[$upstream"

            # Use pre-computed divergence result
            local divergence_result="${divergence_results[divergence_index]:-0	0}"
            if [[ -n "$divergence_result" ]]; then
                local ahead behind
                IFS=$'\t' read -r ahead behind <<< "$divergence_result"
                if [[ "$ahead" != "0" && "$behind" != "0" ]]; then
                    track+=": $BLUE$ahead ahead, $behind behind$CYAN"
                elif [[ "$ahead" != "0" ]]; then
                    track+=": $BLUE$ahead ahead$CYAN"
                elif [[ "$behind" != "0" ]]; then
                    track+=": $BLUE$behind behind$CYAN"
                fi
                ((divergence_index++))
            fi
            track+="]"
        fi

        tracks_ref+=("$track")
    done

    return 0
}

# Prints a single formatted branch line (shared helper for list and menu)
# Usage: print_branch_line prefix current_branch max_len i hashes_ref branches_ref tracks_ref subjects_ref
# Parameters:
#   $1 - Prefix string for the line (e.g., "" for list current, "  " for list non-current, "%d) " or "%d)   " for menu)
#   $2 - Current branch name
#   $3 - Maximum branch name length (for alignment)
#   $4 - Index i in the arrays
#   $5-$8 - Namerefs to arrays (hashes branches tracks subjects)
# Output:
#   Formatted branch line to stdout; subject printed only if subjects array is non-empty
# SC2178: Nameref declarations are intentional
# shellcheck disable=SC2178
print_branch_line() {
    local prefix="$1"
    local current_branch="$2"
    local max_len="$3"
    local i="$4"
    local -n hashes_ref="$5"
    local -n branches_ref="$6"
    local -n tracks_ref="$7"
    local -n subjects_ref="$8"

    local branch="${branches_ref[i]}"
    local hash="${hashes_ref[i]}"
    local subject=""
    local track="${tracks_ref[i]}"

    if [ "$branch" = "$current_branch" ]; then
        if [ -n "$track" ]; then
            printf "${prefix}${GREEN}* %7s %-*s %s${NC}" "$hash" "$max_len" "$branch" "$track"
        else
            printf "${prefix}${GREEN}* %7s %-*s${NC}" "$hash" "$max_len" "$branch"
        fi
    else
        if [ -n "$track" ]; then
            printf "${prefix}${YELLOW}%7s${NC} %-*s %s${NC}" "$hash" "$max_len" "$branch" "$track"
        else
            printf "${prefix}${YELLOW}%7s${NC} %-*s" "$hash" "$max_len" "$branch"
        fi
    fi

    if [[ ${#subjects_ref[@]} -gt 0 ]]; then
        subject="${subjects_ref[i]}"
        printf " %s\n" "$subject"
    else
        printf "\n"
    fi
}

# Prints a non-interactive list of branches with details
# Usage: print_branch_list current_branch max_len hashes branches tracks subjects [search_term]
# Parameters:
#   $1 - Current branch name
#   $2 - Maximum branch name length (for alignment)
#   $3-$6 - Namerefs to arrays (hashes branches tracks subjects)
#   $7 - (Optional) Search term to filter by BRANCH NAME only (case-insensitive)
# Output:
#   Formatted branch list to stdout, with current branch highlighted in green;
#   subjects printed only if subjects array is non-empty
# SC2178: These nameref declarations are intentional and correct
# shellcheck disable=SC2178
print_branch_list() {
    local current_branch="$1"
    local max_len="$2"
    local hashes_name="$3"
    local branches_name="$4"
    local tracks_name="$5"
    local subjects_name="$6"
    local search_term="${7:-}"

    local -n hashes_ref="$hashes_name"
    local -n branches_ref="$branches_name"

    # Use unified search function for multi-term search filtering
    for i in "${!branches_ref[@]}"; do
        local branch="${branches_ref[i]}"
        local hash="${hashes_ref[i]}"

        # Create formatted branch line for searching (matches whole output line)
        # We'll build this progressively based on available data
        local branch_line="${branch} ${hash}"

        # Apply filter if search terms exist using unified search function
        if [[ -n "$search_term" ]]; then
            # Use search_branch_line for branch name and hash matching
            if ! search_branch_line "$branch_line" "$search_term" "OR"; then
                continue
            fi
        fi

        local prefix=""
        if [ "$branch" != "$current_branch" ]; then
            prefix="  "
        fi

        print_branch_line "$prefix" "$current_branch" "$max_len" "$i" "$hashes_name" "$branches_name" "$tracks_name" "$subjects_name"
    done
}

# Prints an interactive menu for branch selection
# Usage: print_interactive_branch_menu selected current_branch max_len hashes branches tracks subjects
# Parameters (namerefs):
#   $1 - Output variable to receive selected branch name
#   $2 - Current branch name
#   $3 - Maximum branch name length (for alignment)
#   $4-$7 - Namerefs to arrays (hashes branches tracks subjects)
# Effects:
#   Displays numbered menu and prompts for selection
#   For repositories with 10 or more branches, uses gum filter (if installed) for
#   easier searching and selection. Otherwise, displays a numbered list.
#   Loops until valid selection is made
# Output:
#   Selected branch name via nameref parameter; subjects printed only if subjects array is non-empty
# SC2178: These nameref declarations are intentional and correct
# shellcheck disable=SC2178
print_interactive_branch_menu() {
    local -n selected_ref="$1"
    local current_branch="$2"
    local max_len="$3"
    local -n hashes_ref="$4"
    local -n branches_ref="$5"
    local -n tracks_ref="$6"
    local -n subjects_ref="$7"

    local num_branches="${#branches_ref[@]}"
    if [[ $num_branches -eq 0 ]]; then
        error "No branches available for selection."
        return 1
    fi

    # Use gum filter for 10+ branches if gum is available
    if [[ $num_branches -ge $MIN_ITEMS_FOR_GUM ]] && gum_available; then
        local -a formatted_options=()
        local i
        for i in "${!branches_ref[@]}"; do
            local branch="${branches_ref[i]}"
            local hash="${hashes_ref[i]}"
            local track="${tracks_ref[i]}"
            local subject=""
            if [[ ${#subjects_ref[@]} -gt 0 ]]; then
                subject="${subjects_ref[i]}"
            fi
            
            # Format: "branch (hash) [track] subject"
            # Current branch is marked with *
            local marker=""
            if [ "$branch" = "$current_branch" ]; then
                marker="${GREEN}* "
            fi
            
            local formatted="${marker}${branch} $YELLOW$hash$NC"
            if [ -n "$track" ]; then
                formatted="$formatted $track"
            fi
            if [ -n "$subject" ]; then
                formatted="$formatted $subject"
            fi
            
            formatted_options+=("$formatted")
        done
        
        local index
        index=$(get_gum_selection_index formatted_options "$num_branches branches; Pick one to switch to...")
        
        # SC2034: selected_ref is a nameref that assigns to caller's variable
        # shellcheck disable=SC2034
        selected_ref="${branches_ref[$index]}"
        return 0
    fi

    # Fallback to numbered list for < 10 branches or when gum is not available
    printf "Select a branch to switch to:\n\n"

    local i
    for i in "${!branches_ref[@]}"; do
        local num=$((i + 1))
        local branch="${branches_ref[i]}"
        local prefix="$num) "
        if [ "$branch" != "$current_branch" ]; then
            prefix="${num})   "
        fi
        print_branch_line "$prefix" "$current_branch" "$max_len" "$i" "$4" "$5" "$6" "$7"
    done

    local index
    index=$(get_numbered_selection_index "$num_branches")
    # SC2034: selected_ref is a nameref that assigns to caller's variable
    # shellcheck disable=SC2034
    selected_ref="${branches_ref[$index]}"
    return 0
}

# Interactive Selection Helpers
# These functions provide reusable logic for interactive selection from lists,
# used by commands like 'hug b' and 'hug brestore' to avoid duplication.

# Threshold for using gum filter instead of numbered list
readonly MIN_ITEMS_FOR_GUM=10

# Returns the 0-based index of the selected item from gum filter output
# Usage: index=$(get_gum_selection_index formatted_options_name placeholder)
# Parameters:
#   $1 - Name of array containing formatted options (nameref, strings for display)
#   $2 - Placeholder text for gum prompt
# Output:
#   Index of matched item to stdout
# Exits:
#   With "Cancelled." if no selection, error if no match
get_gum_selection_index() {
    local formatted_options_name="$1"
    local -n formatted_options_ref="$formatted_options_name"
    local placeholder="$2"
    
    local num_items=${#formatted_options_ref[@]}
    if [[ $num_items -eq 0 ]]; then
        error "No items available for selection."
        return 1
    fi
    
    local index
    if ! index=$(gum_filter_by_index "$formatted_options_name" "$placeholder"); then
        info "Cancelled."
        exit 1
    fi
    
    echo "$index"
    return 0
}

# Prompts for numbered choice and returns the 0-based index
# Usage: index=$(get_numbered_selection_index num_items)
# Parameters:
#   $1 - Number of items in the list
# Output:
#   Selected index to stdout
# Exits:
#   With "Cancelled." if read fails or invalid input persists
get_numbered_selection_index() {
    local num_items="$1"

    if [[ $num_items -eq 0 ]]; then
        error "No items available for selection."
        return 1
    fi

    local choice
    printf "Enter choice (1-%d): " "$num_items" >&2
    if ! read -r choice; then
        info "Cancelled."
        exit 1
    fi

    while true; do
        if [[ "$choice" =~ ^[0-9]+$ ]] && [ "$choice" -ge 1 ] && [ "$choice" -le "$num_items" ]; then
            echo "$((choice - 1))"
            return 0
        else
            printf "Invalid choice. Please enter a number between 1 and %d: " "$num_items" >&2
            if ! read -r choice; then
                info "Cancelled."
                exit 1
            fi
        fi
    done
}

################################################################################
# WIP Branch Functions
################################################################################

# Computes details for WIP branches (or any branch matching a pattern) and populates output arrays
# Usage: compute_wip_branch_details branches hashes subjects [ref_pattern]
# Parameters (all namerefs to output variables):
#   $1 - Array to receive branch names
#   $2 - Array to receive commit hashes
#   $3 - Array to receive commit subjects
#   $4 - (Optional) Ref pattern to match (default: 'refs/heads/WIP/')
# Returns:
#   0 if branches found, 1 if no branches exist
# Note:
#   Arrays are cleared before population. Branches are sorted by name.
#   This is a simpler version of compute_local_branch_details that omits:
#   - Tracking information (upstream branches, ahead/behind status)
#   - Max length calculation for alignment
#   - Current branch highlighting
#   Use this for WIP branch selection where tracking info isn't needed.
#   Use compute_local_branch_details for full branch listing with tracking.
compute_wip_branch_details() {
    local -n branches_ref="$1"
    local -n hashes_ref="$2"
    local -n subjects_ref="$3"
    local ref_pattern="${4:-refs/heads/WIP/}"

    # Clear outputs
    branches_ref=()
    hashes_ref=()
    subjects_ref=()

    # Build format: branch name, hash, and subject
    local format='%(refname:short)%00%(objectname:short)%00%(subject)%00'

    # Use mapfile for robust, atomic parsing of null-delimited data
    local -a git_output=()
    mapfile -t -d '' git_output < <(git for-each-ref \
        --format="$format" \
        --sort=refname "$ref_pattern" 2>/dev/null || true)

    # Check if we got any results
    if [ ${#git_output[@]} -eq 0 ]; then
        return 1
    fi

    # Iterate through the flat array in chunks of 3
    local i
    for ((i = 0; i + 2 < ${#git_output[@]}; i += 3)); do
        local branch_raw="${git_output[i]}"
        local branch
        branch=$(printf '%s' "$branch_raw" | tr -d '\n\r')
        
        # Skip if empty
        if [[ -z "$branch" ]]; then
            continue
        fi

        local hash="${git_output[i+1]}"
        local subject_raw="${git_output[i+2]}"
        local subject
        subject=$(printf '%s' "$subject_raw" | tr -d '\n\r')

        branches_ref+=("$branch")
        hashes_ref+=("$hash")
        subjects_ref+=("${subject:-(no commit message)}")
    done

    # Check if any branches were found after filtering
    if [ ${#branches_ref[@]} -eq 0 ]; then
        return 1
    fi

    return 0
}

# Interactive WIP branch selection using gum
# Usage: select_wip_branch <placeholder_text> <prog_name>
# Returns: selected branch name on stdout, exits on cancel or error
# Example: branch=$(select_wip_branch "Select WIP branch to delete..." "hug w wipdel")
select_wip_branch() {
    local placeholder="$1"
    local prog_name="$2"
    
    # Use library function to get WIP branch details
    declare -a branches=() hashes=() subjects=()
    
    if ! compute_wip_branch_details branches hashes subjects 'refs/heads/WIP/'; then
        error "$prog_name: No WIP branches found."
    fi

    if ! gum_available; then
        printf 'Available WIP branches:\n'
        for i in "${!branches[@]}"; do
            printf '  %s\n' "${branches[$i]}"
        done
        error "$prog_name: Interactive mode requires 'gum' to be installed. Provide the branch explicitly or install gum: https://github.com/charmbracelet/gum"
    fi

    # Prepare formatted options with branch details
    local -a formatted_options=()
    
    for i in "${!branches[@]}"; do
        local branch="${branches[$i]}"
        local hash="${hashes[$i]}"
        local subject="${subjects[$i]}"
        
        # Format: branch (hash) subject
        local formatted="${branch} ${YELLOW}${hash}${NC} ${GREY}${subject}${NC}"
        formatted_options+=("$formatted")
    done
    
    # Use gum_filter_by_index for selection with exact matching
    local index
    if ! index=$(gum_filter_by_index formatted_options "$placeholder"); then
        info "Cancelled."
        exit 0
    fi
    
    # Return the selected branch name using the index
    printf '%s\n' "${branches[$index]}"
}

################################################################################
# Remote Branch Functions
################################################################################

# Computes details for remote branches and populates output arrays
# Usage: compute_remote_branch_details max_len hashes branches remote_refs subjects [include_subjects]
# Parameters (all namerefs to output variables):
#   $1 - Scalar to receive max branch name length
#   $2 - Array to receive commit hashes
#   $3 - Array to receive local branch names (remote prefix stripped, e.g., "feature" from "origin/feature")
#   $4 - Array to receive full remote refs (e.g., "origin/feature")
#   $5 - Array to receive commit subjects
#   $6 - (Optional) Boolean to include subjects (default: true); if false, skips subject computation
# Returns:
#   0 if remote branches found, 1 if no remote branches exist
# Note:
#   Arrays are cleared before population. Branches are sorted by name.
#   Excludes HEAD references (like "origin/HEAD -> origin/main").
compute_remote_branch_details() {
    local -n max_len_ref="$1"
    local -n hashes_ref="$2"
    local -n branches_ref="$3"
    local -n remote_refs_ref="$4"
    local -n subjects_ref="$5"
    local include_subjects="${6:-true}"

    # Clear outputs
    max_len_ref=0
    hashes_ref=()
    branches_ref=()
    remote_refs_ref=()
    subjects_ref=()

    # Build format: remote ref name, hash, and optionally subject
    local format='%(refname:short)%00%(objectname:short)'
    if [[ "$include_subjects" == "true" ]]; then
        format+='%00%(subject)'
    fi
    format+='%00'

    # Use mapfile for robust, atomic parsing of null-delimited data
    local -a git_output=()
    mapfile -t -d '' git_output < <(git for-each-ref \
        --format="$format" \
        --sort=refname refs/remotes/ 2>/dev/null || true)

    # Check if we got any results
    if [ ${#git_output[@]} -eq 0 ]; then
        return 1
    fi

    # Iterate through the flat array in chunks of 2 or 3
    local i
    local increment=2
    local chunk_limit=1
    if [[ "$include_subjects" == "true" ]]; then
        increment=3
        chunk_limit=2
    fi
    
    for ((i = 0; i + chunk_limit < ${#git_output[@]}; i += increment)); do
        local remote_ref_raw="${git_output[i]}"
        local remote_ref
        remote_ref=$(printf '%s' "$remote_ref_raw" | tr -d '\n\r')
        
        # Skip if empty or HEAD reference
        if [[ -z "$remote_ref" ]] || [[ "$remote_ref" == */HEAD ]]; then
            continue
        fi

        local hash="${git_output[i+1]}"
        
        local subject=""
        if [[ "$include_subjects" == "true" ]]; then
            local subject_raw="${git_output[i+2]}"
            subject=$(printf '%s' "$subject_raw" | tr -d '\n\r')
        fi

        # Extract local branch name by stripping remote prefix (e.g., "origin/feature" -> "feature")
        local branch="${remote_ref#*/}"
        
        # Skip if we couldn't extract a meaningful branch name
        if [[ -z "$branch" ]] || [[ "$branch" == "$remote_ref" ]]; then
            continue
        fi

        # Update max length
        if (( ${#branch} > max_len_ref )); then
            max_len_ref=${#branch}
        fi

        branches_ref+=("$branch")
        remote_refs_ref+=("$remote_ref")
        hashes_ref+=("$hash")
        if [[ "$include_subjects" == "true" ]]; then
            subjects_ref+=("$GREY${subject:-(no commit message)}$NC")
        fi
    done

    # Check if any branches were found after filtering
    if [ ${#branches_ref[@]} -eq 0 ]; then
        return 1
    fi

    return 0
}

# Finds a remote branch that matches the given branch name
# Usage: find_remote_branch <branch_name>
# Parameters:
#   $1 - Branch name to search for (can be short name or full remote ref)
# Output:
#   Full remote ref name (e.g., "origin/feature") to stdout if found
# Returns:
#   0 if found, 1 if not found
# Note:
#   If multiple remotes have the same branch, prefers "origin" if available,
#   otherwise returns the first match alphabetically.
find_remote_branch() {
    local branch_name="$1"
    
    # If branch_name already looks like a remote ref (contains /), check if it exists
    if [[ "$branch_name" == */* ]]; then
        if git show-ref --verify --quiet "refs/remotes/$branch_name" 2>/dev/null; then
            echo "$branch_name"
            return 0
        fi
    fi
    
    # Search for matching remote branches
    local -a matches=()
    local remote_ref
    
    # Get all remote branches, excluding HEAD
    while IFS= read -r remote_ref; do
        # Extract the branch name part (after the remote/)
        local ref_branch="${remote_ref#*/}"
        
        # Check if it matches our search
        if [[ "$ref_branch" == "$branch_name" ]]; then
            matches+=("$remote_ref")
        fi
    done < <(git for-each-ref --format='%(refname:short)' refs/remotes/ 2>/dev/null | grep -v '/HEAD$' || true)
    
    # No matches found
    test ${#matches[@]} -eq 0 && return 1

    # If only one match, return it
    test ${#matches[@]} -eq 1 && echo "${matches[0]}" && return 0

    # Multiple matches: prefer origin
    local match
    for match in "${matches[@]}"; do
        if [[ "$match" == origin/* ]]; then
            echo "$match"
            return 0
        fi
    done

    # No origin match, return first alphabetically
    remote_ref=$(printf "%s\n" "${matches[@]}" | sort --ignore-case | head -n1)
    echo "$remote_ref"
    return 0
}

################################################################################
# Universal Branch Selection Functions
################################################################################

# Universal branch selection interface supporting both single and multi-selection
# Usage: select_branches result_array_name [options...]
# Options:
#   --multi-select           Enable multi-selection mode (default: single)
#   --exclude-current        Exclude current branch from selection (default: true)
#   --include-current        Include current branch in selection
#   --exclude-backup         Exclude backup branches (default: true)
#   --include-backup         Include backup branches in selection
#   --placeholder TEXT       Custom placeholder text for selection prompt
#   --filter-function NAME   Custom filter function name
# Parameters:
#   $1 - Array name (string) that will receive selected branch names
# Returns:
#   0 if selection made, 1 if no selection or error
select_branches() {
    local result_array_name="$1"
    shift

    # Default values
    local multi_select=false
    local exclude_current=true
    local exclude_backup=true
    local placeholder="Select branch"
    local filter_function=""

    # Parse options using simple loop (consistent with other library functions)
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --multi-select)
                multi_select=true
                shift
                ;;
            --exclude-current)
                exclude_current=true
                shift
                ;;
            --include-current)
                exclude_current=false
                shift
                ;;
            --exclude-backup)
                exclude_backup=true
                shift
                ;;
            --include-backup)
                exclude_backup=false
                shift
                ;;
            --placeholder)
                placeholder="$2"
                shift 2
                ;;
            --filter-function)
                filter_function="$2"
                shift 2
                ;;
            *)
                error "select_branches(): Unknown option '$1'"
                return 1
                ;;
        esac
    done

    # Get branch data using existing library function
    declare -a branches=() hashes=() subjects=() tracks=()
    local current_branch="" max_len=""

    if ! compute_local_branch_details current_branch max_len hashes branches tracks subjects "true"; then
        error "No local branches found"
        return 1
    fi

    # Apply filters using centralized filtering function
    declare -a filtered_branches=() filtered_hashes=() filtered_subjects=() filtered_tracks=()

    filter_branches branches hashes subjects tracks "$current_branch" \
        filtered_branches filtered_hashes filtered_subjects filtered_tracks \
        "$exclude_current" "$exclude_backup" "$filter_function"

    # Check if any branches remain after filtering
    if [[ ${#filtered_branches[@]} -eq 0 ]]; then
        return 1
    fi

    # Clear result array
    eval "$result_array_name=()"

    # Delegate to appropriate selection function
    if [[ "$multi_select" == "true" ]]; then
        multi_select_branches "$result_array_name" "$current_branch" "$max_len" \
            filtered_hashes filtered_branches filtered_tracks filtered_subjects "$placeholder"
    else
        # For single selection, we need a temporary variable name
        local selected_branch=""
        single_select_branch selected_branch "$current_branch" "$max_len" \
            filtered_hashes filtered_branches filtered_tracks filtered_subjects "$placeholder"

        # Move result to the output array if selection was made
        if [[ -n "$selected_branch" ]]; then
            eval "$result_array_name=(\"$selected_branch\")"
            return 0
        else
            return 1
        fi
    fi
}

# Centralized branch filtering function
# Usage: filter_branches input_branches input_hashes input_subjects input_tracks current_branch output_branches output_hashes output_subjects output_tracks exclude_current exclude_backup [filter_function]
# Parameters:
#   $1-4  - Input arrays (branches, hashes, subjects, tracks)
#   $5    - Current branch name
#   $6-9  - Output arrays (namerefs) for filtered results
#   $10   - Boolean: exclude current branch
#   $11   - Boolean: exclude backup branches
#   $12   - Optional: custom filter function name
filter_branches() {
    # Input arrays
    local -n input_branches_ref="$1"
    local -n input_hashes_ref="$2"
    local -n input_subjects_ref="$3"
    local -n input_tracks_ref="$4"

    # Current branch
    local current_branch="$5"

    # Output arrays (namerefs)
    local -n output_branches_ref="$6"
    local -n output_hashes_ref="$7"
    local -n output_subjects_ref="$8"
    local -n output_tracks_ref="$9"

    # Filter options
    local exclude_current="${10}"
    local exclude_backup="${11}"
    local filter_function="${12:-}"

    # Clear output arrays
    output_branches_ref=()
    output_hashes_ref=()
    output_subjects_ref=()
    output_tracks_ref=()

    # Apply filters
    local i
    for ((i = 0; i < ${#input_branches_ref[@]}; i++)); do
        local branch="${input_branches_ref[i]}"

        # Skip current branch if exclusion enabled
        if [[ "$exclude_current" == "true" && "$branch" == "$current_branch" ]]; then
            continue
        fi

        # Skip backup branches if exclusion enabled
        if [[ "$exclude_backup" == "true" && "$branch" == hug-backups/* ]]; then
            continue
        fi

        # Apply custom filter function if provided
        if [[ -n "$filter_function" ]] && command -v "$filter_function" >/dev/null 2>&1; then
            if ! "$filter_function" "$branch" "${input_hashes_ref[i]}" "${input_subjects_ref[i]}"; then
                continue
            fi
        fi

        # Branch passed all filters, add to output
        output_branches_ref+=("$branch")
        output_hashes_ref+=("${input_hashes_ref[i]}")
        output_subjects_ref+=("${input_subjects_ref[i]}")
        output_tracks_ref+=("${input_tracks_ref[i]}")
    done
}

# Single branch selection function
# Usage: single_select_branch result_variable current_branch max_len hashes branches tracks subjects placeholder
# Parameters:
#   $1 - Variable name (string) to receive selected branch name
#   $2 - Current branch name
#   $3 - Maximum branch name length (for formatting)
#   $4-7 - Arrays with branch data (hashes, branches, tracks, subjects)
#   $8 - Placeholder text for selection prompt
# Returns:
#   0 if branch selected, 1 if no selection
single_select_branch() {
    local result_variable="$1"
    local current_branch="$2"
    local max_len="$3"
    local -n hashes_ref="$4"
    local -n branches_ref="$5"
    local -n tracks_ref="$6"
    local -n subjects_ref="$7"
    local placeholder="$8"

    # Use existing print_interactive_branch_menu function for consistency
    print_interactive_branch_menu "$result_variable" "$current_branch" "$max_len" \
        hashes_ref branches_ref tracks_ref subjects_ref "$placeholder"
}

# Multi-branch selection function
# Usage: multi_select_branches result_array_name current_branch max_len hashes branches tracks subjects placeholder
# Parameters:
#   $1 - Array name (string) that will receive selected branch names
#   $2-7 - Same as single_select_branch
# Returns:
#   0 if branches selected, 1 if no selection
multi_select_branches() {
    local result_array_name="$1"
    local current_branch="$2"
    local max_len="$3"
    local -n hashes_ref="$4"
    local -n branches_ref="$5"
    local -n tracks_ref="$6"
    local -n subjects_ref="$7"
    local placeholder="$8"

    # Clear result array
    eval "$result_array_name=()"

    # Build formatted options for multi-selection (similar to hug bdel pattern)
    local -a formatted_options=()
    local branch hash subject track

    for ((i = 0; i < ${#branches_ref[@]}; i++)); do
        branch="${branches_ref[i]}"
        hash="${hashes_ref[i]}"
        subject="${subjects_ref[i]}"
        track="${tracks_ref[i]}"

        # Format branch line with colors and information
        local formatted=""
        if [[ -n "$branch" ]]; then
            formatted="${branch}"
            if [[ -n "$hash" ]]; then
                formatted+=" ${YELLOW}${hash}${NC}"
            fi
            if [[ -n "$subject" ]]; then
                formatted+=" ${GREY}${subject}${NC}"
            fi
            if [[ -n "$track" ]]; then
                formatted+=" ${CYAN}[${track}]${NC}"
            fi
        fi
        formatted_options+=("$formatted")
    done

    # Use gum for multi-selection if available and enough items
    if [[ ${#branches_ref[@]} -ge $MIN_ITEMS_FOR_GUM ]] && gum_available; then
        local gum_height
        gum_height=$(gum_calculate_height "${#branches_ref[@]}")

        mapfile -t selected_indices < <(
            gum_filter_by_index formatted_options \
                "$placeholder (<TAB> to select, Enter to confirm)..." \
                --height="$gum_height" \
                --no-limit
        )
    else
        # Fallback to numbered list for small numbers or when gum unavailable
        echo "$placeholder"
        echo

        # Display numbered list
        for ((i = 0; i < ${#formatted_options[@]}; i++)); do
            printf "  %2d: %s\n" $((i + 1)) "${formatted_options[i]}"
        done
        echo

        # Get user selection (support comma-separated numbers)
        local selection
        read -r -p "Enter numbers to select (comma-separated, or 'a' for all): " selection

        # Parse selection
        case "$selection" in
            a|A|all)
                # Select all branches
                selected_indices=("${!branches_ref[@]}")
                ;;
            '')
                # No selection
                return 1
                ;;
            *)
                # Parse comma-separated numbers
                IFS=',' read -ra selected_indices <<< "$selection"
                # Convert to 0-based indexing and validate
                local -a valid_indices=()
                local idx
                for idx in "${selected_indices[@]}"; do
                    # Remove whitespace and convert to 0-based
                    idx=$((10#$idx - 1))
                    if [[ $idx -ge 0 && $idx -lt ${#branches_ref[@]} ]]; then
                        valid_indices+=("$idx")
                    fi
                done
                selected_indices=("${valid_indices[@]}")
                ;;
        esac
    fi

    # Convert indices back to branch names
    if [[ ${#selected_indices[@]} -gt 0 ]]; then
        local idx
        for idx in "${selected_indices[@]}"; do
            if [[ $idx -ge 0 && $idx -lt ${#branches_ref[@]} ]]; then
                eval "$result_array_name+=(\"${branches_ref[idx]}\")"
            fi
        done
        return 0
    else
        return 1
    fi
}

