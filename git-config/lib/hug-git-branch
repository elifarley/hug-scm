# shellcheck shell=bash
# This file is a library to be sourced by shell scripts
#
# HUG-GIT-BRANCH: Git branch information, display, and selection functions
#
# This library provides functions for:
# - Computing branch details and metadata
# - Printing branch lists and menus
# - Interactive branch selection
#
# All functions are designed to work with the hug-common library
# and follow consistent patterns for error handling and user feedback.
################################################################################
# Branch Information Functions
################################################################################

# Computes details for local branches and populates output arrays using Python module
# Usage: compute_local_branch_details current_branch max_len hashes branches tracks subjects dates [include_subjects] [sort_context]
# Parameters (all namerefs to output variables):
#   $1 - Scalar to receive current branch name
#   $2 - Scalar to receive max branch name length
#   $3 - Array to receive commit hashes
#   $4 - Array to receive branch names
#   $5 - Array to receive tracking information
#   $6 - Array to receive commit subjects
#   $7 - Array to receive commit dates (YYYY-MM-DD format)
#   $8 - (Optional) Boolean to include subjects (default: true); passed to Python module
#   $9 - (Optional) Sort context for Python module: gum-single, gum-multi, static (default: gum-single)
# Returns:
#   0 if branches found, 1 if no branches exist
# Note:
#   This function now exclusively uses the Python module (hug_git_branch.py) for type safety
#   and to eliminate the "unbound variable" bugs that plagued the Bash implementation.
#   Arrays are cleared before population. Branches are sorted by commit date based on context.
#   Tracking info mimics 'git branch -vv' format.
compute_local_branch_details() {
    local -n current_branch_ref="$1"
    local -n max_len_ref="$2"
    local -n hashes_ref="$3"
    local -n branches_ref="$4"
    local -n tracks_ref="$5"
    local -n subjects_ref="$6"
    local -n dates_ref="$7"
    local include_subjects="${8:-true}"
    local sort_context="${9:-static}"

    # Clear outputs
    current_branch_ref=""
    max_len_ref=0
    branches_ref=()
    hashes_ref=()
    subjects_ref=()
    tracks_ref=()
    dates_ref=()

    # Use Python module for all branch detail computation
    # This provides type safety and eliminates entire classes of bugs:
    # - No "unbound variable" errors from positional parameter confusion
    # - No array synchronization issues between parallel arrays
    # - Consistent date-based sorting with context-aware ordering
    local python_args=(local)
    python_args+=(--sort-context="$sort_context")

    if ! eval "$(python3 "$HUG_HOME/git-config/lib/python/hug_git_branch.py" "${python_args[@]}")"; then
        return 1
    fi

    # Python module sets variables: current_branch, max_len, branches, hashes, tracks, subjects, dates
    current_branch_ref="$current_branch"
    max_len_ref="$max_len"
    branches_ref=("${branches[@]}")
    hashes_ref=("${hashes[@]}")
    subjects_ref=("${subjects[@]}")
    tracks_ref=("${tracks[@]}")
    dates_ref=("${dates[@]:-}")  # Populate dates if available from Python
    return 0
}

# Prints a single formatted branch line (shared helper for list and menu)
# Usage: print_branch_line prefix current_branch max_len i hashes_ref dates_ref branches_ref tracks_ref subjects_ref
# Parameters:
#   $1 - Prefix string for the line (e.g., "" for list current, "  " for list non-current, "%d) " or "%d)   " for menu)
#   $2 - Current branch name
#   $3 - Maximum branch name length (for alignment)
#   $4 - Index i in the arrays
#   $5-$9 - Namerefs to arrays (hashes dates branches tracks subjects)
# Output:
#   Formatted branch line to stdout; subject printed only if subjects array is non-empty
# SC2178: Nameref declarations are intentional
# shellcheck disable=SC2178
print_branch_line() {
    local prefix="$1"
    local current_branch="$2"
    local max_len="$3"
    local i="$4"
    local -n hashes_ref="$5"
    local -n dates_ref="$6"
    local -n branches_ref="$7"
    local -n tracks_ref="$8"
    local -n subjects_ref="$9"

    local branch="${branches_ref[i]}"
    local hash="${hashes_ref[i]}"
    local date="${dates_ref[i]:-}"  # Default to empty if dates array is empty
    local subject=""
    local track="${tracks_ref[i]}"

    if [ "$branch" = "$current_branch" ]; then
        if [ -n "$track" ]; then
            printf "${prefix}${GREEN}* %7s ${BLUE}%s${NC} %-*s %s${NC}" "$hash" "$date" "$max_len" "$branch" "$track"
        else
            printf "${prefix}${GREEN}* %7s ${BLUE}%s${NC} %-*s${NC}" "$hash" "$date" "$max_len" "$branch"
        fi
    else
        if [ -n "$track" ]; then
            printf "${prefix}${YELLOW}%7s${NC} ${BLUE}%s${NC} %-*s %s${NC}" "$hash" "$date" "$max_len" "$branch" "$track"
        else
            printf "${prefix}${YELLOW}%7s${NC} ${BLUE}%s${NC} %-*s" "$hash" "$date" "$max_len" "$branch"
        fi
    fi

    if [[ ${#subjects_ref[@]} -gt 0 ]]; then
        subject="${subjects_ref[i]}"
        printf " %s\n" "$subject"
    else
        printf "\n"
    fi
}

# Prints a non-interactive list of branches with details
# Usage: print_branch_list current_branch max_len hashes dates branches tracks subjects [search_term]
# Parameters:
#   $1 - Current branch name
#   $2 - Maximum branch name length (for alignment)
#   $3-$7 - Namerefs to arrays (hashes dates branches tracks subjects)
#   $8 - (Optional) Search term to filter by BRANCH NAME only (case-insensitive)
# Output:
#   Formatted branch list to stdout, with current branch highlighted in green;
#   subjects printed only if subjects array is non-empty
# SC2178: These nameref declarations are intentional and correct
# shellcheck disable=SC2178
print_branch_list() {
    local current_branch="$1"
    local max_len="$2"
    local hashes_name="$3"
    local dates_name="$4"
    local branches_name="$5"
    local tracks_name="$6"
    local subjects_name="$7"
    local search_term="${8:-}"

    local -n hashes_ref="$hashes_name"
    local -n branches_ref="$branches_name"

    # Use unified search function for multi-term search filtering
    for i in "${!branches_ref[@]}"; do
        local branch="${branches_ref[i]}"
        local hash="${hashes_ref[i]}"

        # Create formatted branch line for searching (matches whole output line)
        # We'll build this progressively based on available data
        local branch_line="${branch} ${hash}"

        # Apply filter if search terms exist using unified search function
        if [[ -n "$search_term" ]]; then
            # Use search_branch_line for branch name and hash matching
            if ! search_branch_line "$branch_line" "$search_term" "OR"; then
                continue
            fi
        fi

        local prefix=""
        if [ "$branch" != "$current_branch" ]; then
            prefix="  "
        fi

        print_branch_line "$prefix" "$current_branch" "$max_len" "$i" "$hashes_name" "$dates_name" "$branches_name" "$tracks_name" "$subjects_name"
    done
}

# Prints an interactive menu for branch selection
# Usage: print_interactive_branch_menu selected current_branch max_len hashes dates branches tracks subjects [placeholder]
# Parameters (namerefs):
#   $1 - Output variable to receive selected branch name
#   $2 - Current branch name
#   $3 - Maximum branch name length (for alignment)
#   $4-$8 - Namerefs to arrays (hashes dates branches tracks subjects)
#   $9 - (Optional) Placeholder text for gum filter prompt (default: "Pick one to switch to...")
# Effects:
#   Displays numbered menu and prompts for selection
#   For repositories with 10 or more branches, uses gum filter (if installed) for
#   easier searching and selection. Otherwise, displays a numbered list.
#   Loops until valid selection is made
# Output:
#   Selected branch name via nameref parameter; subjects printed only if subjects array is non-empty
# SC2178: These nameref declarations are intentional and correct
# shellcheck disable=SC2178
print_interactive_branch_menu() {
    local -n selected_ref="$1"
    local current_branch="$2"
    local max_len="$3"
    local -n hashes_ref="$4"
    local -n dates_ref="$5"
    local -n branches_ref="$6"
    local -n tracks_ref="$7"
    local -n subjects_ref="$8"
    local placeholder="${9:-Pick one to switch to...}"

    local num_branches="${#branches_ref[@]}"
    if [[ $num_branches -eq 0 ]]; then
        error "No branches available for selection."
        return 1
    fi

    # Use gum filter for 10+ branches if gum is available
    if [[ $num_branches -ge $MIN_ITEMS_FOR_GUM ]] && gum_available; then
        local -a formatted_options=()
        local i
        for i in "${!branches_ref[@]}"; do
            local branch="${branches_ref[i]}"
            local hash="${hashes_ref[i]}"
            local date="${dates_ref[i]:-}"  # Default to empty if dates array is empty
            local track="${tracks_ref[i]}"
            local subject=""
            if [[ ${#subjects_ref[@]} -gt 0 ]]; then
                subject="${subjects_ref[i]}"
            fi

            # Format: "branch hash date [track] subject"
            # Current branch is marked with *
            local marker=""
            if [ "$branch" = "$current_branch" ]; then
                marker="${GREEN}* "
            fi

            local formatted="${marker}${branch} $YELLOW${hash}$NC $BLUE${date}$NC"
            if [ -n "$track" ]; then
                formatted="$formatted $track"
            fi
            if [ -n "$subject" ]; then
                formatted="$formatted $subject"
            fi

            formatted_options+=("$formatted")
        done

        local index
        index=$(get_gum_selection_index formatted_options "$placeholder")

        # SC2034: selected_ref is a nameref that assigns to caller's variable
        # shellcheck disable=SC2034
        selected_ref="${branches_ref[$index]}"
        return 0
    fi

    # Fallback to numbered list for < 10 branches or when gum is not available
    printf "Select a branch to switch to:\n\n"

    local i
    for i in "${!branches_ref[@]}"; do
        local num=$((i + 1))
        local branch="${branches_ref[i]}"
        local prefix="$num) "
        if [ "$branch" != "$current_branch" ]; then
            prefix="${num})   "
        fi
        print_branch_line "$prefix" "$current_branch" "$max_len" "$i" "$4" "$5" "$6" "$7" "$8"
    done

    local index
    index=$(get_numbered_selection_index "$num_branches")
    # SC2034: selected_ref is a nameref that assigns to caller's variable
    # shellcheck disable=SC2034
    selected_ref="${branches_ref[$index]}"
    return 0
}

# Interactive Selection Helpers
# These functions provide reusable logic for interactive selection from lists,
# used by commands like 'hug b' and 'hug brestore' to avoid duplication.

# Threshold for using gum filter instead of numbered list
readonly MIN_ITEMS_FOR_GUM=10

# Returns the 0-based index of the selected item from gum filter output
# Usage: index=$(get_gum_selection_index formatted_options_name placeholder)
# Parameters:
#   $1 - Name of array containing formatted options (nameref, strings for display)
#   $2 - Placeholder text for gum prompt
# Output:
#   Index of matched item to stdout
# Exits:
#   With "Cancelled." if no selection, error if no match
get_gum_selection_index() {
    local formatted_options_name="$1"
    local -n formatted_options_ref="$formatted_options_name"
    local placeholder="$2"
    
    local num_items=${#formatted_options_ref[@]}
    if [[ $num_items -eq 0 ]]; then
        error "No items available for selection."
        return 1
    fi
    
    local index
    if ! index=$(gum_filter_by_index "$formatted_options_name" "$placeholder"); then
        info "Cancelled."
        exit 1
    fi
    
    echo "$index"
    return 0
}

# Prompts for numbered choice and returns the 0-based index
# Usage: index=$(get_numbered_selection_index num_items)
# Parameters:
#   $1 - Number of items in the list
# Output:
#   Selected index to stdout
# Exits:
#   With "Cancelled." if read fails or invalid input persists
get_numbered_selection_index() {
    local num_items="$1"

    if [[ $num_items -eq 0 ]]; then
        error "No items available for selection."
        return 1
    fi

    # Test-mode override: allow deterministic non-interactive selection in tests
    if [[ -n "${HUG_TEST_NUMBERED_SELECTION:-}" ]]; then
        local ts_choice="${HUG_TEST_NUMBERED_SELECTION}"
        if [[ "$ts_choice" =~ ^[0-9]+$ ]] && [ "$ts_choice" -ge 1 ] && [ "$ts_choice" -le "$num_items" ]; then
            echo "$((ts_choice - 1))"
            return 0
        else
            info "Cancelled."
            exit 1
        fi
    fi

    local choice
    printf "Enter choice (1-%d): " "$num_items" >&2
    if ! read -r choice; then
        info "Cancelled."
        exit 1
    fi

    while true; do
        if [[ "$choice" =~ ^[0-9]+$ ]] && [ "$choice" -ge 1 ] && [ "$choice" -le "$num_items" ]; then
            echo "$((choice - 1))"
            return 0
        else
            printf "Invalid choice. Please enter a number between 1 and %d: " "$num_items" >&2
            if ! read -r choice; then
                info "Cancelled."
                exit 1
            fi
        fi
    done
}

################################################################################
# WIP Branch Functions
################################################################################

# Computes details for WIP branches (or any branch matching a pattern) and populates output arrays
# Usage: compute_wip_branch_details branches hashes subjects [ref_pattern]
# Parameters (all namerefs to output variables):
#   $1 - Array to receive branch names
#   $2 - Array to receive commit hashes
#   $3 - Array to receive commit subjects
#   $4 - (Optional) Ref pattern to match (default: 'refs/heads/WIP/')
# Returns:
#   0 if branches found, 1 if no branches exist
# Note:
#   Arrays are cleared before population. Branches are sorted by name.
#   This is a simpler version of compute_local_branch_details that omits:
#   - Tracking information (upstream branches, ahead/behind status)
#   - Max length calculation for alignment
#   - Current branch highlighting
#   Use this for WIP branch selection where tracking info isn't needed.
#   Use compute_local_branch_details for full branch listing with tracking.
compute_wip_branch_details() {
    local -n branches_ref="$1"
    local -n hashes_ref="$2"
    local -n subjects_ref="$3"
    local ref_pattern="${4:-refs/heads/WIP/}"

    # Clear outputs
    branches_ref=()
    hashes_ref=()
    subjects_ref=()

    # Build format: branch name, hash, and subject
    local format='%(refname:short)%00%(objectname:short)%00%(subject)%00'

    # Use mapfile for robust, atomic parsing of null-delimited data
    local -a git_output=()
    mapfile -t -d '' git_output < <(git for-each-ref \
        --format="$format" \
        --sort=refname "$ref_pattern" 2>/dev/null || true)

    # Check if we got any results
    if [ ${#git_output[@]} -eq 0 ]; then
        return 1
    fi

    # Iterate through the flat array in chunks of 3
    local i
    for ((i = 0; i + 2 < ${#git_output[@]}; i += 3)); do
        local branch_raw="${git_output[i]}"
        local branch
        branch=$(printf '%s' "$branch_raw" | tr -d '\n\r')
        
        # Skip if empty
        if [[ -z "$branch" ]]; then
            continue
        fi

        local hash="${git_output[i+1]}"
        local subject_raw="${git_output[i+2]}"
        local subject
        subject=$(printf '%s' "$subject_raw" | tr -d '\n\r')

        branches_ref+=("$branch")
        hashes_ref+=("$hash")
        subjects_ref+=("${subject:-(no commit message)}")
    done

    # Check if any branches were found after filtering
    if [ ${#branches_ref[@]} -eq 0 ]; then
        return 1
    fi

    return 0
}

# Interactive WIP branch selection using gum
# Usage: select_wip_branch <placeholder_text> <prog_name>
# Returns: selected branch name on stdout, exits on cancel or error
# Example: branch=$(select_wip_branch "Select WIP branch to delete..." "hug w wipdel")
select_wip_branch() {
    local placeholder="$1"
    local prog_name="$2"
    
    # Use library function to get WIP branch details
    declare -a branches=() hashes=() subjects=()
    
    if ! compute_wip_branch_details branches hashes subjects 'refs/heads/WIP/'; then
        error "$prog_name: No WIP branches found."
    fi

    if ! gum_available; then
        printf 'Available WIP branches:\n'
        for i in "${!branches[@]}"; do
            printf '  %s\n' "${branches[$i]}"
        done
        error "$prog_name: Interactive mode requires 'gum' to be installed. Provide the branch explicitly or install gum: https://github.com/charmbracelet/gum"
    fi

    # Prepare formatted options with branch details
    local -a formatted_options=()
    
    for i in "${!branches[@]}"; do
        local branch="${branches[$i]}"
        local hash="${hashes[$i]}"
        local subject="${subjects[$i]}"
        
        # Format: branch (hash) subject
        local formatted="${branch} ${YELLOW}${hash}${NC} ${GREY}${subject}${NC}"
        formatted_options+=("$formatted")
    done
    
    # Use gum_filter_by_index for selection with exact matching
    local index
    if ! index=$(gum_filter_by_index formatted_options "$placeholder"); then
        info "Cancelled."
        exit 0
    fi
    
    # Return the selected branch name using the index
    printf '%s\n' "${branches[$index]}"
}

################################################################################
# Remote Branch Functions
################################################################################

# Computes details for remote branches and populates output arrays
# Usage: compute_remote_branch_details max_len hashes branches remote_refs subjects [include_subjects]
# Parameters (all namerefs to output variables):
#   $1 - Scalar to receive max branch name length
#   $2 - Array to receive commit hashes
#   $3 - Array to receive local branch names (remote prefix stripped, e.g., "feature" from "origin/feature")
#   $4 - Array to receive full remote refs (e.g., "origin/feature")
#   $5 - Array to receive commit subjects
#   $6 - (Optional) Boolean to include subjects (default: true); if false, skips subject computation
# Returns:
#   0 if remote branches found, 1 if no remote branches exist
# Note:
#   Arrays are cleared before population. Branches are sorted by name.
#   Excludes HEAD references (like "origin/HEAD -> origin/main").
compute_remote_branch_details() {
    local -n max_len_ref="$1"
    local -n hashes_ref="$2"
    local -n branches_ref="$3"
    local -n remote_refs_ref="$4"
    local -n subjects_ref="$5"
    local include_subjects="${6:-true}"

    # Clear outputs
    max_len_ref=0
    hashes_ref=()
    branches_ref=()
    remote_refs_ref=()
    subjects_ref=()

    # Build format: remote ref name, hash, and optionally subject
    local format='%(refname:short)%00%(objectname:short)'
    if [[ "$include_subjects" == "true" ]]; then
        format+='%00%(subject)'
    fi
    format+='%00'

    # Use mapfile for robust, atomic parsing of null-delimited data
    local -a git_output=()
    mapfile -t -d '' git_output < <(git for-each-ref \
        --format="$format" \
        --sort=refname refs/remotes/ 2>/dev/null || true)

    # Check if we got any results
    if [ ${#git_output[@]} -eq 0 ]; then
        return 1
    fi

    # Iterate through the flat array in chunks of 2 or 3
    local i
    local increment=2
    local chunk_limit=1
    if [[ "$include_subjects" == "true" ]]; then
        increment=3
        chunk_limit=2
    fi
    
    for ((i = 0; i + chunk_limit < ${#git_output[@]}; i += increment)); do
        local remote_ref_raw="${git_output[i]}"
        local remote_ref
        remote_ref=$(printf '%s' "$remote_ref_raw" | tr -d '\n\r')
        
        # Skip if empty or HEAD reference
        if [[ -z "$remote_ref" ]] || [[ "$remote_ref" == */HEAD ]]; then
            continue
        fi

        local hash="${git_output[i+1]}"
        
        local subject=""
        if [[ "$include_subjects" == "true" ]]; then
            local subject_raw="${git_output[i+2]}"
            subject=$(printf '%s' "$subject_raw" | tr -d '\n\r')
        fi

        # Extract local branch name by stripping remote prefix (e.g., "origin/feature" -> "feature")
        local branch="${remote_ref#*/}"
        
        # Skip if we couldn't extract a meaningful branch name
        if [[ -z "$branch" ]] || [[ "$branch" == "$remote_ref" ]]; then
            continue
        fi

        # Update max length
        if (( ${#branch} > max_len_ref )); then
            max_len_ref=${#branch}
        fi

        branches_ref+=("$branch")
        remote_refs_ref+=("$remote_ref")
        hashes_ref+=("$hash")
        if [[ "$include_subjects" == "true" ]]; then
            subjects_ref+=("$GREY${subject:-(no commit message)}$NC")
        fi
    done

    # Check if any branches were found after filtering
    if [ ${#branches_ref[@]} -eq 0 ]; then
        return 1
    fi

    return 0
}

# Finds a remote branch that matches the given branch name
# Usage: find_remote_branch <branch_name>
# Parameters:
#   $1 - Branch name to search for (can be short name or full remote ref)
# Output:
#   Full remote ref name (e.g., "origin/feature") to stdout if found
# Returns:
#   0 if found, 1 if not found
# Note:
#   If multiple remotes have the same branch, prefers "origin" if available,
#   otherwise returns the first match alphabetically.
find_remote_branch() {
    local branch_name="$1"
    
    # If branch_name already looks like a remote ref (contains /), check if it exists
    if [[ "$branch_name" == */* ]]; then
        if git show-ref --verify --quiet "refs/remotes/$branch_name" 2>/dev/null; then
            echo "$branch_name"
            return 0
        fi
    fi
    
    # Search for matching remote branches
    local -a matches=()
    local remote_ref
    
    # Get all remote branches, excluding HEAD
    while IFS= read -r remote_ref; do
        # Extract the branch name part (after the remote/)
        local ref_branch="${remote_ref#*/}"
        
        # Check if it matches our search
        if [[ "$ref_branch" == "$branch_name" ]]; then
            matches+=("$remote_ref")
        fi
    done < <(git for-each-ref --format='%(refname:short)' refs/remotes/ 2>/dev/null | grep -v '/HEAD$' || true)
    
    # No matches found
    test ${#matches[@]} -eq 0 && return 1

    # If only one match, return it
    test ${#matches[@]} -eq 1 && echo "${matches[0]}" && return 0

    # Multiple matches: prefer origin
    local match
    for match in "${matches[@]}"; do
        if [[ "$match" == origin/* ]]; then
            echo "$match"
            return 0
        fi
    done

    # No origin match, return first alphabetically
    remote_ref=$(printf "%s\n" "${matches[@]}" | sort --ignore-case | head -n1)
    echo "$remote_ref"
    return 0
}

################################################################################
# Universal Branch Selection Functions
################################################################################

# Universal branch selection interface supporting both single and multi-selection
# Usage: select_branches result_array_name [options...]
# Options:
#   --multi-select           Enable multi-selection mode (default: single)
#   --exclude-current        Exclude current branch from selection (default: true)
#   --include-current        Include current branch in selection
#   --exclude-backup         Exclude backup branches (default: true)
#   --include-backup         Include backup branches in selection
#   --placeholder TEXT       Custom placeholder text for selection prompt
#   --filter-function NAME   Custom filter function name
#   --sort-context CONTEXT   Sort context: gum-single, gum-multi, or static (default: gum-single for single-select, gum-multi for multi-select)
# Parameters:
#   $1 - Array name (string) that will receive selected branch names
# Returns:
#   0 if selection made, 1 if no selection or error
select_branches() {
    local result_array_name="$1"
    shift

    # Default values
    local multi_select=false
    local exclude_current=true
    local exclude_backup=true
    local placeholder="Select branch"
    local filter_function=""
    local sort_context=""

    # Parse options using simple loop (consistent with other library functions)
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --multi-select)
                multi_select=true
                shift
                ;;
            --exclude-current)
                exclude_current=true
                shift
                ;;
            --include-current)
                exclude_current=false
                shift
                ;;
            --exclude-backup)
                exclude_backup=true
                shift
                ;;
            --include-backup)
                exclude_backup=false
                shift
                ;;
            --placeholder)
                placeholder="$2"
                shift 2
                ;;
            --filter-function)
                filter_function="$2"
                shift 2
                ;;
            --sort-context)
                sort_context="$2"
                shift 2
                ;;
            *)
                error "select_branches(): Unknown option '$1'"
                return 1
                ;;
        esac
    done

    # Determine sort context if not explicitly set
    # gum-single: ascending (oldest first) for single-select with --reverse
    # gum-multi: descending (newest first) for multi-select without --reverse
    if [[ -z "$sort_context" ]]; then
        if [[ "$multi_select" == "true" ]]; then
            sort_context="gum-multi"
        else
            sort_context="gum-single"
        fi
    fi

    # Get branch data using compute_local_branch_details with sort context
    # Use different variable names to avoid shadowing Python module output
    declare -a sel_branches=() sel_hashes=() sel_subjects=() sel_tracks=() sel_dates=()
    local sel_current_branch="" sel_max_len=""

    if ! compute_local_branch_details sel_current_branch sel_max_len sel_hashes sel_branches sel_tracks sel_subjects sel_dates "true" "$sort_context"; then
        error "No local branches found"
        return 1
    fi

    # Apply filters using centralized filtering function
    # Use Python module when feature flag is enabled (default: true)
    declare -a filtered_branches=() filtered_hashes=() filtered_subjects=() filtered_tracks=() filtered_dates=()

    if [[ "${HUG_USE_PYTHON_FILTER:-true}" == "true" ]]; then
        # Python module: type-safe filtering with dataclasses
        local filter_args=()
        filter_args+=(--branches "${sel_branches[*]}")
        filter_args+=(--hashes "${sel_hashes[*]}")
        filter_args+=(--subjects "${sel_subjects[*]}")
        filter_args+=(--tracks "${sel_tracks[*]}")
        filter_args+=(--dates "${sel_dates[*]}")
        filter_args+=(--current-branch "$sel_current_branch")

        if [[ "$exclude_current" == "true" ]]; then
            filter_args+=(--exclude-current)
        fi

        # Backup exclusion (default: true)
        if [[ "$exclude_backup" != "false" ]]; then
            filter_args+=(--exclude-backup)
        else
            filter_args+=(--include-backup)
        fi

        # Note: Custom filter function not yet supported in Python
        # Fall back to Bash if a custom filter is provided
        if [[ -n "$filter_function" ]]; then
            filter_branches sel_branches sel_hashes sel_subjects sel_tracks sel_dates "$sel_current_branch" \
                filtered_branches filtered_hashes filtered_subjects filtered_tracks filtered_dates \
                "$exclude_current" "$exclude_backup" "$filter_function"
        else
            if ! eval "$(python3 "$HUG_HOME/git-config/lib/python/git/branch_filter.py" \
                filter "${filter_args[@]}")"; then
                return 1
            fi
            # Python module sets variables: filtered_branches, filtered_hashes, etc.
        fi
    else
        # Bash fallback: 14 positional parameters (fragile)
        filter_branches sel_branches sel_hashes sel_subjects sel_tracks sel_dates "$sel_current_branch" \
            filtered_branches filtered_hashes filtered_subjects filtered_tracks filtered_dates \
            "$exclude_current" "$exclude_backup" "$filter_function"
    fi

    # Check if any branches remain after filtering
    if [[ ${#filtered_branches[@]} -eq 0 ]]; then
        return 1
    fi

    # Clear result array
    eval "$result_array_name=()"

    # Delegate to appropriate selection function
    if [[ "$multi_select" == "true" ]]; then
        multi_select_branches "$result_array_name" "$sel_current_branch" "$sel_max_len" \
            filtered_hashes filtered_dates filtered_branches filtered_tracks filtered_subjects "$placeholder"
    else
        # For single selection, we need a temporary variable name
        local selected_branch=""
        single_select_branch selected_branch "$sel_current_branch" "$sel_max_len" \
            filtered_hashes filtered_dates filtered_branches filtered_tracks filtered_subjects "$placeholder"

        # Move result to the output array if selection was made
        if [[ -n "$selected_branch" ]]; then
            eval "$result_array_name=(\"$selected_branch\")"
            return 0
        else
            return 1
        fi
    fi
}

# Centralized branch filtering function
# Usage: filter_branches input_branches input_hashes input_subjects input_tracks input_dates current_branch output_branches output_hashes output_subjects output_tracks output_dates exclude_current exclude_backup [filter_function]
# Parameters:
#   $1-5  - Input arrays (branches, hashes, subjects, tracks, dates)
#   $6    - Current branch name
#   $7-11 - Output arrays (namerefs) for filtered results
#   $12   - Boolean: exclude current branch
#   $13   - Boolean: exclude backup branches
#   $14   - Optional: custom filter function name
filter_branches() {
    # Input arrays
    local -n input_branches_ref="$1"
    local -n input_hashes_ref="$2"
    local -n input_subjects_ref="$3"
    local -n input_tracks_ref="$4"
    local -n input_dates_ref="$5"

    # Current branch
    local current_branch="$6"

    # Output arrays (namerefs)
    local -n output_branches_ref="$7"
    local -n output_hashes_ref="$8"
    local -n output_subjects_ref="$9"
    local -n output_tracks_ref="${10}"
    local -n output_dates_ref="${11}"

    # Filter options
    local exclude_current="${12}"
    local exclude_backup="${13}"
    local filter_function="${14:-}"

    # Clear output arrays
    output_branches_ref=()
    output_hashes_ref=()
    output_subjects_ref=()
    output_tracks_ref=()
    output_dates_ref=()

    # Apply filters
    local i
    for ((i = 0; i < ${#input_branches_ref[@]}; i++)); do
        local branch="${input_branches_ref[i]}"

        # Skip current branch if exclusion enabled
        if [[ "$exclude_current" == "true" && "$branch" == "$current_branch" ]]; then
            continue
        fi

        # Skip backup branches if exclusion enabled
        if [[ "$exclude_backup" == "true" && "$branch" == hug-backups/* ]]; then
            continue
        fi

        # Apply custom filter function if provided
        if [[ -n "$filter_function" ]] && command -v "$filter_function" >/dev/null 2>&1; then
            if ! "$filter_function" "$branch" "${input_hashes_ref[i]}" "${input_subjects_ref[i]}"; then
                continue
            fi
        fi

        # Branch passed all filters, add to output
        output_branches_ref+=("$branch")
        output_hashes_ref+=("${input_hashes_ref[i]}")
        output_subjects_ref+=("${input_subjects_ref[i]}")
        output_tracks_ref+=("${input_tracks_ref[i]}")
        output_dates_ref+=("${input_dates_ref[i]:-}")  # Add date if available
    done
}

# Single branch selection function
# Usage: single_select_branch result_variable current_branch max_len hashes dates branches tracks subjects placeholder
# Parameters:
#   $1 - Variable name (string) to receive selected branch name
#   $2 - Current branch name
#   $3 - Maximum branch name length (for formatting)
#   $4-8 - Arrays with branch data (hashes, dates, branches, tracks, subjects)
#   $9 - Placeholder text for selection prompt
# Returns:
#   0 if branch selected, 1 if no selection
single_select_branch() {
    local result_variable="$1"
    local current_branch="$2"
    local max_len="$3"
    local -n hashes_ref="$4"
    local -n dates_ref="$5"
    local -n branches_ref="$6"
    local -n tracks_ref="$7"
    local -n subjects_ref="$8"
    local placeholder="$9"

    # Use existing print_interactive_branch_menu function for consistency
    # Pass original parameter names, not the nameref variable names, to avoid circular reference
    print_interactive_branch_menu "$result_variable" "$current_branch" "$max_len" \
        "$4" "$5" "$6" "$7" "$8" "$placeholder"
}

# Multi-branch selection function
# Usage: multi_select_branches result_array_name current_branch max_len hashes dates branches tracks subjects placeholder
# Parameters:
#   $1 - Array name (string) that will receive selected branch names
#   $2-8 - Same as single_select_branch
# Returns:
#   0 if branches selected, 1 if no selection
multi_select_branches() {
    local result_array_name="$1"
    local current_branch="$2"
    local max_len="$3"
    local -n hashes_ref="$4"
    local -n dates_ref="$5"
    local -n branches_ref="$6"
    local -n tracks_ref="$7"
    local -n subjects_ref="$8"
    local placeholder="$9"

    # Clear result array
    eval "$result_array_name=()"

    # Build formatted options for multi-selection (similar to hug bdel pattern)
    local -a formatted_options=()
    local -a selected_indices=()
    local branch hash date subject track

    for ((i = 0; i < ${#branches_ref[@]}; i++)); do
        branch="${branches_ref[i]}"
        hash="${hashes_ref[i]}"
        date="${dates_ref[i]:-}"
        subject="${subjects_ref[i]}"
        track="${tracks_ref[i]}"

        # Format branch line with colors and information
        local formatted=""
        if [[ -n "$branch" ]]; then
            formatted="${branch}"
            if [[ -n "$hash" ]]; then
                formatted+=" ${YELLOW}${hash}${NC}"
            fi
            if [[ -n "$date" ]]; then
                formatted+=" ${BLUE}${date}${NC}"
            fi
            if [[ -n "$subject" ]]; then
                formatted+=" ${GREY}${subject}${NC}"
            fi
            if [[ -n "$track" ]]; then
                formatted+=" ${CYAN}[${track}]${NC}"
            fi
        fi
        formatted_options+=("$formatted")
    done

    # Use gum for multi-selection if available and enough items
    if [[ ${#branches_ref[@]} -ge $MIN_ITEMS_FOR_GUM ]] && gum_available; then
        local gum_height
        gum_height=$(gum_calculate_height "${#branches_ref[@]}")

        mapfile -t selected_indices < <(
            gum_filter_by_index formatted_options \
                "$placeholder (<TAB> to select, Enter to confirm)..." \
                --height="$gum_height" \
                --no-limit
        )
    else
        # Fallback to numbered list for small numbers or when gum unavailable
        if [[ "${HUG_USE_PYTHON_SELECT:-true}" == "true" ]]; then
            # Python module: type-safe numbered list selection with dataclasses
            local select_args=()
            select_args+=(--branches "${branches_ref[*]}")
            select_args+=(--hashes "${hashes_ref[*]}")
            select_args+=(--dates "${dates_ref[*]}")
            select_args+=(--subjects "${subjects_ref[*]}")
            select_args+=(--tracks "${tracks_ref[*]}")
            select_args+=(--placeholder "$placeholder")
            select_args+=(--array-name "$result_array_name")
            select_args+=(--no-gum)  # Explicitly disable gum (we're in numbered list mode)

            if ! eval "$(python3 "$HUG_HOME/git-config/lib/python/git/branch_select.py" \
                select "${select_args[@]}")"; then
                return 1
            fi
            # Python module sets variables: $result_array_name and selected_indices
            return 0
        else
            # Bash fallback: numbered list with manual parsing
            echo "$placeholder"
            echo

            # Display numbered list
            for ((i = 0; i < ${#formatted_options[@]}; i++)); do
                printf "  %2d: %s\n" $((i + 1)) "${formatted_options[i]}"
            done
            echo

            # Get user selection (support comma-separated numbers)
            local selection
            if [[ -n "${HUG_TEST_NUMBERED_SELECTION:-}" ]]; then
                selection="${HUG_TEST_NUMBERED_SELECTION}"
            else
                read -r -p "Enter numbers to select (comma-separated, or 'a' for all): " selection
            fi

            # Parse selection
            case "$selection" in
                a|A|all)
                    # Select all branches
                    selected_indices=("${!branches_ref[@]}")
                    ;;
                '')
                    # No selection
                    return 1
                    ;;
                *)
                    # Parse comma-separated numbers
                    IFS=',' read -ra selected_indices <<< "$selection"
                    # Convert to 0-based indexing and validate
                    local -a valid_indices=()
                    local idx
                    for idx in "${selected_indices[@]}"; do
                        # Remove whitespace and convert to 0-based
                        idx=$((10#$idx - 1))
                        if [[ $idx -ge 0 && $idx -lt ${#branches_ref[@]} ]]; then
                            valid_indices+=("$idx")
                        fi
                    done
                    selected_indices=("${valid_indices[@]}")
                    ;;
            esac
        fi
    fi

    # Convert indices back to branch names (only for gum mode or Bash fallback)
    if [[ ${#selected_indices[@]} -gt 0 ]]; then
        local idx
        for idx in "${selected_indices[@]}"; do
            if [[ $idx -ge 0 && $idx -lt ${#branches_ref[@]} ]]; then
                eval "$result_array_name+=(\"${branches_ref[idx]}\")"
            fi
        done
        return 0
    else
        return 1
    fi
}

