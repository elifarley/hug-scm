# shellcheck shell=bash
# This file is a library to be sourced by shell scripts
#
# HUG-GIT-BRANCH: Git branch information, display, and selection functions
#
# This library provides functions for:
# - Computing branch details and metadata
# - Printing branch lists and menus
# - Interactive branch selection
#
# All functions are designed to work with the hug-common library
# and follow consistent patterns for error handling and user feedback.
################################################################################
# Branch Information Functions
################################################################################

# Computes details for local branches and populates output arrays
# Usage: compute_local_branch_details current_branch max_len hashes branches tracks subjects [include_subjects]
# Parameters (all namerefs to output variables):
#   $1 - Scalar to receive current branch name
#   $2 - Scalar to receive max branch name length
#   $3 - Array to receive commit hashes
#   $4 - Array to receive branch names
#   $5 - Array to receive tracking information
#   $6 - Array to receive commit subjects
#   $7 - (Optional) Boolean to include subjects (default: true); if false, skips subject computation and leaves subjects empty
# Returns:
#   0 if branches found, 1 if no branches exist
# Note:
#   Arrays are cleared before population. Branches are sorted by name. Tracking info mimics 'git branch -vv' format.
compute_local_branch_details() {
    local -n current_branch_ref="$1"
    local -n max_len_ref="$2"
    local -n hashes_ref="$3"
    local -n branches_ref="$4"
    local -n tracks_ref="$5"
    local -n subjects_ref="$6"
    local include_subjects="${7:-false}"

    # Clear outputs
    current_branch_ref=""
    max_len_ref=0
    branches_ref=()
    hashes_ref=()
    subjects_ref=()
    tracks_ref=()

    #
    # --- ROBUST SANITIZATION: CURRENT BRANCH ---
    # Get the current branch and aggressively strip any trailing newline or
    # carriage return characters to ensure string comparisons work correctly.
    local current_branch_raw
    current_branch_raw=$(git branch --show-current 2>/dev/null || echo "")
    current_branch_ref=$(printf '%s' "$current_branch_raw" | tr -d '\n\r')

    # Build format: Include upstream:short separately for reliable name resolution
    local format='%(refname:short)%00%(objectname:short)'
    if [[ "$include_subjects" == "true" ]]; then
        format+='%00%(subject)'
    fi
    format+='%00%(upstream:short)%00'

    # Use mapfile for robust, atomic parsing of null-delimited data.
    local -a git_output=()
    mapfile -t -d '' git_output < <(git for-each-ref \
        --format="$format" \
        --sort=refname refs/heads/)

    # Iterate through the flat array in chunks of 3 or 4.
    local i
    local increment=3
    local chunk_limit=2
    if [[ "$include_subjects" == "true" ]]; then
        increment=4
        chunk_limit=3
    fi
    for ((i = 0; i + chunk_limit < ${#git_output[@]}; i += increment)); do
        #
        # --- ROBUST SANITIZATION: BRANCH AND SUBJECT (if included) ---
        # Read the raw values and then pipe them through 'tr' to delete any
        # hidden \n or \r characters. This is the critical fix.
        #
        local branch_raw="${git_output[i]}"
        local branch
        branch=$(printf '%s' "$branch_raw" | tr -d '\n\r')
        
        # Skip backup branches (internal implementation detail)
        # Backup branches follow the pattern: hug-backups/**
        if [[ "$branch" == hug-backups/* ]]; then
            continue
        fi

        local hash="${git_output[i+1]}"

        local subject=""
        if [[ "$include_subjects" == "true" ]]; then
            local subject_raw="${git_output[i+2]}"
            subject=$(printf '%s' "$subject_raw" | tr -d '\n\r')
        fi

        local upstream_name="${git_output[i + increment - 1]}"
        upstream_name=$(printf '%s' "$upstream_name" | tr -d '\n\r' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')  # Trim whitespace

        # Compute divergence status to mimic 'git branch -vv' (ahead/behind)
        local status=""
        if [[ -n "$upstream_name" ]]; then
            local divergence
            divergence=$(git rev-list --left-right --count "$branch...$upstream_name" 2>/dev/null || echo "")
            if [[ -n "$divergence" ]]; then
                local ahead behind
                IFS='	' read -r ahead behind <<< "$divergence"
                if [[ "$ahead" != "0" && "$behind" != "0" ]]; then
                    status="[ahead $ahead behind $behind]"
                elif [[ "$ahead" != "0" ]]; then
                    status="[ahead $ahead]"
                elif [[ "$behind" != "0" ]]; then
                    status="[behind $behind]"
                fi
            fi
        fi

        # Build track string: [upstream: status] like 'git branch -vv'
        local track=""
        if [[ -n "$upstream_name" ]]; then
            track="$CYAN[$upstream_name"
            if [[ -n "$status" ]]; then
                track+=": $BLUE$(echo $status | tr -d '[]')$CYAN"
            fi
            track+="]"
        elif [[ -n "$status" ]]; then
            # Fallback if name empty but status computable (rare)
            track="$status"
        fi

        # Operate directly on the nameref to update the max length.
        #
        if (( ${#branch} > max_len_ref )); then
            max_len_ref=${#branch}
        fi

        branches_ref+=("$branch")
        hashes_ref+=("$hash")
        if [[ "$include_subjects" == "true" ]]; then
            subjects_ref+=("$GREY${subject:-(no commit message)}$NC")
        fi
        tracks_ref+=("$track")
    done

    # Check if any branches were found
    if [ ${#branches_ref[@]} -eq 0 ]; then
        return 1
    fi

    return 0
}

# Prints a single formatted branch line (shared helper for list and menu)
# Usage: print_branch_line prefix current_branch max_len i hashes_ref branches_ref tracks_ref subjects_ref
# Parameters:
#   $1 - Prefix string for the line (e.g., "" for list current, "  " for list non-current, "%d) " or "%d)   " for menu)
#   $2 - Current branch name
#   $3 - Maximum branch name length (for alignment)
#   $4 - Index i in the arrays
#   $5-$8 - Namerefs to arrays (hashes branches tracks subjects)
# Output:
#   Formatted branch line to stdout; subject printed only if subjects array is non-empty
# SC2178: Nameref declarations are intentional
# shellcheck disable=SC2178
print_branch_line() {
    local prefix="$1"
    local current_branch="$2"
    local max_len="$3"
    local i="$4"
    local -n hashes_ref="$5"
    local -n branches_ref="$6"
    local -n tracks_ref="$7"
    local -n subjects_ref="$8"

    local branch="${branches_ref[i]}"
    local hash="${hashes_ref[i]}"
    local subject=""
    local track="${tracks_ref[i]}"

    if [ "$branch" = "$current_branch" ]; then
        if [ -n "$track" ]; then
            printf "${prefix}${GREEN}* %7s %-*s %s${NC}" "$hash" "$max_len" "$branch" "$track"
        else
            printf "${prefix}${GREEN}* %7s %-*s${NC}" "$hash" "$max_len" "$branch"
        fi
    else
        if [ -n "$track" ]; then
            printf "${prefix}${YELLOW}%7s${NC} %-*s %s${NC}" "$hash" "$max_len" "$branch" "$track"
        else
            printf "${prefix}${YELLOW}%7s${NC} %-*s" "$hash" "$max_len" "$branch"
        fi
    fi

    if [[ ${#subjects_ref[@]} -gt 0 ]]; then
        subject="${subjects_ref[i]}"
        printf " %s\n" "$subject"
    else
        printf "\n"
    fi
}

# Prints a non-interactive list of branches with details
# Usage: print_branch_list current_branch max_len hashes branches tracks subjects
# Parameters:
#   $1 - Current branch name
#   $2 - Maximum branch name length (for alignment)
#   $3-$6 - Namerefs to arrays (hashes branches tracks subjects)
# Output:
#   Formatted branch list to stdout, with current branch highlighted in green;
#   subjects printed only if subjects array is non-empty
# SC2178: These nameref declarations are intentional and correct
# shellcheck disable=SC2178
print_branch_list() {
    local current_branch="$1"
    local max_len="$2"
    local -n hashes_ref="$3"
    local -n branches_ref="$4"
    local -n tracks_ref="$5"
    local -n subjects_ref="$6"

    for i in "${!branches_ref[@]}"; do
        local branch="${branches_ref[i]}"
        local prefix=""
        if [ "$branch" != "$current_branch" ]; then
            prefix="  "
        fi
        print_branch_line "$prefix" "$current_branch" "$max_len" "$i" "$3" "$4" "$5" "$6"
    done
}

# Prints an interactive menu for branch selection
# Usage: print_interactive_branch_menu selected current_branch max_len hashes branches tracks subjects
# Parameters (namerefs):
#   $1 - Output variable to receive selected branch name
#   $2 - Current branch name
#   $3 - Maximum branch name length (for alignment)
#   $4-$7 - Namerefs to arrays (hashes branches tracks subjects)
# Effects:
#   Displays numbered menu and prompts for selection
#   For repositories with 10 or more branches, uses gum filter (if installed) for
#   easier searching and selection. Otherwise, displays a numbered list.
#   Loops until valid selection is made
# Output:
#   Selected branch name via nameref parameter; subjects printed only if subjects array is non-empty
# SC2178: These nameref declarations are intentional and correct
# shellcheck disable=SC2178
print_interactive_branch_menu() {
    local -n selected_ref="$1"
    local current_branch="$2"
    local max_len="$3"
    local -n hashes_ref="$4"
    local -n branches_ref="$5"
    local -n tracks_ref="$6"
    local -n subjects_ref="$7"

    local num_branches="${#branches_ref[@]}"
    if [[ $num_branches -eq 0 ]]; then
        error "No branches available for selection."
        return 1
    fi

    # Use gum filter for 10+ branches if gum is available
    if [[ $num_branches -ge 10 ]] && gum_available; then
        local -a formatted_options=()
        local i
        for i in "${!branches_ref[@]}"; do
            local branch="${branches_ref[i]}"
            local hash="${hashes_ref[i]}"
            local track="${tracks_ref[i]}"
            local subject=""
            if [[ ${#subjects_ref[@]} -gt 0 ]]; then
                subject="${subjects_ref[i]}"
            fi
            
            # Format: "branch (hash) [track] subject"
            # Current branch is marked with *
            local marker=""
            if [ "$branch" = "$current_branch" ]; then
                marker="${GREEN}* "
            fi
            
            local formatted="${marker}${branch} $YELLOW$hash$NC"
            if [ -n "$track" ]; then
                formatted="$formatted $track"
            fi
            if [ -n "$subject" ]; then
                formatted="$formatted $subject"
            fi
            
            formatted_options+=("$formatted")
        done
        
        local index
        index=$(get_gum_selection_index formatted_options "$num_branches branches; Pick one to switch to...")
        
        # SC2034: selected_ref is a nameref that assigns to caller's variable
        # shellcheck disable=SC2034
        selected_ref="${branches_ref[$index]}"
        return 0
    fi

    # Fallback to numbered list for < 10 branches or when gum is not available
    printf "Select a branch to switch to:\n\n"

    local i
    for i in "${!branches_ref[@]}"; do
        local num=$((i + 1))
        local branch="${branches_ref[i]}"
        local prefix="$num) "
        if [ "$branch" != "$current_branch" ]; then
            prefix="${num})   "
        fi
        print_branch_line "$prefix" "$current_branch" "$max_len" "$i" "$4" "$5" "$6" "$7"
    done

    local index
    index=$(get_numbered_selection_index "$num_branches")
    # SC2034: selected_ref is a nameref that assigns to caller's variable
    # shellcheck disable=SC2034
    selected_ref="${branches_ref[$index]}"
    return 0
}

# Interactive Selection Helpers
# These functions provide reusable logic for interactive selection from lists,
# used by commands like 'hug b' and 'hug brestore' to avoid duplication.

# Threshold for using gum filter instead of numbered list
readonly MIN_ITEMS_FOR_GUM=10

# Returns the 0-based index of the selected item from gum filter output
# Usage: index=$(get_gum_selection_index formatted_options_name placeholder)
# Parameters:
#   $1 - Name of array containing formatted options (nameref, strings for display)
#   $2 - Placeholder text for gum prompt
# Output:
#   Index of matched item to stdout
# Exits:
#   With "Cancelled." if no selection, error if no match
get_gum_selection_index() {
    local formatted_options_name="$1"
    local -n formatted_options_ref="$formatted_options_name"
    local placeholder="$2"
    
    local num_items=${#formatted_options_ref[@]}
    if [[ $num_items -eq 0 ]]; then
        error "No items available for selection."
        return 1
    fi
    
    local index
    if ! index=$(gum_filter_by_index "$formatted_options_name" "$placeholder"); then
        info "Cancelled."
        exit 1
    fi
    
    echo "$index"
    return 0
}

# Prompts for numbered choice and returns the 0-based index
# Usage: index=$(get_numbered_selection_index num_items)
# Parameters:
#   $1 - Number of items in the list
# Output:
#   Selected index to stdout
# Exits:
#   With "Cancelled." if read fails or invalid input persists
get_numbered_selection_index() {
    local num_items="$1"

    if [[ $num_items -eq 0 ]]; then
        error "No items available for selection."
        return 1
    fi

    local choice
    printf "Enter choice (1-%d): " "$num_items" >&2
    if ! read -r choice; then
        info "Cancelled."
        exit 1
    fi

    while true; do
        if [[ "$choice" =~ ^[0-9]+$ ]] && [ "$choice" -ge 1 ] && [ "$choice" -le "$num_items" ]; then
            echo "$((choice - 1))"
            return 0
        else
            printf "Invalid choice. Please enter a number between 1 and %d: " "$num_items" >&2
            if ! read -r choice; then
                info "Cancelled."
                exit 1
            fi
        fi
    done
}

################################################################################
# WIP Branch Functions
################################################################################

# Computes details for WIP branches (or any branch matching a pattern) and populates output arrays
# Usage: compute_wip_branch_details branches hashes subjects [ref_pattern]
# Parameters (all namerefs to output variables):
#   $1 - Array to receive branch names
#   $2 - Array to receive commit hashes
#   $3 - Array to receive commit subjects
#   $4 - (Optional) Ref pattern to match (default: 'refs/heads/WIP/')
# Returns:
#   0 if branches found, 1 if no branches exist
# Note:
#   Arrays are cleared before population. Branches are sorted by name.
#   This is a simpler version of compute_local_branch_details that omits:
#   - Tracking information (upstream branches, ahead/behind status)
#   - Max length calculation for alignment
#   - Current branch highlighting
#   Use this for WIP branch selection where tracking info isn't needed.
#   Use compute_local_branch_details for full branch listing with tracking.
compute_wip_branch_details() {
    local -n branches_ref="$1"
    local -n hashes_ref="$2"
    local -n subjects_ref="$3"
    local ref_pattern="${4:-refs/heads/WIP/}"

    # Clear outputs
    branches_ref=()
    hashes_ref=()
    subjects_ref=()

    # Build format: branch name, hash, and subject
    local format='%(refname:short)%00%(objectname:short)%00%(subject)%00'

    # Use mapfile for robust, atomic parsing of null-delimited data
    local -a git_output=()
    mapfile -t -d '' git_output < <(git for-each-ref \
        --format="$format" \
        --sort=refname "$ref_pattern" 2>/dev/null || true)

    # Check if we got any results
    if [ ${#git_output[@]} -eq 0 ]; then
        return 1
    fi

    # Iterate through the flat array in chunks of 3
    local i
    for ((i = 0; i + 2 < ${#git_output[@]}; i += 3)); do
        local branch_raw="${git_output[i]}"
        local branch
        branch=$(printf '%s' "$branch_raw" | tr -d '\n\r')
        
        # Skip if empty
        if [[ -z "$branch" ]]; then
            continue
        fi

        local hash="${git_output[i+1]}"
        local subject_raw="${git_output[i+2]}"
        local subject
        subject=$(printf '%s' "$subject_raw" | tr -d '\n\r')

        branches_ref+=("$branch")
        hashes_ref+=("$hash")
        subjects_ref+=("${subject:-(no commit message)}")
    done

    # Check if any branches were found after filtering
    if [ ${#branches_ref[@]} -eq 0 ]; then
        return 1
    fi

    return 0
}

# Interactive WIP branch selection using gum
# Usage: select_wip_branch <placeholder_text> <prog_name>
# Returns: selected branch name on stdout, exits on cancel or error
# Example: branch=$(select_wip_branch "Select WIP branch to delete..." "hug w wipdel")
select_wip_branch() {
    local placeholder="$1"
    local prog_name="$2"
    
    # Use library function to get WIP branch details
    declare -a branches=() hashes=() subjects=()
    
    if ! compute_wip_branch_details branches hashes subjects 'refs/heads/WIP/'; then
        error "$prog_name: No WIP branches found."
    fi

    if ! gum_available; then
        printf 'Available WIP branches:\n'
        for i in "${!branches[@]}"; do
            printf '  %s\n' "${branches[$i]}"
        done
        error "$prog_name: Interactive mode requires 'gum' to be installed. Provide the branch explicitly or install gum: https://github.com/charmbracelet/gum"
    fi

    # Prepare formatted options with branch details
    local -a formatted_options=()
    
    for i in "${!branches[@]}"; do
        local branch="${branches[$i]}"
        local hash="${hashes[$i]}"
        local subject="${subjects[$i]}"
        
        # Format: branch (hash) subject
        local formatted="${branch} ${YELLOW}${hash}${NC} ${GREY}${subject}${NC}"
        formatted_options+=("$formatted")
    done
    
    # Use gum_filter_by_index for selection with exact matching
    local index
    if ! index=$(gum_filter_by_index formatted_options "$placeholder"); then
        info "Cancelled."
        exit 0
    fi
    
    # Return the selected branch name using the index
    printf '%s\n' "${branches[$index]}"
}

################################################################################
# Remote Branch Functions
################################################################################

# Computes details for remote branches and populates output arrays
# Usage: compute_remote_branch_details max_len hashes branches remote_refs subjects [include_subjects]
# Parameters (all namerefs to output variables):
#   $1 - Scalar to receive max branch name length
#   $2 - Array to receive commit hashes
#   $3 - Array to receive local branch names (remote prefix stripped, e.g., "feature" from "origin/feature")
#   $4 - Array to receive full remote refs (e.g., "origin/feature")
#   $5 - Array to receive commit subjects
#   $6 - (Optional) Boolean to include subjects (default: true); if false, skips subject computation
# Returns:
#   0 if remote branches found, 1 if no remote branches exist
# Note:
#   Arrays are cleared before population. Branches are sorted by name.
#   Excludes HEAD references (like "origin/HEAD -> origin/main").
compute_remote_branch_details() {
    local -n max_len_ref="$1"
    local -n hashes_ref="$2"
    local -n branches_ref="$3"
    local -n remote_refs_ref="$4"
    local -n subjects_ref="$5"
    local include_subjects="${6:-true}"

    # Clear outputs
    max_len_ref=0
    hashes_ref=()
    branches_ref=()
    remote_refs_ref=()
    subjects_ref=()

    # Build format: remote ref name, hash, and optionally subject
    local format='%(refname:short)%00%(objectname:short)'
    if [[ "$include_subjects" == "true" ]]; then
        format+='%00%(subject)'
    fi
    format+='%00'

    # Use mapfile for robust, atomic parsing of null-delimited data
    local -a git_output=()
    mapfile -t -d '' git_output < <(git for-each-ref \
        --format="$format" \
        --sort=refname refs/remotes/ 2>/dev/null || true)

    # Check if we got any results
    if [ ${#git_output[@]} -eq 0 ]; then
        return 1
    fi

    # Iterate through the flat array in chunks of 2 or 3
    local i
    local increment=2
    local chunk_limit=1
    if [[ "$include_subjects" == "true" ]]; then
        increment=3
        chunk_limit=2
    fi
    
    for ((i = 0; i + chunk_limit < ${#git_output[@]}; i += increment)); do
        local remote_ref_raw="${git_output[i]}"
        local remote_ref
        remote_ref=$(printf '%s' "$remote_ref_raw" | tr -d '\n\r')
        
        # Skip if empty or HEAD reference
        if [[ -z "$remote_ref" ]] || [[ "$remote_ref" == */HEAD ]]; then
            continue
        fi

        local hash="${git_output[i+1]}"
        
        local subject=""
        if [[ "$include_subjects" == "true" ]]; then
            local subject_raw="${git_output[i+2]}"
            subject=$(printf '%s' "$subject_raw" | tr -d '\n\r')
        fi

        # Extract local branch name by stripping remote prefix (e.g., "origin/feature" -> "feature")
        local branch="${remote_ref#*/}"
        
        # Skip if we couldn't extract a meaningful branch name
        if [[ -z "$branch" ]] || [[ "$branch" == "$remote_ref" ]]; then
            continue
        fi

        # Update max length
        if (( ${#branch} > max_len_ref )); then
            max_len_ref=${#branch}
        fi

        branches_ref+=("$branch")
        remote_refs_ref+=("$remote_ref")
        hashes_ref+=("$hash")
        if [[ "$include_subjects" == "true" ]]; then
            subjects_ref+=("$GREY${subject:-(no commit message)}$NC")
        fi
    done

    # Check if any branches were found after filtering
    if [ ${#branches_ref[@]} -eq 0 ]; then
        return 1
    fi

    return 0
}

# Finds a remote branch that matches the given branch name
# Usage: find_remote_branch <branch_name>
# Parameters:
#   $1 - Branch name to search for (can be short name or full remote ref)
# Output:
#   Full remote ref name (e.g., "origin/feature") to stdout if found
# Returns:
#   0 if found, 1 if not found
# Note:
#   If multiple remotes have the same branch, prefers "origin" if available,
#   otherwise returns the first match alphabetically.
find_remote_branch() {
    local branch_name="$1"
    
    # If branch_name already looks like a remote ref (contains /), check if it exists
    if [[ "$branch_name" == */* ]]; then
        if git show-ref --verify --quiet "refs/remotes/$branch_name" 2>/dev/null; then
            echo "$branch_name"
            return 0
        fi
    fi
    
    # Search for matching remote branches
    local -a matches=()
    local remote_ref
    
    # Get all remote branches, excluding HEAD
    while IFS= read -r remote_ref; do
        # Extract the branch name part (after the remote/)
        local ref_branch="${remote_ref#*/}"
        
        # Check if it matches our search
        if [[ "$ref_branch" == "$branch_name" ]]; then
            matches+=("$remote_ref")
        fi
    done < <(git for-each-ref --format='%(refname:short)' refs/remotes/ 2>/dev/null | grep -v '/HEAD$' || true)
    
    # No matches found
    if [ ${#matches[@]} -eq 0 ]; then
        return 1
    fi
    
    # If only one match, return it
    if [ ${#matches[@]} -eq 1 ]; then
        echo "${matches[0]}"
        return 0
    fi
    
    # Multiple matches: prefer origin
    local match
    for match in "${matches[@]}"; do
        if [[ "$match" == origin/* ]]; then
            echo "$match"
            return 0
        fi
    done
    
    # No origin match, return first alphabetically
    echo "${matches[0]}"
    return 0
}

