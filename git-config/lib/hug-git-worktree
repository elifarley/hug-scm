# shellcheck shell=bash
# This file is a library to be sourced by shell scripts
#
# HUG-GIT-WORKTREE: Git worktree management functions
#
# This library provides functions for:
# - Worktree discovery and information gathering
# - Worktree creation and removal with safety checks
# - Worktree validation and path management
# - Interactive worktree operations
#
# All functions are designed to work with the hug-common library
# and follow consistent patterns for error handling and user feedback.
################################################################################
# Worktree Information Functions
################################################################################

# Get ADDITIONAL worktrees (excluding the main repository)
# Usage: get_worktrees worktree_paths branches commits status_dirty locked_status
# Parameters (all namerefs to output variables):
#   $1 - Array to receive worktree paths
#   $2 - Array to receive branch names
#   $3 - Array to receive commit hashes (short)
#   $4 - Array to receive dirty status (true/false)
#   $5 - Array to receive locked status (true/false)
# Returns:
#   0 if additional worktrees found, 1 if only main worktree exists
#
# IMPORTANT: This function returns ONLY additional worktrees, excluding the main
#            repository. The main worktree always exists, so this function answers
#            the question "do we have additional worktrees beyond the main one?"
#            For commands that need to include the main worktree, use
#            get_all_worktrees_including_main() instead.
#
# Feature Flag:
#   Set HUG_USE_PYTHON_WORKTREE=false to use Bash implementation instead of Python.
#   This allows for easy rollback if issues arise with the Python module.
get_worktrees() {
    local -n paths_ref="$1"
    local -n branches_ref="$2"
    local -n commits_ref="$3"
    local -n status_ref="$4"
    local -n locked_ref="$5"

    # Clear output arrays
    paths_ref=()
    branches_ref=()
    commits_ref=()
    status_ref=()
    locked_ref=()

    # Get main repository path
    local main_repo_path
    main_repo_path=$(git rev-parse --show-toplevel 2>/dev/null)
    if [[ -z "$main_repo_path" ]]; then
        return 1
    fi

    # Use Python module for worktree parsing if feature flag is enabled (default)
    if [[ "${HUG_USE_PYTHON_WORKTREE:-true}" == "true" ]]; then
        # Use Python module for worktree parsing (type-safe, eliminates Bash state machine bugs)
        local -a _wt_paths=() _wt_branches=() _wt_commits=()
        local -a _wt_dirty_status=() _wt_locked_status=()

        if ! eval "$(python3 "$HUG_HOME/git-config/lib/python/git/worktree.py" list \
                  --main-repo-path "$main_repo_path")"; then
            return 1
        fi

        # Check if any additional worktrees exist (Python module excludes main repo)
        if [[ ${#_wt_paths[@]} -eq 0 ]]; then
            return 1
        fi

        # Assign Python outputs to namerefs
        paths_ref=("${_wt_paths[@]}")
        branches_ref=("${_wt_branches[@]}")
        commits_ref=("${_wt_commits[@]}")
        status_ref=("${_wt_dirty_status[@]}")
        locked_ref=("${_wt_locked_status[@]}")

        return 0
    fi

    # Bash fallback implementation
    # Parse git worktree list --porcelain output
    local -a worktree_output
    mapfile -t worktree_output < <(git worktree list --porcelain 2>/dev/null)

    # Check if any additional worktrees exist (exclude main repo)
    local has_additional_worktrees=false
    local line
    for line in "${worktree_output[@]}"; do
        if [[ "$line" =~ ^worktree\ (.+) ]]; then
            local worktree_path="${BASH_REMATCH[1]}"
            if [[ "$worktree_path" != "$main_repo_path" ]]; then
                has_additional_worktrees=true
                break
            fi
        fi
    done

    if ! $has_additional_worktrees; then
        return 1
    fi

    # Parse worktrees (excluding main repo)
    local current_path=""
    local current_branch=""
    local current_commit=""
    local current_locked="false"
    local i=0

    while [[ $i -lt ${#worktree_output[@]} ]]; do
        local line="${worktree_output[$i]}"

        case "$line" in
            "worktree "*)
                # If we have a previous worktree, store it (only if not main repo)
                if [[ -n "$current_path" && "$current_path" != "$main_repo_path" ]]; then
                    paths_ref+=("$current_path")
                    branches_ref+=("$current_branch")
                    commits_ref+=("$current_commit")

                    # Check if worktree is dirty (modified, staged, or untracked files)
                    # NOTE: We check both tracked changes (diff) and untracked files (status)
                    if git -C "$current_path" diff --quiet 2>/dev/null && \
                       git -C "$current_path" diff --cached --quiet 2>/dev/null && \
                       [[ -z $(git -C "$current_path" ls-files --others --exclude-standard 2>/dev/null) ]]; then
                        status_ref+=("false")
                    else
                        status_ref+=("true")
                    fi

                    locked_ref+=("$current_locked")
                fi

                # Start new worktree
                current_path="${line#worktree }"
                current_branch=""
                current_commit=""
                current_locked="false"
                ;;
            "branch "*)
                current_branch="${line#branch refs/heads/}"
                # Get commit hash for this branch
                current_commit=$(git rev-parse --short "$current_branch" 2>/dev/null || echo "unknown")
                ;;
            "commit "*)
                current_commit="${line#commit }"
                current_commit=$(git rev-parse --short "$current_commit" 2>/dev/null || echo "unknown")
                ;;
            "locked")
                current_locked="true"
                ;;
        esac

        i=$((i + 1))
    done

    # Store the last worktree (only if not main repo)
    if [[ -n "$current_path" && "$current_path" != "$main_repo_path" ]]; then
        paths_ref+=("$current_path")
        branches_ref+=("$current_branch")
        commits_ref+=("$current_commit")

        # Check if worktree is dirty (modified, staged, or untracked files)
        # NOTE: We check both tracked changes (diff) and untracked files (status)
        if git -C "$current_path" diff --quiet 2>/dev/null && \
           git -C "$current_path" diff --cached --quiet 2>/dev/null && \
           [[ -z $(git -C "$current_path" ls-files --others --exclude-standard 2>/dev/null) ]]; then
            status_ref+=("false")
        else
            status_ref+=("true")
        fi

        locked_ref+=("$current_locked")
    fi

    return 0
}

# Get ALL worktrees including the main repository
# Usage: get_all_worktrees_including_main worktree_paths branches commits status_dirty locked_status
# Parameters (all namerefs to output variables):
#   $1 - Array to receive worktree paths
#   $2 - Array to receive branch names
#   $3 - Array to receive commit hashes (short)
#   $4 - Array to receive dirty status (true/false)
#   $5 - Array to receive locked status (true/false)
# Returns:
#   0 if any worktrees found (always succeeds if in a git repo), 1 if not in a git repo
#
# TEACHING NOTE: Use this function when you need to display/operate on ALL worktrees
#                including the main repository. This is appropriate for:
#                - Status displays (e.g., "show current worktree" which might be main)
#                - Complete worktree listings
#                - Commands that should work even with only the main worktree
#
#                IMPORTANT: When displaying counts, use get_worktree_count() which
#                excludes the main worktree to match user expectations:
#                - 0 worktrees = only main exists (default state)
#                - 1 worktree = user created 1 additional worktree
#                - This matches the semantic that the main worktree is always present
#                  and users think in terms of "additional" worktrees they create.
#
#                Use get_worktrees() (without "including_main") when you specifically
#                need to know about ADDITIONAL worktrees, such as:
#                - Deletion operations (can't delete main worktree)
#                - Operations that only make sense with multiple worktrees
#
# Feature Flag:
#   Set HUG_USE_PYTHON_WORKTREE=false to use Bash implementation instead of Python.
#   This allows for easy rollback if issues arise with the Python module.
get_all_worktrees_including_main() {
    local -n paths_ref="$1"
    local -n branches_ref="$2"
    local -n commits_ref="$3"
    local -n status_ref="$4"
    local -n locked_ref="$5"

    # Clear output arrays
    paths_ref=()
    branches_ref=()
    commits_ref=()
    status_ref=()
    locked_ref=()

    # Get main repository path
    local main_repo_path
    main_repo_path=$(git rev-parse --show-toplevel 2>/dev/null)
    if [[ -z "$main_repo_path" ]]; then
        return 1
    fi

    # Use Python module for worktree parsing if feature flag is enabled (default)
    if [[ "${HUG_USE_PYTHON_WORKTREE:-true}" == "true" ]]; then
        # Use Python module for worktree parsing (type-safe, eliminates Bash state machine bugs)
        local -a _wt_paths=() _wt_branches=() _wt_commits=()
        local -a _wt_dirty_status=() _wt_locked_status=()

        if ! eval "$(python3 "$HUG_HOME/git-config/lib/python/git/worktree.py" list \
                  --include-main \
                  --main-repo-path "$main_repo_path")"; then
            return 1
        fi

        # Assign Python outputs to namerefs
        paths_ref=("${_wt_paths[@]}")
        branches_ref=("${_wt_branches[@]}")
        commits_ref=("${_wt_commits[@]}")
        status_ref=("${_wt_dirty_status[@]}")
        locked_ref=("${_wt_locked_status[@]}")

        return 0
    fi

    # Bash fallback implementation
    # Parse git worktree list --porcelain output
    local -a worktree_output
    mapfile -t worktree_output < <(git worktree list --porcelain 2>/dev/null)

    if [[ ${#worktree_output[@]} -eq 0 ]]; then
        return 1
    fi

    # Parse ALL worktrees (INCLUDING main repo)
    local current_path=""
    local current_branch=""
    local current_commit=""
    local current_locked="false"
    local i=0

    while [[ $i -lt ${#worktree_output[@]} ]]; do
        local line="${worktree_output[$i]}"

        case "$line" in
            "worktree "*)
                # If we have a previous worktree, store it (including main repo)
                if [[ -n "$current_path" ]]; then
                    paths_ref+=("$current_path")
                    branches_ref+=("$current_branch")
                    commits_ref+=("$current_commit")

                    # Check if worktree is dirty (modified, staged, or untracked files)
                    # NOTE: We check both tracked changes (diff) and untracked files (status)
                    if git -C "$current_path" diff --quiet 2>/dev/null && \
                       git -C "$current_path" diff --cached --quiet 2>/dev/null && \
                       [[ -z $(git -C "$current_path" ls-files --others --exclude-standard 2>/dev/null) ]]; then
                        status_ref+=("false")
                    else
                        status_ref+=("true")
                    fi

                    locked_ref+=("$current_locked")
                fi

                # Start new worktree
                current_path="${line#worktree }"
                current_branch=""
                current_commit=""
                current_locked="false"
                ;;
            "branch "*)
                current_branch="${line#branch refs/heads/}"
                # Get commit hash for this branch
                current_commit=$(git rev-parse --short "$current_branch" 2>/dev/null || echo "unknown")
                ;;
            "commit "*)
                current_commit="${line#commit }"
                current_commit=$(git rev-parse --short "$current_commit" 2>/dev/null || echo "unknown")
                ;;
            "locked")
                current_locked="true"
                ;;
        esac

        i=$((i + 1))
    done

    # Store the last worktree (including main repo)
    if [[ -n "$current_path" ]]; then
        paths_ref+=("$current_path")
        branches_ref+=("$current_branch")
        commits_ref+=("$current_commit")

        # Check if worktree is dirty (modified, staged, or untracked files)
        # NOTE: We check both tracked changes (diff) and untracked files (status)
        if git -C "$current_path" diff --quiet 2>/dev/null && \
           git -C "$current_path" diff --cached --quiet 2>/dev/null && \
           [[ -z $(git -C "$current_path" ls-files --others --exclude-standard 2>/dev/null) ]]; then
            status_ref+=("false")
        else
            status_ref+=("true")
        fi

        locked_ref+=("$current_locked")
    fi

    return 0
}

# Get current worktree path
# Usage: current_path=$(get_current_worktree_path)
# Returns: Absolute path to current worktree, or empty if not in a worktree
get_current_worktree_path() {
    git rev-parse --show-toplevel 2>/dev/null || echo ""
}

# Check if worktree exists at given path
# Usage: if worktree_exists "/path/to/worktree"; then ...
# Returns: 0 if worktree exists, 1 if not
worktree_exists() {
    local path="$1"
    # Use grep -F (fixed string) to match path exactly without regex interpretation
    [[ -n "$path" ]] && git worktree list --porcelain 2>/dev/null | grep -qF "worktree $path"
}

# Count number of ADDITIONAL worktrees (excluding main worktree)
# Usage: count=$(get_worktree_count)
# Returns: Number of additional worktrees (0 = only main exists, 1 = one additional worktree created)
#
# SEMANTIC NOTE: This matches user mental model where:
#   - 0 worktrees = default state (only main worktree)
#   - 1 worktree = user created one additional worktree
#   - Main worktree is always present and not counted
get_worktree_count() {
    local total
    total=$(git worktree list 2>/dev/null | wc -l)
    # Subtract 1 for main worktree (if any worktrees exist)
    if [[ $total -gt 0 ]]; then
        echo $((total - 1))
    else
        echo 0
    fi
}

################################################################################
# Worktree Validation Functions
################################################################################

# Validate worktree path is safe to operate on
# Usage: validate_worktree_path "/path/to/worktree"
# Returns: 0 if valid, 1 if invalid (outputs error messages)
validate_worktree_path() {
    local path="$1"

    if [[ -z "$path" ]]; then
        error "Worktree path cannot be empty"
        return 1
    fi

    # Convert to absolute path
    if [[ ! "$path" = /* ]]; then
        path="$(pwd)/$path"
    fi

    # Check if path exists and is a directory
    if [[ ! -e "$path" ]]; then
        error "Worktree path does not exist: $path"
        return 1
    fi

    if [[ ! -d "$path" ]]; then
        error "Worktree path is not a directory: $path"
        return 1
    fi

    # Check if it's actually a worktree
    if ! worktree_exists "$path"; then
        error "Path is not a Git worktree: $path"
        return 1
    fi

    # Check if we have read permissions
    if [[ ! -r "$path" ]]; then
        error "No read permission for worktree: $path"
        return 1
    fi

    return 0
}

# Validate branch is available for worktree creation (not already checked out)
# Usage: if branch_available_for_worktree "feature-auth"; then ...
# Returns: 0 if available, 1 if already checked out or doesn't exist
branch_available_for_worktree() {
    local branch="$1"

    if [[ -z "$branch" ]]; then
        return 1
    fi

    # Check if branch exists locally
    if ! git rev-parse --verify "refs/heads/$branch" >/dev/null 2>&1; then
        return 1
    fi

    # Check if branch is already checked out in any worktree (excluding main repo)
    # Get main repo path to exclude it from worktree checking
    local main_repo_path
    main_repo_path=$(git rev-parse --show-toplevel 2>/dev/null)

    # Get list of worktrees and check if any additional worktree has this branch
    local -a worktree_info
    mapfile -t worktree_info < <(git worktree list --porcelain 2>/dev/null)

    local current_worktree_path=""
    local i=0
    while [[ $i -lt ${#worktree_info[@]} ]]; do
        local line="${worktree_info[$i]}"

        case "$line" in
            "worktree "*)
                current_worktree_path="${line#worktree }"
                ;;
            "branch refs/heads/"*)
                local branch_name="${line#branch refs/heads/}"
                # Only check additional worktrees (not main repo)
                if [[ "$current_worktree_path" != "$main_repo_path" && "$branch_name" == "$branch" ]]; then
                    return 1
                fi
                ;;
        esac

        i=$((i + 1))
    done

    return 0
}

# Validate worktree creation path is safe
# Usage: validate_worktree_creation_path "/path/to/worktree" [auto_create_parent]
# Returns: 0 if safe, 1 if unsafe (outputs error messages)
validate_worktree_creation_path() {
    local path="$1"
    local auto_create_parent="${2:-true}"  # Auto-create parent directories by default

    if [[ -z "$path" ]]; then
        warning "Worktree path cannot be empty"
        return 1
    fi

    # Convert to absolute path
    if [[ ! "$path" = /* ]]; then
        path="$(pwd)/$path"
    fi

    # Check if target already exists
    if [[ -e "$path" ]]; then
        warning "Target path already exists: $path"
        info "Choose a different path or remove the existing directory"
        return 1
    fi

    # Check parent directory exists and try to create if requested
    local parent_dir
    parent_dir=$(dirname "$path")

    if [[ ! -d "$parent_dir" ]]; then
        if [[ "$auto_create_parent" == "true" ]]; then
            if ! mkdir -p "$parent_dir" 2>/dev/null; then
                error "Cannot create parent directory: $parent_dir"
                return 1
            fi
            info "Auto-created parent directory: $parent_dir"
        else
            warning "Parent directory does not exist: $parent_dir"
            return 1
        fi
    fi

    if [[ ! -w "$parent_dir" ]]; then
        warning "No write permission to parent directory: $parent_dir"
        return 1
    fi

    # Check that target path is not inside main repository
    local main_repo
    main_repo=$(get_current_worktree_path)

    # Normalize paths for comparison using realpath to resolve symlinks and relative paths
    local normalized_main_repo normalized_path
    normalized_main_repo=$(realpath "$main_repo" 2>/dev/null || echo "$main_repo")
    normalized_path=$(realpath "$path" 2>/dev/null || echo "$path")

    # Remove trailing slashes for consistent comparison
    normalized_main_repo="${normalized_main_repo%/}"
    normalized_path="${normalized_path%/}"

    # Check if path would be a subdirectory of main repository using proper path comparison
    # Add trailing slash to ensure we're matching directory boundaries, not just prefixes
    if [[ "$normalized_path" == "$normalized_main_repo"/* ]] || [[ "$normalized_path" == "$normalized_main_repo" ]]; then
        warning "Cannot create worktree inside main repository: $normalized_path"
        info "Choose a location outside the main repository"
        return 1
    fi

    return 0
}

################################################################################
# Worktree Path Generation Functions
################################################################################

# Generate smart default worktree path for a branch
# Usage: path=$(generate_worktree_path "feature-auth")
# Returns: Default worktree path outside main repository
generate_worktree_path() {
    local branch="$1"
    local repo_name
    local safe_branch

    if [[ -z "$branch" ]]; then
        return 1
    fi

    # Get repository name
    repo_name=$(basename "$(get_current_worktree_path)")

    # Make branch name safe for filesystem
    safe_branch=$(printf '%s' "$branch" | sed 's|/|-|g' | sed 's|\.|-|g' | tr '[:upper:]' '[:lower:]')

    # Generate preferred path with auto-creation of parent directories
    local preferred_path="../${repo_name}-worktrees/${safe_branch}"
    local parent_dir=$(dirname "$preferred_path")

    # Auto-create parent directory if it doesn't exist
    if [[ ! -d "$parent_dir" ]]; then
        mkdir -p "$parent_dir" 2>/dev/null || {
            # Fallback to absolute path in temp directory if auto-creation fails
            printf '/tmp/hug-wt-%s-%s/%s' "$repo_name" "$$" "$safe_branch"
            return 0
        }
    fi

    printf '%s' "$preferred_path"
}

# Generate unique worktree path (handles conflicts)
# Usage: path=$(generate_unique_worktree_path "feature-auth")
# Returns: Unique path that doesn't exist
generate_unique_worktree_path() {
    local branch="$1"
    local base_path
    local counter=1

    base_path=$(generate_worktree_path "$branch")

    # If base path doesn't exist, use it
    if [[ ! -e "$base_path" ]]; then
        printf '%s' "$base_path"
        return 0
    fi

    # Otherwise, try numbered versions
    while [[ -e "${base_path}-${counter}" ]]; do
        ((counter++))
    done

    printf '%s-%d' "$base_path" "$counter"
}

################################################################################
# Worktree Operations Functions
################################################################################

# Create worktree with comprehensive safety checks
# Usage: create_worktree "feature-auth" "/path" [force] [dry_run]
# Parameters:
#   $1 - Branch name (must exist and not be checked out)
#   $2 - Target path (parent must exist and be writable)
#   $3 - Force creation without confirmation (default: false)
#   $4 - Dry run only (default: false)
# Returns: 0 on success, 1 on failure
create_worktree() {
    local branch="$1"
    local path="$2"
    local force="${3:-false}"
    local dry_run="${4:-false}"

    # Show what we're about to do (dry run comes first)
    if $dry_run; then
        echo "Would create worktree for branch '$branch' at '$path'"
        return 0
    fi

    # Validate inputs
    if [[ -z "$branch" ]]; then
        warning "Branch name cannot be empty"
        return 1
    fi

    if [[ -z "$path" ]]; then
        warning "Worktree path cannot be empty"
        return 1
    fi

    # Validate branch exists
    if ! git rev-parse --verify "refs/heads/$branch" >/dev/null 2>&1; then
        warning "Branch '$branch' does not exist locally"
        info "Create it first with: hug bc '$branch'"
        info "Or use --new flag to automatically create it"
        return 1
    fi

    # Validate branch is available (force only bypasses confirmation, not validation)
    if ! branch_available_for_worktree "$branch"; then
        warning "Branch '$branch' is already checked out in another worktree"
        info "Use 'hug wt' to see current worktree assignments"
        return 1
    fi

    # Validate creation path
    if ! validate_worktree_creation_path "$path"; then
        return 1
    fi

    # Get confirmation unless forced
    if ! $force; then
        echo "Creating worktree for branch '$branch' at '$path'"
        if ! prompt_confirm_safe "Create worktree for branch '$branch' at '$path'?"; then
            info "Worktree creation cancelled"
            return 0
        fi
    fi

    # Create the worktree
    echo "Creating worktree..."
    local git_args=("$path" "$branch")
    if $force; then
        git_args+=("--force")
    fi

    if git worktree add "${git_args[@]}" 2>/dev/null; then
        # Verify the worktree was actually created (in worktrees, .git is a file, not a directory)
        if [[ -f "$path/.git" ]]; then
            success "Worktree created: $path"
            info "Switch to it with: hug wt $path"
            info "Or: cd $path"
            return 0
        else
            warning "Worktree creation appeared to succeed but directory is invalid"
            return 1
        fi
    else
        warning "Failed to create worktree"
        return 1
    fi
}

# Remove worktree with comprehensive safety checks
# Usage: remove_worktree "/path/to/worktree" [force] [dry_run]
# Parameters:
#   $1 - Worktree path to remove
#   $2 - Force removal without confirmation (default: false)
#   $3 - Dry run only (default: false)
# Returns: 0 on success, 1 on failure
remove_worktree() {
    local path="$1"
    local force="${2:-false}"
    local dry_run="${3:-false}"

    # Show what we're about to do (dry run comes first)
    if $dry_run; then
        echo "Would remove worktree at: $path"
        return 0
    fi

    # Validate worktree path
    if ! validate_worktree_path "$path"; then
        return 1
    fi

    # Prevent removal of current worktree
    local current_worktree
    current_worktree=$(get_current_worktree_path)
    if [[ "$path" == "$current_worktree" ]]; then
        warning "Cannot remove current worktree"
        info "Switch to another worktree first with: hug wt"
        return 1
    fi

    # Check for uncommitted changes
    local unstaged_changes=false
    local staged_changes=false
    local untracked_files=false

    if ! git -C "$path" diff --quiet 2>/dev/null; then
        unstaged_changes=true
    fi

    if ! git -C "$path" diff --cached --quiet 2>/dev/null; then
        staged_changes=true
    fi

    # Check for untracked files (excluding .git directory)
    if git -C "$path" ls-files --others --exclude-standard 2>/dev/null | grep -q .; then
        untracked_files=true
    fi

    if $unstaged_changes || $staged_changes || $untracked_files; then
        if $force; then
            warning "Worktree has uncommitted changes that will be lost"
        else
            warning "Worktree has uncommitted changes"
            info "Commit or stash changes first, or use --force"
            return 1
        fi
    fi

    # Get confirmation unless forced
    if ! $force; then
        echo "Removing worktree at: $path"
        if ! prompt_confirm_danger "remove"; then
            info "Worktree removal cancelled"
            return 0
        fi
    fi

    # Remove the worktree
    echo "Removing worktree..."
    if git worktree remove "$path" 2>/dev/null; then
        success "Worktree removed: $path"
        return 0
    else
        # Fallback to manual removal if git worktree remove fails
        warning "git worktree remove failed, trying manual cleanup"
        if rm -rf "$path" && git worktree prune 2>/dev/null; then
            success "Worktree removed manually: $path"
            return 0
        else
            warning "Failed to remove worktree"
            return 1
        fi
    fi
}

# Switch to worktree with validation
# Usage: switch_to_worktree "/path/to/worktree"
# Parameters:
#   $1 - Worktree path to switch to
# Returns: 0 on success, 1 on failure
switch_to_worktree() {
    local path="$1"

    # Validate worktree path with specific error handling
    if [[ -z "$path" ]]; then
        error "Cannot switch to worktree: path cannot be empty"
        return 1
    fi

    # Convert to absolute path
    if [[ ! "$path" = /* ]]; then
        path="$(pwd)/$path"
    fi

    # Check if path exists and is a directory
    if [[ ! -e "$path" ]]; then
        error "Cannot switch to worktree"
        return 1
    fi

    if [[ ! -d "$path" ]]; then
        error "Cannot switch to worktree"
        return 1
    fi

    # Check if it's actually a worktree
    if ! worktree_exists "$path"; then
        error "Cannot switch to worktree"
        return 1
    fi

    # Check if we have read permissions
    if [[ ! -r "$path" ]]; then
        error "Cannot switch to worktree"
        return 1
    fi

    # Note: This script cannot change the parent shell's working directory
    # The shell function 'wt' in the activation script will handle the actual cd
    # Output the path for shell integration
    printf "WORKTREE_PATH:%s\n" "$path"

    local display_path="${path/#$HOME/\~}"
    local current_branch
    current_branch=$(git -C "$path" branch --show-current 2>/dev/null || echo "detached")

    success "Switched to worktree: $display_path"
    info "Current branch: $current_branch"
    return 0
}

# Prune orphaned worktrees (those pointing to non-existent directories)
# Usage: prune_worktrees [force] [dry_run]
# Parameters:
#   $1 - Force pruning without confirmation (default: false)
#   $2 - Dry run only (default: false)
# Returns: 0 on success, 1 on failure
prune_worktrees() {
    local force="${1:-false}"
    local dry_run="${2:-false}"

    # Find orphaned worktrees
    local -a orphaned_worktrees=()
    local -a worktree_output
    mapfile -t worktree_output < <(git worktree list --porcelain)

    local current_path=""
    local i=0

    while [[ $i -lt ${#worktree_output[@]} ]]; do
        local line="${worktree_output[$i]}"

        case "$line" in
            "worktree "*)
                current_path="${line#worktree }"
                if [[ ! -d "$current_path" ]]; then
                    orphaned_worktrees+=("$current_path")
                fi
                ;;
        esac

        i=$((i + 1))
    done

    if [[ ${#orphaned_worktrees[@]} -eq 0 ]]; then
        info "No orphaned worktrees found"
        return 0
    fi

    # Show what we found
    echo "Found ${#orphaned_worktrees[@]} orphaned worktree(s):"
    printf '  %s\n' "${orphaned_worktrees[@]}"

    if $dry_run; then
        echo "Would prune ${#orphaned_worktrees[@]} orphaned worktree(s)"
        return 0
    fi

    # Get confirmation unless forced
    if ! $force; then
        echo "Pruning will remove references to these non-existent worktrees"
        if ! prompt_confirm_danger "prune"; then
            info "Worktree pruning cancelled"
            return 0
        fi
    fi

    # Prune the worktrees
    echo "Pruning orphaned worktrees..."
    if git worktree prune 2>/dev/null; then
        success "Pruned ${#orphaned_worktrees[@]} orphaned worktree(s)"
        return 0
    else
        error "Failed to prune worktrees"
        return 1
    fi
}

################################################################################
# Worktree Status and Summary Functions
################################################################################

# Get worktree status summary for display
# Usage: show_worktree_summary
# Returns: Human-readable summary of all worktrees
show_worktree_summary() {
    local -a worktree_paths=()
    local -a branches=()
    local -a commits=()
    local -a status_dirty=()
    local -a locked_status=()

    if ! get_worktrees worktree_paths branches commits status_dirty locked_status; then
        info "No worktrees found"
        return 0
    fi

    local current_worktree
    current_worktree=$(get_current_worktree_path)
    local count=${#worktree_paths[@]}

    echo
    printf "${BLUE}Worktrees (%d):${NC}\n" "$count"
    echo

    for i in "${!worktree_paths[@]}"; do
        local path="${worktree_paths[$i]}"
        local branch="${branches[$i]}"
        local commit="${commits[$i]}"
        local dirty="${status_dirty[$i]}"
        local locked="${locked_status[$i]}"

        # Status indicators
        local indicators=""
        [[ "$path" == "$current_worktree" ]] && indicators="${indicators}${GREEN}[CURRENT]${NC} "
        [[ "$dirty" == "true" ]] && indicators="${indicators}${YELLOW}[DIRTY]${NC} "
        [[ "$locked" == "true" ]] && indicators="${indicators}${RED}[LOCKED]${NC} "

        printf "  %s%-20s %s\n" "$indicators" "$branch" "($commit) → ${path/#$HOME/\~}"
    done

    echo
}

# Check if current directory is a worktree (not the main repository)
# Usage: if is_worktree_not_main; then ...
# Returns: 0 if in a worktree (not main), 1 if in main repository or not in git repo
is_worktree_not_main() {
    local main_repo
    local current_dir
    current_dir=$(git rev-parse --show-toplevel 2>/dev/null) || return 1

    # Get the git directory and determine the main repository
    main_repo=$(git rev-parse --git-common-dir 2>/dev/null) || return 1
    if [[ "$main_repo" == ".git" ]]; then
        # If .git is in the current directory, the main repo is current directory
        main_repo=$(git rev-parse --show-toplevel 2>/dev/null) || return 1
    else
        # Remove .git suffix to get the main repo directory
        main_repo=${main_repo%/.git}
    fi

    # If current directory is not the main repository, we're in a worktree
    [[ "$current_dir" != "$main_repo" ]]
}

################################################################################
# Worktree Listing Functions (for wtl/wtll commands)
################################################################################

# Format worktree information for short listing (wtl)
# Usage: format_worktree_line "$current_worktree" "$path" "$branch" "$commit" "$dirty" "$locked"
# Returns: Formatted line for display
format_worktree_line() {
    local current_worktree="$1"
    local path="$2"
    local branch="$3"
    local commit="$4"
    local dirty="$5"
    local locked="$6"

    # Build status indicators
    local status_indicators=""
    local path_display="${path/#$HOME/\~}"

    # Check if current worktree
    [[ "$path" == "$current_worktree" ]] && status_indicators="${GREEN}*${NC} "

    # Add other status indicators
    [[ "$dirty" == "true" ]] && status_indicators="${status_indicators}${YELLOW}[DIRTY]${NC} "
    [[ "$locked" == "true" ]] && status_indicators="${status_indicators}${RED}[LOCKED]${NC} "

    printf "%s%-20s %s %s\n" "$status_indicators" "$branch" "$commit" "$path_display"
}

# Format worktree information for long listing (wtll)
# Usage: format_worktree_long_line "$current_worktree" "$path" "$branch" "$commit" "$dirty" "$locked"
# Returns: Formatted lines for display with commit info
format_worktree_long_line() {
    local current_worktree="$1"
    local path="$2"
    local branch="$3"
    local commit="$4"
    local dirty="$5"
    local locked="$6"

    # Build status indicators
    local status_indicators=""
    local path_display="${path/#$HOME/\~}"

    # Check if current worktree
    [[ "$path" == "$current_worktree" ]] && status_indicators="${GREEN}*${NC} "

    # Add other status indicators
    [[ "$dirty" == "true" ]] && status_indicators="${status_indicators}${YELLOW}[DIRTY]${NC} "
    [[ "$locked" == "true" ]] && status_indicators="${status_indicators}${RED}[LOCKED]${NC} "

    printf "%s%-20s %s %s\n" "$status_indicators" "$branch" "$commit" "$path_display"

    # Get commit subject and relative time
    local commit_subject
    local commit_time
    commit_subject=$(git -C "$path" log -1 --format=%s "$commit" 2>/dev/null | head -1)
    commit_time=$(git -C "$path" log -1 --format=%cr "$commit" 2>/dev/null)

    # Format detailed status
    local detailed_status="Clean"
    local status_symbol="✓"
    local locked_status="No"

    if [[ "$dirty" == "true" ]]; then
        # Get file counts for dirty worktree
        local staged_count unstaged_count
        staged_count=$(git -C "$path" diff --cached --name-only 2>/dev/null | wc -l)
        unstaged_count=$(git -C "$path" diff --name-only 2>/dev/null | wc -l)
        detailed_status="Modified ! ($staged_count staged, $unstaged_count unstaged)"
        status_symbol="!"
    fi

    if [[ "$locked" == "true" ]]; then
        locked_status="Yes (locked)"
    fi

    printf "  %s\n" "${commit_subject:-No commits}"
    printf "  Status: %s %s | Locked: %s\n" "$detailed_status" "$status_symbol" "$locked_status"
    printf "\n"
}

# Get worktree commit subject
# Usage: get_worktree_commit_subject "/path/to/worktree"
# Returns: Commit subject or empty string
get_worktree_commit_subject() {
    local worktree_path="$1"

    if [[ -d "$worktree_path" ]]; then
        git -C "$worktree_path" log -1 --format=%s 2>/dev/null | head -1
    fi
}

# Get worktree commit time
# Usage: get_worktree_commit_time "/path/to/worktree"
# Returns: Relative time (e.g., "2 hours ago") or empty string
get_worktree_commit_time() {
    local worktree_path="$1"

    if [[ -d "$worktree_path" ]]; then
        git -C "$worktree_path" log -1 --format=%cr 2>/dev/null
    fi
}

# Output worktree information in JSON format
# Usage: output_worktree_json "$current_worktree" "$search_terms"
# Returns: JSON formatted worktree data
output_worktree_json() {
    local current_worktree="$1"
    local search_terms="$2"
    declare -a worktree_paths=() branches=() commits=() status_dirty=() locked_status=()

    if ! get_worktrees worktree_paths branches commits status_dirty locked_status; then
        printf '{"worktrees":[],"current":"%s","count":0}\n' "$current_worktree"
        return 0
    fi

    local count=0
    local first=true

    printf '{"worktrees":['
    for i in "${!worktree_paths[@]}"; do
        local path="${worktree_paths[$i]}"
        local branch="${branches[$i]}"
        local commit="${commits[$i]}"
        local dirty="${status_dirty[$i]}"
        local locked="${locked_status[$i]}"
        local is_current="false"

        [[ "$path" == "$current_worktree" ]] && is_current="true"

        # Apply search filter if provided using unified search function
        local show_worktree=true
        if [[ -n "$search_terms" ]]; then
            # Use the unified search function from hug-arrays
            if search_worktree "$path" "$branch" "$search_terms" "OR"; then
                show_worktree=true
            else
                show_worktree=false
            fi
        fi

        # Only include worktree if it matches search criteria (or no search provided)
        if $show_worktree; then
            if ! $first; then
                printf ','
            fi
            first=false

            printf '{'
            printf '"path":"%s",' "$path"
            printf '"branch":"%s",' "$branch"
            printf '"commit":"%s",' "$commit"
            printf '"dirty":%s,' "$dirty"
            printf '"locked":%s,' "$locked"
            printf '"current":%s' "$is_current"
            printf '}'
            count=$((count + 1))
        fi
    done

    printf '],"current":"%s","count":%d}\n' "$current_worktree" "$count"
}

# Create branch if needed with proper prompts
# Usage: create_branch_if_needed "branch-name" [new_flag] [force_flag]
# Returns: 0 on success, 1 on failure or user cancellation
create_branch_if_needed() {
    local branch="$1"
    local new_flag="${2:-false}"
    local force_flag="${3:-false}"

    # Check if branch already exists
    if git rev-parse --verify "refs/heads/$branch" >/dev/null 2>&1; then
        return 0  # Branch exists
    fi

    # Create branch based on flags
    if $new_flag || $force_flag; then
        # Create without prompting
        git branch "$branch"
        info "Created new branch '$branch'"
    else
        # Prompt to create
        warning "Branch '$branch' does not exist locally."
        info "Use --new flag to automatically create it."
        if prompt_confirm_safe "Create branch '$branch'?"; then
            git branch "$branch"
            info "Created new branch '$branch'"
        else
            return 1
        fi
    fi
}

# Get worktree path by branch name
# Usage: path=$(get_worktree_path_by_branch "branch-name")
# Returns: Path to worktree if branch has one, empty string otherwise
get_worktree_path_by_branch() {
    local branch="$1"

    if [[ -z "$branch" ]]; then
        echo ""
        return 1
    fi

    # Get all worktrees
    declare -a worktree_paths=() branches=() commits=() status_dirty=() locked_status=()

    if ! get_all_worktrees_including_main worktree_paths branches commits status_dirty locked_status; then
        echo ""
        return 1
    fi

    # Find matching branch
    for i in "${!branches[@]}"; do
        if [[ "${branches[$i]}" == "$branch" ]]; then
            echo "${worktree_paths[$i]}"
            return 0
        fi
    done

    # No matching branch found
    echo ""
    return 1
}
