# In ~/.gitconfig:
# [include]
#   path = $HUG_HOME/.gitconfig
#
# [user]
#   name = <name>
#   email = <email>

[include]
    path = $HUG_HOME/.delta.gitconfig

[commit]
    verbose = true

[pull]
  rebase = false

[pretty]
    log1        = %C(yellow)%h%C(reset) %C(blue)%ad%C(reset) %C(magenta)[%an]%C(reset)%C(auto)%d%C(reset) %s
    log1reldate = %C(yellow)%h%C(reset) %C(blue)%ad (%cr)%C(reset) %C(magenta)[%an]%C(reset)%C(auto)%d%C(reset) %s
    logbody     = %C(yellow)%h%C(reset) %C(blue)%ad (%cr)%C(reset) %C(magenta)[%an]%C(reset)%C(auto)%d%C(reset)%n%s%C(reset)%n%b
    stash       = %C(yellow)%gd%Creset %C(cyan)(%cr)%Creset %s

[alias]
  # ============================================================================
  # Discoverability
  # ============================================================================

  # Show all aliases (optionally search with: hug alias <pattern>)
  alias = !git config --list | grep ^alias\\. | cut -c 7- | grep -Ei --color \"$1\" "#"

  # ============================================================================
  # LOGGING
  # ============================================================================

  # Log one-line with graph and decorations
  l  = log --oneline --graph --decorate --color
  # Log commits after the last Upstream commit
  lu = l @{u}..HEAD

  # All branches
  la = l --all

  # Log one-line with date, author and message
  ll  = log --graph --pretty=log1 --date=short
  # Log commits after the last Upstream commit
  llu = ll @{u}..HEAD

  # All branches
  lla = ll --all

  # File history with patches (-p)
  lp = ll -p

  # log-outgoing aliases
  lo = log-outgoing --quiet
  lol = log-outgoing

  # Search commits by message
  lf = "!f() { \
    test $# -eq 0 -o \"$1\" = '-h' && { \
      printf 'hug lf: Search commits by MESSAGE.\n-i: Ignore case.\n-p: Show patches.\n--all: Consider ALL branches.\nUsage: git lf <search-term> [-ip] [--all]' >&2; return 1; }; \
    t=\"$1\"; shift; \
    hug ll --grep=\"$t\" \"$@\"; \
  }; f"

  # Search commits by code changes
  # Ex: Search in specific file
  # hug lc "getUserById" -- src/users.js
  lc = "!f() { \
    test $# -eq 0 -o \"$1\" = '-h' && { \
      printf '\nlc: Search commits by CODE CHANGES in diff.\n-i: Ignore case.\n-p: Show patches.\n--all: Consider ALL branches.\n-- file: Restrict to a file.\nUsage: hug lc <search-term> [-ip] [--all] [-- file]' >&2; return 1; }; \
    t=\"$1\"; shift; \
    git ll -S \"$t\" \"$@\"; \
  }; f"

  # Search commits by RegEx changes
  lcr = "!f() { \
    test $# -eq 0 -o \"$1\" = '-h' && { \
      printf '\nlcr: Search commits by RegEx CODE CHANGES in diff.\n-i: Ignore case.\n-p: Show patches.\n--all: Consider ALL branches.\n-- file: Restrict to a file.\nUsage: hug lcr <RegEx> [-ip] [--all] [-- file]' >&2; return 1; }; \
    t=\"$1\"; shift; \
    git ll -G \"$t\" \"$@\"; \
  }; f"

  # Commits by specific author
  lau = "!f() { t=\"${1:?(Search commits by AUTHOR) Missing search term}\"; shift; git ll --author=\"$t\" \"$@\"; }; f"

  # Commits in date range
  ld = "!f() { git ll --since=\"$1\" --until=\"${2:-now}\"; }; f"

  # ============================================================================
  # FILE INSPECTION
  # ============================================================================

  # Who changed what line (usage: hug fblame <file>)
  fblame = blame -w -C -C -C # w: Ignore whitespace changes; CCC: Detect code moved/copied within/across files (3 levels deep)

  # Short blame with just author and line (usage: hug fb <file>)
  fb = blame -w -C -C -C --line-porcelain

  # List all contributors to a file (usage: hug fcon <file>)
  fcon = "!f() { git log --follow --pretty=format:'%an <%ae>' -- \"$1\" | sort -u; }; f"

  # Count commits per author for a file (usage: hug fa <file>)
  fa = "!f() { git log --follow --format='%an' -- \"$1\" | sort | uniq -c | sort -rn; }; f"

  # Show when file was added (usage: hug fborn <file>)
  fborn = log --pretty=logbody --follow --diff-filter=A --find-renames=40% --

  # ═══════════════════════════════════════════════════════════════════
  #  STAGING (a*)
  # ═══════════════════════════════════════════════════════════════════

  # Invoke interactive add menu
  ai = add --interactive

  # Add patches interactively (no commit)
  ap = add --patch

  # ═══════════════════════════════════════════════════════════════════
  #  UNSTAGING / Undo Staging (us*)
  # ═══════════════════════════════════════════════════════════════════

  # Unstage specific files (most common - shortest alias)
  # Usage: hug us [<file> ...]
  # Now implemented as git-config/bin/git-us script with interactive UI
  # (alias removed - script takes precedence)

  # Unstage all files (nuclear option)
  # Usage: hug usa
  usa = reset HEAD

  # Stop tracking files but keep them locally
  # Usage: hug untrack [<file> ...]
  # Common use: hug untrack .env (after accidentally committing secrets)
  # Now implemented as git-config/bin/git-untrack script with interactive UI
  # (alias removed - script takes precedence)

  # ═══════════════════════════════════════════════════════════════════
  #  Head (h*)
  # ═══════════════════════════════════════════════════════════════════

  back = h back
  undo = h undo
  rollback = h rollback
  rewind = h rewind
  squash = h squash
  files = h files

  # ═══════════════════════════════════════════════════════════════════
  #  Working directory (w-*)
  # ═══════════════════════════════════════════════════════════════════

  # WIP workflow: commit everything as work-in-progress
  wip = w wip
  wips = w wips

  # Unpark: Squash-merge WIP branch into current and delete (for integration)
  unwip = w unwip

  get = w get

  # ──────────────────────────────────────────────────────────────────
  #  COMMITS (c*)
  # ──────────────────────────────────────────────────────────────────

  # Commit tracked files
  ca = commit -a

  # Modify (amend) last commit with staged changes only
  cm = commit --amend

  # Modify (amend) last commit with all tracked changes
  cma = commit -a --amend

  # ──────────────────────────────────────────────────────────────────
  #  INTERACTIVE COMMITS
  # ──────────────────────────────────────────────────────────────────

  # Commit patches interactively (most common workflow)
  # Stages hunks interactively, then commits
  cii = "!f() { \
    git add --patch && \
    git status -sb && \
    printf '\n' && \
    git diff --cached --stat && \
    printf '\nCommit message: ' && \
    read -r msg && \
    test -n \"$msg\" && git commit -m \"$msg\" || { \
      printf 'Aborted (empty message)\n' >&2; return 1; \
    }; \
  }; f"

  # Full interactive staging menu (git add -i wrapper)
  cim = "!git add --interactive && git s && git c"

  # ============================================================================
  # STASH
  # ============================================================================

  # List stashes with beautiful formatting
  sls = stash list --pretty=stash

  # ============================================================================
  #  Status (s?)
  # ============================================================================

  # No untracked files shown
  sl = !git statusbase -uno \"$@\"
  # Untracked files are also shown
  sla = !git statusbase --long \"$@\"
  # Untracked files are also shown
  sli = !git ls-files --others --ignored --exclude-standard && git s \"$@\"

  # ============================================================================
  # SHow object info (sh*)
  # ============================================================================

  # Show specific commit (defaults to last) with list of changed files
  sh = log -1 --stat --pretty=logbody --date=human-local
  # Show specific commit (defaults to last) with patch
  shp = show --pretty=logbody --date=human-local
  # Show files changed in a commit (usage: hug shc <commit-hash>)
  shc  = diff-tree --no-commit-id --name-only -r
  # Show file diff in a commit
  shf = "!f() { \
    test $# -eq 0 -o \"$1\" = '-h' && { \
      printf '\nshf: Show file at a commit (with patch).\nUsage: hug shf <file>' >&2; return 1; }; \
    t=\"$1\"; shift; \
    git shp \"$@\" -- \"$GIT_PREFIX$t\"; \
  }; f"

  # ═══════════════════════════════════════════════════════════════════
  #  TAG MANAGEMENT (t*)
  # ═══════════════════════════════════════════════════════════════════

  # List tags matching pattern (usage: hug t "v1.*")
  t = "!f() { git tag -l \"${1:-*}\"; }; f"

  # Create lightweight tag (default)
  # Usage: hug tc v1.0 [<commit>]
  tc = "!f() { \
    test $# -eq 0 && { printf 'Usage: hug tc <tag> [<commit>]\n' >&2; return 1; }; \
    git tag \"$@\"; \
  }; f"

  # Create annotated tag
  # Usage: hug ta v1.0 "Release version 1.0"
  ta = "!f() { \
    test $# -eq 0 && { printf 'Usage: hug ta <tag> [<message>]\n' >&2; return 1; }; \
    tag=\"$1\"; shift; \
    msg=\"${*:-Annotated tag $tag}\"; \
    git tag -a \"$tag\" -m \"$msg\"; \
  }; f"

  # Show tag details (usage: hug ts v1.0)
  ts = "!f() { \
    test $# -eq 0 && { printf 'Usage: hug ts <tag>\n' >&2; return 1; }; \
    git show \"$1\"; \
  }; f"

  # Rename tag (changes name, keeps same commit)
  # Usage: hug tr v1.0 v1.0.1
  tr = "!f() { \
    test $# -lt 2 && { printf 'Usage: hug tr <old-tag> <new-tag>\n' >&2; return 1; }; \
    old=\"$1\"; new=\"$2\"; \
    git rev-parse \"$old\" >/dev/null 2>&1 || { \
      printf 'Error: tag \"%s\" does not exist\n' \"$old\" >&2; return 1; \
    }; \
    commit=\"$(git rev-list -n 1 \"$old\")\"; \
    git tag \"$new\" \"$commit\" && git tag -d \"$old\" && \
    printf 'Tag \"%s\" renamed to \"%s\"\n' \"$old\" \"$new\"; \
  }; f"

  # Move tag (changes target commit, keeps same name)
  # Usage: hug tm v1.0 [<new-commit>]
  #   hug tm v1.0           → move to HEAD
  #   hug tm v1.0 a1b2c3d   → move to specific commit
  tm = "!f() { \
    test $# -eq 0 && { printf 'Usage: git tm <tag> [<new-commit>]\n' >&2; return 1; }; \
    tag=\"$1\"; \
    new_commit=\"${2:-HEAD}\"; \
    git rev-parse \"$tag\" >/dev/null 2>&1 || { \
      printf 'Error: tag \"%s\" does not exist\n' \"$tag\" >&2; return 1; \
    }; \
    old_commit=\"$(git rev-list -n 1 \"$tag\")\"; \
    git tag -f \"$tag\" \"$new_commit\" && \
    printf 'Tag \"%s\" moved:\n  %s → %s\n' \"$tag\" \"${old_commit:0:7}\" \"$(git rev-parse --short \"$new_commit\")\"; \
  }; f"

  # Move and re-annotate
  # Usage: hug tma v1.0 "New message" [<new-commit>]
  tma = "!f() { \
    test $# -lt 2 && { printf 'Usage: git tma <tag> <message> [<new-commit>]\n' >&2; return 1; }; \
    tag=\"$1\"; msg=\"$2\"; new_commit=\"${3:-HEAD}\"; \
    git rev-parse \"$tag\" >/dev/null 2>&1 || { \
      printf 'Error: tag \"%s\" does not exist\n' \"$tag\" >&2; return 1; \
    }; \
    old_commit=\"$(git rev-list -n 1 \"$tag\")\"; \
    git tag -f -a \"$tag\" -m \"$msg\" \"$new_commit\" && \
    printf 'Tag \"%s\" moved and re-annotated:\n  %s → %s\n' \"$tag\" \"${old_commit:0:7}\" \"$(git rev-parse --short \"$new_commit\")\"; \
  }; f"

  # Push tags to remote
  tpush = "!f() { \
    if [ $# -eq 0 ]; then \
      git push --tags; \
    else \
      git push origin \"$@\"; \
    fi; \
  }; f"

  tpull = "!f() { \
    git fetch --tags; \
  }; f"

  tpullf = "!f() { \
    git fetch --tags --prune --prune-tags --force; \
  }; f"

  # Delete local tag
  tdel = "!f() { \
    test $# -eq 0 && { printf 'Usage: hug td <tag>\n' >&2; return 1; }; \
    git tag -d \"$1\"; \
  }; f"

  # Delete remote tag
  tdelr = "!f() { \
    test $# -eq 0 && { printf 'Usage: hug tdr <tag>\n' >&2; return 1; }; \
    git push origin --delete \"$1\"; \
  }; f"

  # Checkout tag
  tco = "!f() { \
    test $# -eq 0 && { printf 'Usage: hug tco <tag>\n' >&2; return 1; }; \
    git checkout \"$1\"; \
  }; f"

  # ═══════════════════════════════════════════════════════════════════
  #  TAG QUERIES (tw*)
  # ═══════════════════════════════════════════════════════════════════

  # Show 'Tags Which Contain' a commit (commit is in tag's history)
  # Usage: hug twc [<commit>]  (defaults to HEAD)
  twc = "!f() { \
    commit=\"${1:-HEAD}\"; \
    git tag --contains \"$commit\"; \
  }; f"

  # Show 'Tags Which Point' directly at an object (exact match)
  # Usage: hug twp [<object>]  (defaults to HEAD)
  twp = "!f() { \
    object=\"${1:-HEAD}\"; \
    git tag --points-at \"$object\"; \
  }; f"

  # ============================================================================
  # BRANCHING
  # ============================================================================

  # ═══════════════════════════════════════════════════════════════════
  #  BRANCH NAVIGATION (most common → shortest)
  # ═══════════════════════════════════════════════════════════════════

  # Go back to previous branch (like 'cd -')
  # Usage: hug bs
  bs = switch -

  # ═══════════════════════════════════════════════════════════════════
  #  BRANCH LISTING
  # ═══════════════════════════════════════════════════════════════════

  # List all branches (local + remote)
  bla = branch -avv

  # List remote branches only
  blr = branch -rvv

  # ═══════════════════════════════════════════════════════════════════
  #  BRANCH CREATION / MODIFICATION
  # ═══════════════════════════════════════════════════════════════════

  # Create and switch to new branch
  # Usage: hug bc <branch-name>
  bc = switch -c

  # Rename current branch
  # Usage: hug br <new-name>
  br = branch -m

  # ═══════════════════════════════════════════════════════════════════
  #  BRANCH DELETION
  # ═══════════════════════════════════════════════════════════════════

  # Delete local branches with interactive UI (implemented as script)
  # Usage: hug bdel [<branch>...]
  # See: git-config/bin/git-bdel

  # Force delete local branch (dangerous: deletes even if unmerged)
  # Usage: hug bdelf <branch>
  bdelf = branch -D

  # Delete remote branch
  # Usage: hug bdelr <branch>
  bdelr = "!f() { \
    test $# -eq 0 -o \"$1\" = '-h' && { \
      printf 'bdelr: Delete remote branch\n' >&2; \
      printf 'Usage: hug bdelr <branch>\n' >&2; \
      return 1; \
    }; \
    git push origin --delete \"$1\"; \
  }; f"

  # Create a new branch from a specific existing branch:
  #! br <new> <existing>
  #! switch <new>

  # ═══════════════════════════════════════════════════════════════════
  #  BRANCH QUERIES (bw*)
  # ═══════════════════════════════════════════════════════════════════

  # Show 'Branches Which Contain' a commit (commit is in branch's history)
  # Usage: hug bwc [<commit>]  (defaults to HEAD)
  bwc = "!f() { \
    commit=\"${1:-HEAD}\"; \
    git branch --contains \"$commit\"; \
  }; f"

  # Show 'Branches Which Point' directly at an object (exact match)
  # Usage: hug bwp [<object>]  (defaults to HEAD)
  bwp = "!f() { \
    object=\"${1:-HEAD}\"; \
    git branch --points-at \"$object\"; \
  }; f"

  # Which branches DON'T contain this commit?
  # Usage: hug bwnc [<commit>]  (defaults to HEAD)
  bwnc = "!f() { \
    commit=\"${1:-HEAD}\"; \
    git branch --no-contains \"$commit\"; \
  }; f"

  # Which branches are merged into HEAD?
  bwm = "!f() { \
    commit=\"${1:-HEAD}\"; \
    git branch --merged \"$commit\"; \
  }; f"

  # Which branches are NOT merged into HEAD?
  bwnm = "!f() { \
    commit=\"${1:-HEAD}\"; \
    git branch --no-merged \"$commit\"; \
  }; f"

  # ═══════════════════════════════════════════════════════════════════
  #  REBASE OPERATIONS
  # ═══════════════════════════════════════════════════════════════════

  # Rebase interactive (clean up commits)
  # Usage: hug rbi [commit]
  #   hug rbi           → interactive rebase from root
  #   hug rbi HEAD~5    → interactive rebase last 5 commits
  #   hug rbi main      → interactive rebase since main
  rbi = "!f() { \
    if [ $# -eq 0 ]; then \
      git rebase -i --root; \
    else \
      git rebase -i \"$1\"; \
    fi; \
  }; f"

  # Continue rebase after resolving conflicts
  rbc = rebase --continue

  # Abort rebase (go back to before rebase)
  rba = rebase --abort

  # Skip current commit during rebase
  rbs = rebase --skip

  # ═══════════════════════════════════════════════════════════════════
  #  MERGE OPERATIONS
  # ═══════════════════════════════════════════════════════════════════

  # Squash-merge branch into current branch (doesn't commit)
  # Usage: hug m <branch>; hug c
  m = merge --squash

  # Merge with fast-forward only (fails if not possible)
  # Usage: git mff <branch>
  mff = merge --ff-only

  # Merge with no fast-forward (always create merge commit)
  # Usage: git mnf <branch>
  mkeep = merge --no-ff

  # Abort merge (go back to before merge)
  ma = merge --abort

  # ═══════════════════════════════════════════════════════════════════
  #  PUSH / PULL BRANCHES
  # ═══════════════════════════════════════════════════════════════════

  # Safe fast-forward pull (fails if merge/rebase needed)
  # Usage: hug bpull
  bpull = pull --ff-only

  # Pull with rebase (linear history)
  # Usage: hug bpullr
  bpullr = pull --rebase

  # Pull and update all remote tracking branches
  # Usage: hug pullall
  pullall = pull --all

  # ============================================================================
  # UTILITIES
  # ============================================================================

  # Show object type (usage: hug type <object>)
  type = cat-file -t

  # Show object contents (usage: hug dump <object>)
  dump = cat-file -p
