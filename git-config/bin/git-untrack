#!/usr/bin/env bash
# Assume HUG_HOME is set (exported by hug or environment)
# shellcheck source=git-config/lib/hug-common
. "$HUG_HOME/git-config/lib/hug-common"
# shellcheck source=git-config/lib/hug-git-kit
. "$HUG_HOME/git-config/lib/hug-git-kit"
# shellcheck source=git-config/lib/hug-file-input
. "$HUG_HOME/git-config/lib/hug-file-input"
set -euo pipefail  # Exit on error, undefined vars, pipe failures
# Part of the Hug tool suite

show_help() {
    cat << EOF
hug untrack: Stop tracking files but keep them locally

USAGE:
    hug untrack [<file>...] [--from-file <file>] [--from-commit <commit>] [--dry-run] [-f, --force] [--quiet] [-h, --help]

ARGUMENTS:
    <file>...          One or more file paths to untrack
                       If not provided, shows interactive list for selection

OPTIONS:
    --from-file <file>    Read file list from file or stdin (use '-' for stdin)
    --from-commit <commit> Use files changed in the specified commit
    --dry-run          Preview the untrack operation without applying changes
    -f, --force        Skip confirmation prompts (sets HUG_FORCE=true)
    --quiet            Suppress output (sets HUG_QUIET=T)
    -h, --help         Show this help

DESCRIPTION:
    Stops tracking one or more files while keeping them in the working directory.
    This is useful when you accidentally committed files that should be ignored
    (like .env, config.local.json, etc.) and want to stop tracking them without
    deleting them.

    When no file names are provided, displays an interactive menu using gum filter
    (if installed) for multi-selection. This makes it easy to select multiple
    files to untrack at once.

    If no tracked files exist (or only directories), displays an informative message.

    The --from-file flag reads file names from a file or stdin. It intelligently
    parses both simple file lists (one per line) and the output from 'hug sh'.

    The --from-commit flag directly extracts files from a commit's changes,
    providing an optimized workflow for untracking the same files as a previous commit.

    After untracking, remember to add the files to .gitignore to prevent them
    from being tracked again.

EXAMPLES:
    hug untrack                         # Interactive: select files to untrack
    hug untrack .env                    # Untrack single file
    hug untrack .env config.local.json  # Untrack multiple files
    hug untrack --from-file files.txt   # Untrack files from list
    hug untrack --from-commit HEAD~1    # Untrack files from previous commit
    hug sh HEAD~2 | hug untrack --from-file - # Untrack files from hug sh output
    hug untrack --dry-run               # Preview which files would be untracked

SEE ALSO:
    hug us         Unstage files (keep them tracked, just remove from staging)
    hug usa        Unstage all files
EOF
}

# Parse custom flags first
from_file=""
from_commit=""
remaining_args=()

while [[ $# -gt 0 ]]; do
  case "$1" in
    --from-file)
      if [[ -n "$from_commit" ]]; then
        error "Cannot use --from-file and --from-commit together. Use one or the other."
      fi
      from_file="$2"
      shift 2
      ;;
    --from-commit)
      if [[ -n "$from_file" ]]; then
        error "Cannot use --from-commit and --from-file together. Use one or the other."
      fi
      from_commit="$2"
      shift 2
      ;;
    -h|--help)
      show_help
      exit 0
      ;;
    --dry-run|--force|-f|--quiet)
      # These will be handled by parse_common_flags
      remaining_args+=("$1")
      shift
      ;;
    -*)
      error "Unknown option: $1. See 'hug untrack --help'."
      ;;
    *)
      remaining_args+=("$1")
      shift
      ;;
  esac
done

# Parse common flags with remaining arguments
eval "$(parse_common_flags "${remaining_args[@]}")"

# Handle file input flags
if [[ -n "$from_file" || -n "$from_commit" ]]; then
  files_from_source=()

  if [[ -n "$from_commit" ]]; then
    mapfile -t files_from_source < <(extract_files_from_commit "$from_commit")
  elif [[ -n "$from_file" ]]; then
    mapfile -t files_from_source < <(read_files_from_source "$from_file")
  fi

  # Filter out any common flags from remaining_args to get just files
  files_to_untrack=()
  for arg in "${remaining_args[@]}"; do
    case "$arg" in
      --dry-run|--force|-f|--quiet) ;;
      *) files_to_untrack+=("$arg") ;;
    esac
  done

  # Add files from source
  files_to_untrack+=("${files_from_source[@]}")
else
  # Filter out any common flags from remaining_args to get just files
  files_to_untrack=()
  for arg in "${remaining_args[@]}"; do
    case "$arg" in
      --dry-run|--force|-f|--quiet) ;;
      *) files_to_untrack+=("$arg") ;;
    esac
  done
fi

check_git_repo

# --- Main function for 'hug untrack' ---
hug_untrack() {
  local -a files_to_untrack=("$@")
  
  # If no files specified, show interactive menu
  if [[ ${#files_to_untrack[@]} -eq 0 ]]; then
    local -a tracked_files=()
    
    # Get all tracked files (excluding directories)
    mapfile -t tracked_files < <(
      git ls-files 2>/dev/null || true
    )
    
    if [[ ${#tracked_files[@]} -eq 0 ]]; then
      info "No tracked files to untrack."
      exit 0
    fi
    
    # Check if gum is available
    if ! gum_available; then
      error "Interactive mode requires 'gum' to be installed. Please install it or specify file names directly.
       Install: https://github.com/charmbracelet/gum"
    fi
    
    # Prepare formatted options for gum with file details
    local -a formatted_options=()
    
    for file in "${tracked_files[@]}"; do
      # Get file modification status
      local status=""
      if git diff --quiet -- "$file" 2>/dev/null && git diff --cached --quiet -- "$file" 2>/dev/null; then
        status="${GREEN}clean${NC}"
      elif ! git diff --cached --quiet -- "$file" 2>/dev/null; then
        status="${YELLOW}staged${NC}"
      else
        status="${YELLOW}modified${NC}"
      fi
      
      # Format for gum: plain text with details
      local formatted="${file} ${status}"
      formatted_options+=("$formatted")
    done
    
    # Use gum_filter_by_index for selection with exact matching
    local -a selected_indices=()
    mapfile -t selected_indices < <(
      gum_filter_by_index formatted_options \
                          "Select files to untrack (<TAB> to select, Enter to confirm)..." \
                          --no-limit
    )
    
    if [ ${#selected_indices[@]} -eq 0 ]; then
      info "No files selected."
      exit 0
    fi
    
    # Extract selected files using indices
    files_to_untrack=()
    for idx in "${selected_indices[@]}"; do
      files_to_untrack+=("${tracked_files[$idx]}")
    done
  fi
  
  # Validate that files exist and are tracked
  for file in "${files_to_untrack[@]}"; do
    if ! git ls-files --error-unmatch "$file" >/dev/null 2>&1; then
      error "File '$file' is not tracked by git."
    fi
  done
  
  # Set dry_run default if not already set by parse_common_flags
  local dry_run="${dry_run:-false}"
  
  # Preview mode
  if [[ "${dry_run}" == "true" ]]; then
    info "Dry run: Would untrack ${#files_to_untrack[@]} file(s):"
    for file in "${files_to_untrack[@]}"; do
      printf "  - %s\n" "$file" >&2
    done
    print_dry_run_preview "untrack the listed files (files will be kept locally)"
    return 0
  fi
  
  # Confirmation prompt (unless --force) for potentially destructive operation
  if [[ ${HUG_FORCE:-} != true ]]; then
    local count=${#files_to_untrack[@]}
    local file_word="file"
    [[ $count -gt 1 ]] && file_word="files"
    
    warning "About to untrack $count $file_word (files will be kept locally):"
    for file in "${files_to_untrack[@]}"; do
      printf "  - %s\n" "$file" >&2
    done
    printf "\n" >&2
    tip "Remember to add these files to .gitignore to prevent them from being tracked again."
    printf "\n" >&2
    prompt_confirm "⚠️  Proceed with untracking? [y/N]: "
  fi
  
  # Perform untracking
  if ! git rm --cached -- "${files_to_untrack[@]}" 2>/dev/null; then
    error "Failed to untrack files. Check file paths and permissions."
  fi
  
  # Report results
  local count=${#files_to_untrack[@]}
  local file_word="file"
  [[ $count -gt 1 ]] && file_word="files"
  
  success "Untracked $count $file_word (kept locally):"
  for file in "${files_to_untrack[@]}"; do
    printf "  ✓ %s\n" "$file" >&2
  done
  
  printf "\n" >&2
  tip "Don't forget to add these files to .gitignore to prevent them from being tracked again."
}

hug_untrack "${files_to_untrack[@]}"
