#!/usr/bin/env bash
# Assume HUG_HOME is set (exported by hug or environment)
# shellcheck source=git-config/lib/hug-common
. "$HUG_HOME/git-config/lib/hug-common"
# shellcheck source=git-config/lib/hug-git-kit
. "$HUG_HOME/git-config/lib/hug-git-kit"
set -euo pipefail  # Exit on error, undefined vars, pipe failures

# Part of the Hug tool suite

show_help() {
  cat <<'EOF'
hug ccp: Commit Cherry-Pick / Commit Clone / Carbon Copy (copy a commit onto HEAD).

USAGE:
  hug ccp [OPTIONS] <commit>...
  hug ccp [OPTIONS] <commit-range>
  hug ccp --husk <commit>

OPTIONS:
  --husk         Stage the same files as the source commit and reuse its message
  -h, --help     Show this help message and exit.
  (All other options are passed directly to 'git cherry-pick')

DESCRIPTION:
  This is a convenient alias for 'git cherry-pick -x', which copies the specified commit(s)
  onto the current branch while preserving the original commit's metadata (via -x). It supports
  single commits, ranges (e.g., HEAD~2..HEAD), or multiple commits.

  The --husk flag creates a new commit that reuses the structure (files and message)
  of the source commit without applying its actual changes. This is useful when you
  want to apply similar changes to different content or create a template commit.

  After cherry-picking, you can edit the new commit message with 'hug cm' if needed.
  Note: Cherry-picking can lead to conflicts; resolve them with 'hug s' (status) and 'hug caa' (commit all).

EXAMPLES:
  hug ccp a1b2c3d4              # Cherry-pick a single commit by hash
  hug ccp HEAD~2                # Cherry-pick the commit two steps back
  hug ccp HEAD~2..HEAD          # Cherry-pick a range of commits
  hug ccp a1b2c3 d4e5f6         # Cherry-pick multiple commits
  hug ccp --no-commit a1b2c3    # Cherry-pick without auto-committing (passes to git)
  hug ccp --husk abc123         # Stage same files as abc123 and reuse its message

EOF
}

error() {
  printf 'hug cc: %s\n' "$1" >&2
  exit "${2:-1}"
}

usage_error() {
  printf 'hug cc: %s\n\n' "$1" >&2
  show_help >&2
  exit 1
}

# Early exit if not in Git repo
check_git_repo

husk_mode=false
positional_args=()
git_options=()

while (($#)); do
  case "$1" in
    -h|--help)
      show_help
      exit 0
      ;;
    --husk)
      husk_mode=true
      shift
      ;;
    --)
      shift
      while (($#)); do
        positional_args+=("$1")
        shift
      done
      break
      ;;
    -*)
      # Assume it's a git cherry-pick option (pass through)
      git_options+=("$1")
      ;;
    *)
      positional_args+=("$1")
      ;;
  esac
  shift || break
done

set -- "${positional_args[@]}"

# Handle husk mode
if [[ "$husk_mode" == true ]]; then
  if [ $# -eq 0 ]; then
    usage_error "--husk mode requires a source commit to be specified."
  fi

  # Validate source commit
  validate_commitish "husk source commit" "$1"
  source_commit="$1"

  # Get list of files from source commit
  files=()
  mapfile -t files < <(extract_files_from_commit "$source_commit")

  if [ ${#files[@]} -eq 0 ]; then
    info "No files changed in commit '$source_commit'."
    exit 0
  fi

  printf "Staging %d file(s) from commit %s...\n" "${#files[@]}" "$source_commit"

  # Stage the files (but only if they exist in the working directory)
  files_to_stage=()
  for file in "${files[@]}"; do
    if [[ -e "$file" || -L "$file" ]]; then
      files_to_stage+=("$file")
    else
      warning "File '$file' does not exist in working directory, skipping."
    fi
  done

  if [ ${#files_to_stage[@]} -eq 0 ]; then
    info "No existing files to stage from commit '$source_commit'."
    exit 0
  fi

  # Stage the files
  git add "${files_to_stage[@]}"

  printf "Creating commit with message from %s...\n" "$source_commit"
  # Use git's native commit message reuse
  exec git commit -C "$source_commit"
fi

# Regular cherry-pick mode
if [ $# -eq 0 ]; then
  usage_error "No commit(s) specified. Provide at least one commit hash, reference, or range."
fi

# Validate that arguments are valid commitish (Git refs, hashes, or ranges)
for arg in "$@"; do
  validate_commitish "ccp argument" "$arg"
done

printf "Copying %s onto current branch...\n" "$*"
exec git cherry-pick -x "${git_options[@]}" "$@"
