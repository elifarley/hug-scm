#!/usr/bin/env bash
CMD_BASE="$(readlink -f "$0" 2>/dev/null || greadlink -f "$0")" || CMD_BASE="$0"; CMD_BASE="$(dirname "$CMD_BASE")"
for f in hug-common hug-git-kit hug-git-worktree; do . "$CMD_BASE/../lib/$f"; done # Load common constants and functions
set -euo pipefail  # Exit on error, undefined vars, pipe failures

# Part of the Hug tool suite

show_help() {
  cat <<'EOF'
hug wtl: List worktrees in short format, showing path, branch, and status.

USAGE:
  hug wtl [OPTIONS] [SEARCH_TERM]

OPTIONS:
  -h, --help     Show this help message and exit.
  --json         Output in JSON format instead of human-readable text.

DESCRIPTION:
  Displays each worktree sorted alphabetically. The current worktree is highlighted in green and marked with an asterisk (*).
  Each entry shows: path [branch] [status indicators] (short commit).

  Status indicators:
    [CURRENT] - The worktree you're currently in
    [DIRTY]   - Worktree has uncommitted changes
    [LOCKED]  - Worktree is locked (cannot be removed)

  If a search term is provided, only worktrees containing the term (case-insensitive substring match on path or branch name) are displayed.

EXAMPLES:
  hug wtl                  # List all worktrees
  hug wtl feature          # List worktrees containing "feature"
  hug wtl /home/user/project  # List worktrees containing that path
  hug wtl --json           # Output worktree information in JSON format

SEE ALSO:
  hug wtll : For listing worktrees in long form
  hug wt   : For interactive worktree selection and switching
  hug wtdel : For removing worktrees safely
EOF
}

# Parse arguments
json_output=false
while [[ $# -gt 0 ]]; do
  case "$1" in
    --json)
      json_output=true
      shift
      ;;
    -h|--help)
      show_help
      exit 0
      ;;
    *)
      # Treat remaining arguments as search terms
      break
      ;;
  esac
done

# Capture search terms
search_terms="$*"

# Early exit if not in Git repo
check_git_repo

# JSON output mode
if $json_output; then
  # Get current worktree path for JSON
  current_worktree=$(get_current_worktree_path)
  output_worktree_json "$current_worktree" "$search_terms"
  exit 0
fi

# Get worktree data
# NOTE: wtl lists all worktrees, including the main repository
declare -a worktree_paths=() branches=() commits=() status_dirty=() locked_status=()
if ! get_all_worktrees_including_main worktree_paths branches commits status_dirty locked_status; then
  printf "No worktrees found.\n" >&2
  exit 1
fi

# Get current worktree path for comparison
current_worktree=$(get_current_worktree_path)

# Build and print worktree list
printf "${BLUE}Worktrees:%s${NC}\n" ""
match_count=0
for i in "${!worktree_paths[@]}"; do
  path="${worktree_paths[$i]}"
  branch="${branches[$i]}"
  commit="${commits[$i]}"
  dirty="${status_dirty[$i]}"
  locked="${locked_status[$i]}"

  # Build status indicators
  status_indicators=""
  path_display="${path/#$HOME/\~}"

  # Check if current worktree
  [[ "$path" == "$current_worktree" ]] && status_indicators="${GREEN}*${NC} "

  # Add other status indicators
  [[ "$dirty" == "true" ]] && status_indicators="${status_indicators}${YELLOW}[DIRTY]${NC} "
  [[ "$locked" == "true" ]] && status_indicators="${status_indicators}${RED}[LOCKED]${NC} "

  # Apply search filter if provided using unified search function
  show_worktree=true
  if [[ -n "$search_terms" ]]; then
    # Use the unified search function from hug-arrays
    if search_worktree "$path" "$branch" "$search_terms" "OR"; then
      show_worktree=true
    else
      show_worktree=false
    fi
  fi

  # Only show worktree if it matches search criteria (or no search provided)
  if $show_worktree; then
    printf "%s%-20s %s %s\n" "$status_indicators" "$branch" "($commit)" "$path_display"
    match_count=$((match_count + 1))
  fi
done

# Return error if search terms were provided but no matches found
if [[ -n "$search_terms" && $match_count -eq 0 ]]; then
  printf "No worktrees found matching: %s\n" "$search_terms" >&2
  exit 1
fi