#!/usr/bin/env bash
CMD_BASE="$(readlink -f "$0" 2> /dev/null || greadlink -f "$0")" || CMD_BASE="$0"
CMD_BASE="$(dirname "$CMD_BASE")"
for f in hug-common hug-git-kit hug-git-tag; do . "$CMD_BASE/../lib/$f"; done # Load common constants and functions
set -euo pipefail                                                             # Exit on error, undefined vars, pipe failures

# Part of the Hug tool suite

show_help() {
  cat << 'EOF'
hug tll: List tags with detailed information and annotations.

USAGE:
  hug tll [options] [pattern]

OPTIONS:
  -h, --help            Show this help message and exit.
  -j, --json            Output tags in JSON format.
  -t, --type TYPE       Filter by tag type: lightweight, annotated, signed.

ARGUMENTS:
  pattern               Optional pattern to filter tag names (supports glob patterns).

DESCRIPTION:
  Lists all tags in the repository with detailed information including:
  - Tag type (lightweight/annotated/signed)
  - Commit hash and subject
  - Tag date and tagger (for annotated tags)
  - GPG signature status (for signed tags)
  - Current tag indicator
  - Remote status

  Tag Types:
    Lightweight - Direct pointer to a commit (no metadata)
    Annotated   - Full tag object with message, date, and tagger
    Signed      - Annotated tag with GPG signature

  With --json flag, outputs structured data including:
    Tag name, hash, type, subject, date, tagger info, and signature status.

  If a pattern is provided, only tags matching the pattern are shown.
  Supports glob patterns like 'v1.*' or 'release-*'.

EXAMPLES:
  hug tll                     # List all tags with details
  hug tll --json              # Output in JSON format
  hug tll --type annotated    # Show only annotated tags
  hug tll --type signed       # Show only signed tags
  hug tll v1.*                # Show v1.* tags with details
  hug tll release-*           # Show release tags with details

SEE ALSO:
  hug tl  : Simple tag list with type indicators
  hug t   : Interactive tag browser and selector

FURTHER READING:
  See 'git tag --help' and 'git for-each-ref --help'.
EOF
}

# Parse flags
json_output=false
type_filter=""
pattern=""

while [[ $# -gt 0 ]]; do
  case "$1" in
  -h | --help)
    show_help
    exit 0
    ;;
  -j | --json)
    json_output=true
    shift
    ;;
  -t | --type)
    if [[ $# -lt 2 ]]; then
      error "Option --type requires a value"
      exit 1
    fi
    type_filter="$2"
    if [[ "$type_filter" != "lightweight" && "$type_filter" != "annotated" && "$type_filter" != "signed" ]]; then
      error "Invalid type filter: $type_filter. Must be: lightweight, annotated, or signed"
      exit 1
    fi
    shift 2
    ;;
  -*)
    error "Unknown option: $1"
    show_help
    exit 1
    ;;
  *)
    if [[ -n "$pattern" ]]; then
      error "Only one pattern can be specified"
      exit 1
    fi
    pattern="$1"
    shift
    ;;
  esac
done

# Early exit if not in Git repo
check_git_repo

# Build options for print_detailed_tag_list
print_options=()

if [[ "$json_output" == "true" ]]; then
  print_options+=(--json)
fi

if [[ -n "$type_filter" ]]; then
  print_options+=(--type "$type_filter")
fi

# If pattern is provided, we need to filter the tags
if [[ -n "$pattern" ]]; then
  # Get all tags first
  current_tag=""
  max_len=0
  tags=()
  hashes=()
  types=()
  subjects=()
  dates=()
  signatures=()

  if ! compute_tag_details current_tag max_len hashes tags types subjects dates signatures; then
    warn "No tags found in this repository."
    exit 1
  fi

  # Filter tags by pattern and type
  i=0
  found=false
  for ((i = 0; i < ${#tags[@]}; i++)); do
    # Check pattern match
    if [[ "${tags[i]}" != $pattern ]]; then
      continue
    fi

    # Check type filter
    if [[ -n "$type_filter" && "${types[i]}" != "$type_filter" ]]; then
      continue
    fi

    found=true
    # Print detailed info for this tag
    tag="${tags[i]}"
    hash="${hashes[i]}"
    type="${types[i]}"
    subject="${subjects[i]}"
    date="${dates[i]}"

    # Header with tag name and type
    printf "${GREEN}%s${NC} " "$tag"

    case "$type" in
    "lightweight")
      printf "${GREY}(lightweight)${NC}"
      ;;
    "annotated")
      printf "${BLUE}(annotated)${NC}"
      ;;
    "signed")
      printf "${GREEN}(signed)${NC}"
      ;;
    esac

    # Current tag indicator
    if [[ "$tag" == "$current_tag" ]]; then
      printf " ${YELLOW}[CURRENT]${NC}"
    fi

    # Remote status
    if tag_exists_remote "$tag"; then
      printf " ${CYAN}[REMOTE]${NC}"
    fi

    printf "\n"

    # Commit info
    printf "  Commit: ${YELLOW}%s${NC}\n" "$hash"
    printf "  Subject: ${subject:-${GREY}(no message)${NC}}\n"

    # Annotated tag info
    if [[ "$type" != "lightweight" && -n "$date" ]]; then
      printf "  Tagged: %s\n" "$date"
      tagger_name=$(git for-each-ref --format='%(taggername)' "refs/tags/$tag")
      tagger_email=$(git for-each-ref --format='%(taggeremail)' "refs/tags/$tag")
      printf "  Tagger: ${BLUE}%s${NC} ${GREY}<%s>${NC}\n" "$tagger_name" "$tagger_email"

      # Signature info
      if [[ "$type" == "signed" ]]; then
        sig_status=$(get_tag_signature_info "$tag")
        if [[ "$sig_status" == "verified" ]]; then
          printf "  Signature: ${GREEN}Verified${NC}\n"
        else
          printf "  Signature: ${RED}Unverified${NC}\n"
        fi
      fi
    fi

    printf "\n"
  done

  if [[ "$found" == "false" ]]; then
    if [[ -n "$type_filter" ]]; then
      warn "No tags matching pattern '$pattern' with type '$type_filter' found."
    else
      warn "No tags matching pattern '$pattern' found."
    fi
    exit 1
  fi
else
  # No pattern, use library function with options
  print_detailed_tag_list "${print_options[@]}"
fi
