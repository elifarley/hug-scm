#!/usr/bin/env bash
CMD_BASE="$(readlink -f "$0" 2>/dev/null || greadlink -f "$0")" || CMD_BASE="$0"; CMD_BASE="$(dirname "$CMD_BASE")"
for f in hug-common hug-git-kit; do . "$CMD_BASE/../lib/$f"; done # Load common constants and functions
set -euo pipefail  # Exit on error, undefined vars, pipe failures

# Part of the Hug tool suite

show_help() {
  cat <<'EOF'
Usage: hug w zap [OPTIONS] [<path>...]

Wipe tracked changes and purge untracked / ignored files for the specified paths.

Options:
  -f, --force        Skip confirmation prompts
      --browse-root  Browse full repository scope in file selector UI (default: current directory)
      --dry-run      Show what would be affected without applying changes
  -h, --help         Show this help

Semantics:
  • Performs a full factory reset on the provided paths of the working directory so that they match HEAD verbatim.
  • ALL uncommitted changes on those paths (staged or unstaged) will be wiped (as in `hug wipe <path>`).
  • ALL untracked and ignored files on those paths will be gone for good (as in `hug purge -ui <path>`).
  • It's the same as `hug wipe <path>; hug purge -ui <path>`.

Behavior:
  • When run with no paths, shows an interactive file selection UI (requires gum).
  • By default, file selection is scoped to the current directory and subdirectories.
  • Use --browse-root to browse files across the entire repository in the UI.
  • When explicit paths are provided, they are interpreted relative to the current directory.
  • Use `hug w zap-all` to affect ALL files in the working directory without interactive selection.

Examples:
  hug w zap                       # Interactive UI, current directory scope
  hug w zap --browse-root         # Interactive UI, full repository scope
  hug w zap dir/                  # Zap everything in dir/ (CWD-relative)
EOF
}

force=false
dry_run=false
browse_root=false

while [[ $# -gt 0 ]]; do
  case "$1" in
    -f|--force)
      force=true
      shift
      ;;
    --browse-root)
      browse_root=true
      shift
      ;;
    --dry-run)
      dry_run=true
      shift
      ;;
    -h|--help)
      show_help
      exit 0
      ;;
    --)
      shift
      break
      ;;
    -*)
      opt=$1
      shift
      # expand combined short flags (e.g., -us)
      opt=${opt#-}
      for ((i=0; i<${#opt}; ++i)); do
        char=${opt:i:1}
        case "$char" in
          *)
            error "unknown option: -$char"
            show_help >&2
            exit 2
            ;;
        esac
      done
      ;;
    *)
      break
      ;;
  esac
done

# Early exit if not in Git repo
check_git_repo

# Handle interactive file selection when no paths provided
if [[ $# -lt 1 ]]; then
  # Check for conflicting flags
  if $browse_root; then
    # --browse-root without explicit paths is valid (triggers UI with full scope)
    :
  fi
  
  # Show all types: staged, unstaged, untracked, ignored
  declare -a select_opts=("--multi" "--staged" "--unstaged" "--untracked" "--ignored")
  
  # Default to --cwd (current directory scope) unless --browse-root is specified
  if ! $browse_root; then
    select_opts+=("--cwd")
  fi
  
  select_opts+=("--prompt" "Select files to zap (complete cleanup)...")
  
  paths=()
  if ! mapfile -t paths < <(select_files_with_status "${select_opts[@]}"); then
    info "No files selected or cancelled."
    exit 0
  fi
  
  if [[ ${#paths[@]} -eq 0 ]]; then
    info "No files selected."
    exit 0
  fi
else
  # Explicit paths provided - check for conflicting flags
  if $browse_root; then
    error "--browse-root cannot be used with explicit paths. 
       Either use --browse-root alone to browse files, or specify paths directly."
  fi
  
  paths=("$@")
fi

# Separate tracked/changed files from untracked/ignored files
declare -a tracked_paths=()
declare -a untracked_paths=()

while IFS= read -r -d '' entry; do
  [[ -z "$entry" ]] && continue
  status=${entry:0:2}
  path=${entry:3}
  case "$status" in
    '??'|'!!')
      # Untracked or ignored
      untracked_paths+=("$path")
      ;;
    *)
      # Tracked file (modified, staged, etc.)
      tracked_paths+=("$path")
      ;;
  esac
done < <(git status --porcelain=v1 --ignored=matching -z -- "${paths[@]}" 2>/dev/null || true)

# Convert paths to be relative to current directory before passing to sub-commands
# (git status returns repo-root-relative paths, but wipe/purge expect current-dir-relative)
convert_to_relative_paths tracked_paths
convert_to_relative_paths untracked_paths

if [[ ${#tracked_paths[@]} -eq 0 && ${#untracked_paths[@]} -eq 0 ]]; then
  print_nothing_to_do "zap" "for the provided paths."
  exit 0
fi

# Wipe tracked changes
if [[ ${#tracked_paths[@]} -gt 0 ]]; then
  wipe_cmd=(hug w wipe)
  $dry_run && wipe_cmd+=(--dry-run)
  $force && wipe_cmd+=(-f)
  wipe_cmd+=(-- "${tracked_paths[@]}")
  "${wipe_cmd[@]}"
fi

# Purge untracked/ignored files
if [[ ${#untracked_paths[@]} -gt 0 ]]; then
  purge_cmd=(hug w purge)
  $dry_run && purge_cmd+=(--dry-run)
  purge_cmd+=(-u -i -- "${untracked_paths[@]}")
  "${purge_cmd[@]}"
fi

exit 0
