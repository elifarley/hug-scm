#!/usr/bin/env bash
CMD_BASE="$(readlink -f "$0" 2>/dev/null || greadlink -f "$0")" || CMD_BASE="$0"; CMD_BASE="$(dirname "$CMD_BASE")"
for f in hug-common hug-git-kit; do . "$CMD_BASE/../lib/$f"; done # Load common constants and functions
set -euo pipefail  # Exit on error, undefined vars, pipe failures

# Part of the Hug tool suite

show_help() {
  cat <<'EOF'
Usage: hug w zap [OPTIONS] <path> [<path>...]

Wipe tracked changes and purge untracked / ignored files for the specified paths.

Options:
  -f, --force      Skip confirmation prompts
      --dry-run    Show what would be affected without applying changes
  -h, --help       Show this help

Semantics:
  • Performs a full factory reset on the provided paths of the working directory so that they match HEAD verbatim.
  • ALL uncommitted changes on those paths (staged or unstaged) will be wiped (as in `hug wipe <path>`).
  • ALL untracked and ignored files on those paths will be gone for good (as in `hug purge -ui <path>`).
  • It's the same as `hug wipe <path>; hug purge -ui <path>`.
  • Requires at least one path; use `hug w zap-all` to affect ALL files in the working directory.
EOF
}

force=false
dry_run=false

while [[ $# -gt 0 ]]; do
  case "$1" in
    -f|--force)
      force=true
      shift
      ;;
    --dry-run)
      dry_run=true
      shift
      ;;
    -h|--help)
      show_help
      exit 0
      ;;
    --)
      shift
      break
      ;;
    -*)
      opt=$1
      shift
      # expand combined short flags (e.g., -us)
      opt=${opt#-}
      for ((i=0; i<${#opt}; ++i)); do
        char=${opt:i:1}
        case "$char" in
          *)
            error "unknown option: -$char"
            show_help >&2
            exit 2
            ;;
        esac
      done
      ;;
    *)
      break
      ;;
  esac
done

if [[ $# -lt 1 ]]; then
  error "this command requires at least one path (or use 'hug w zap-all')"
  show_help >&2
  exit 2
fi

# Early exit if not in Git repo
check_git_repo

paths=("$@")

wipe_cmd=(hug w wipe)
$dry_run && wipe_cmd+=(--dry-run)
$force && wipe_cmd+=(-f)
wipe_cmd+=(-- "${paths[@]}")
"${wipe_cmd[@]}"

purge_cmd=(hug w purge)
$dry_run && purge_cmd+=(--dry-run)
$force && purge_cmd+=(-f)
purge_cmd+=(-u -i -- "${paths[@]}")
"${purge_cmd[@]}"

exit 0
