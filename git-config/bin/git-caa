#!/usr/bin/env bash
CMD_BASE="$(readlink -f "$0" 2> /dev/null || greadlink -f "$0")" || CMD_BASE="$0"
CMD_BASE="$(dirname "$CMD_BASE")"
# shellcheck source=../lib/hug-common
. "$CMD_BASE/../lib/hug-common"
# shellcheck source=../lib/hug-git-kit
. "$CMD_BASE/../lib/hug-git-kit"
# shellcheck source=../lib/hug-git-files
. "$CMD_BASE/../lib/hug-git-files"
# shellcheck source=../lib/hug-git-state
. "$CMD_BASE/../lib/hug-git-state"
# shellcheck source=../lib/hug-git-commit
. "$CMD_BASE/../lib/hug-git-commit"
set -euo pipefail # Exit on error, undefined vars, pipe failures
# Part of the Hug tool suite

show_help() {
  cat << EOF
hug caa: Commit all changes (tracked + untracked + deletions).

USAGE:
    hug caa [COMMIT_OPTIONS] [--dry-run] [-f, --force] [--quiet] [-h, --help]

ARGUMENTS:
    COMMIT_OPTIONS    Options passed directly to 'git commit' (e.g., -m "message", -v)

OPTIONS:
    --dry-run         Preview the staging and commit operation without applying changes
    -f, --force       Skip confirmation prompts (sets HUG_FORCE=true)
    --quiet           Suppress non-essential output (sets HUG_QUIET=T)
    -h, --help        Show this help

DESCRIPTION:
    Stages all changes in the working directory—including new untracked files, modifications to tracked files, and deletions—then commits them.
    This is equivalent to 'git add -A' followed by 'git commit'.
    If no changes are detected, the script exits early with a message.
    For large or destructive changes (e.g., many deletions), a confirmation prompt is shown unless --force is used.

EXAMPLES:
    hug caa -m "WIP: all changes"                  # Stage and commit everything with a message
    hug caa --dry-run                              # Preview what would be staged and committed
    hug caa -v                                     # Verbose commit (passes -v to git commit)
    hug caa                                        # Interactive commit (opens editor if no -m)

SEE ALSO:
    hug aa     Stage everything (without committing)
    hug c      Commit only staged changes
    hug ca     Commit all tracked changes (staged + unstaged, no untracked)
    hug a      Stage specific files or tracked changes
EOF
}

# Parse common flags (--dry-run, -f|--force, --quiet, -h|--help)
eval "$(parse_common_flags "$@")"

# Collect remaining args for git commit
commit_args=()
while [[ $# -gt 0 ]]; do
  case "$1" in
  -*)
    # Unknown options after commons; let git commit handle them or error
    commit_args+=("$1")
    shift
    ;;
  *)
    commit_args+=("$1")
    shift
    ;;
  esac
done

check_git_repo

# --- Main function for 'hug caa' ---
hug_caa() {
  local commit_args=("$@")

  # Check if there are any changes to stage/commit
  if ! has_pending_changes; then
    info "No changes to stage or commit."
    return 0
  fi

  # Dry-run preview
  if [[ "${dry_run:-false}" == "true" ]]; then
    info "Dry run: Previewing 'caa' operation (stage all and commit)."

    printf "\nChanges that would be staged:\n" >&2

    # Untracked files
    local -a untracked=()
    mapfile -t untracked < <(list_untracked_files)
    if [[ ${#untracked[@]} -gt 0 ]]; then
      printf "\n  UNTRACKED (%d files):\n" "${#untracked[@]}" >&2
      printf "    %s\n" "${untracked[@]}" >&2
    fi

    # Already staged (rare, but show)
    local -a staged=()
    mapfile -t staged < <(list_staged_files)
    if [[ ${#staged[@]} -gt 0 ]]; then
      printf "\n  ALREADY STAGED (%d files):\n" "${#staged[@]}" >&2
      printf "    %s\n" "${staged[@]}" >&2
    fi

    # Unstaged with status (mods + dels)
    local -a unstaged_status=()
    mapfile -t unstaged_status < <(list_unstaged_files --status)
    local mod_count=0 del_count=0
    for line in "${unstaged_status[@]}"; do
      local status="${line%%	*}"
      local file="${line#*	}"
      if [[ "$status" == D* ]]; then
        printf "  ⚠️  DELETE: %s\n" "$file" >&2
        ((del_count++))
      else
        printf "  MODIFY: %s\n" "$file" >&2
        ((mod_count++))
      fi
    done
    if [[ $((mod_count + del_count)) -gt 0 ]]; then
      printf "\n  UNSTAGED SUMMARY: %d modified, %d deleted\n" "$mod_count" "$del_count" >&2
    fi

    local total_change_count=$((${#untracked[@]} + ${#staged[@]} + mod_count + del_count))
    printf "\nSummary: Would stage %s files and commit them.\n" "$total_change_count" >&2

    if [[ ${#commit_args[@]} -gt 0 ]]; then
      printf "Commit options: %s\n" "${commit_args[*]}" >&2
    else
      printf "Commit would open editor for message.\n" >&2
    fi

    print_dry_run_preview "stage all changes and commit with ${commit_args[*]:-default message}"
    return 0
  fi

  # Check for potentially large/destructive changes and confirm
  local -a unstaged_with_status=()
  mapfile -t unstaged_with_status < <(list_unstaged_files --status)
  local unstaged_count=${#unstaged_with_status[@]}
  local deletions_count=0
  for line in "${unstaged_with_status[@]}"; do
    local status="${line%%	*}"
    if [[ "$status" == D* ]]; then
      ((deletions_count++))
    fi
  done

  local -a untracked_files=()
  mapfile -t untracked_files < <(list_untracked_files)
  local untracked_count=${#untracked_files[@]}

  local -a staged_files=()
  mapfile -t staged_files < <(list_staged_files)
  local staged_count=${#staged_files[@]}

  local change_count=$((unstaged_count + untracked_count + staged_count))
  local has_deletions=false
  [[ $deletions_count -gt 0 ]] && has_deletions=true

  local needs_confirm=false
  if [[ $change_count -gt 10 ]] || $has_deletions; then
    needs_confirm=true
  fi

  if $needs_confirm && [[ ${HUG_QUIET:-} != T && ${HUG_FORCE:-} != true ]]; then
    warning "Detected potentially large/destructive changes:"
    if [[ $change_count -gt 10 ]]; then
      warning "  - $unstaged_count unstaged, $untracked_count untracked, $staged_count already staged (total: $change_count)"
    fi
    if $has_deletions; then
      warning "  - $deletions_count deletions involved (use 'git status' to review)"
    fi
    prompt_confirm_warn "Proceed to stage all and commit? [y/N]: "
  fi

  info "Staging all changes..."
  hug aa

  local pre_commit_staged_count
  mapfile -t pre_commit_staged_files < <(list_staged_files)
  pre_commit_staged_count=${#pre_commit_staged_files[@]}

  info "Committing all staged changes..."
  hug c "${commit_args[@]}"

  success "Committed all changes ($pre_commit_staged_count files staged and committed)."

  # Suggest push command if applicable
  suggest_next_push_command
}

hug_caa "${commit_args[@]}"
