#!/usr/bin/env bash

# Smart help that suggests related commands
# Usage: hug help [prefix]
test $# -eq 0 && {
  echo "Available command groups:"
  echo '  a*  - Add to staging area'
  echo '  b*  - Branch operations'
  echo '  c*  - Commit operations'
  echo '  f*  - File operations'
  echo '  h*  - HEAD operations'
  echo '  l*  - Log/history operations'
  echo '  p*  - Push / pull operations'
  echo '  s*  - Status operations'
  echo ' sh*  - SHow operations'
  echo '  t*  - Tag operations'
  echo '  u*  - Utility commands'
  echo '  w*  - Working dir operations'
  echo ''
  echo "Use 'hug help [prefix]' to see commands with that prefix"
  exit 0
}
prefix="$1"
dir=$(dirname "$0")

# Show help for exact command if exists (script preferred over alias)
if command -v "git-$prefix" > /dev/null 2>&1; then
  echo
  "git-$prefix" --help
  echo
elif [ -n "$(git config --get "alias.$prefix" 2>/dev/null)" ]; then
  git $prefix -h
  echo
fi

echo "Commands starting with '$prefix':"

# Collect Git aliases starting with prefix (exclude exact prefix)
aliases=()
while IFS== read -r name def; do
  if [ "$name" != "$prefix" ] && [[ "$name" == ${prefix}* ]]; then
    aliases+=("$name")
  fi
done < <(git config --list | grep "^alias\.${prefix}" | cut -c 7- | sort)

# If prefix is 'l', add tips for common file history queries
if [[ "$prefix" == "l" ]]; then
  echo ""
  echo "Tips for file history (use with llf/llfp/llfs):"
  echo "  llf <file> -1     # Most recent commit touching file"
  echo "  llf <file> -N     # Last N commits for file"
  echo "  llfp <file> -1    # Patch of most recent change"
  echo "  llfs <file> -1    # Stats for most recent"
fi

# Collect script commands starting with prefix (exclude exact prefix)
scripts=()
if [ -d "$dir" ]; then
  for f in "$dir"/git-${prefix}*; do
    if [ -f "$f" ]; then
      script_name=$(basename "$f" | sed 's/^git-//')
      if [ "$script_name" != "$prefix" ]; then
        scripts+=("$script_name")
      fi
    fi
  done
fi

# Combine, sort unique, and print
all_commands=($(printf '%s\n' "${aliases[@]}" "${scripts[@]}" | sort -u))
if [ ${#all_commands[@]} -eq 0 ]; then
  echo "  (none)"
else
  for cmd in "${all_commands[@]}"; do
    echo "  hug $cmd"
  done
fi

# Special handling for gateways like h, w, etc. - add subcommands if prefix is a gateway
if [[ "$prefix" == "h" ]]; then
  echo ""
  echo "h* subcommands (HEAD operations):"
  echo "  back     - Move HEAD back, keep staged"
  echo "  files    - Preview files touched by commits to rewind"
  echo "  rollback - Rollback commit, preserve local work"
  echo "  rewind   - Rewind to clean state (destructive)"
  echo "  squash   - Squash last N commits into 1 with original message"
  echo "  steps    - Count steps back to last file change"
  echo "  undo     - Move HEAD back, unstage changes"
  echo ""
  echo "All mutating h* commands (back, undo, rollback, rewind, squash) support:"
  echo "  -u/--upstream: Target remote upstream tip"
  echo "  --force: Skip confirmation prompts (use cautiously)"
  echo "  e.g., 'hug h back -u' (HEAD moves to origin/BRANCH, discard local commits)"
  echo "  e.g., 'hug h rewind 3 --force' (destructive, no prompt)"
fi

# Special handling for utilities
if [[ "$prefix" == "u" ]]; then
  echo ""
  echo "Utilities (no prefix):"
  echo "  init       - Initialize new repository"
  echo "  clone      - Clone repository (auto-detects Git/Mercurial)"
  echo "  remote2ssh - Convert remote HTTPS URL to SSH"
  echo "  type       - Show Git object type"
  echo "  dump       - Show Git object contents"
  echo "  untrack    - Stop tracking files (keep locally)"
fi

exit 0
