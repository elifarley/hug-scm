#!/usr/bin/env bash
CMD_BASE="$(readlink -f "$0" 2>/dev/null || greadlink -f "$0")" || CMD_BASE="$0"; CMD_BASE="$(dirname "$CMD_BASE")"
for f in hug-common hug-git-kit; do . "$CMD_BASE/../lib/$f"; done
set -euo pipefail  # Exit on error, undefined vars, pipe failures

# Part of the Hug tool suite

show_help() {
  printf 'hug llf: Log commits to a file (handles renames).\n' >&2
  printf -- '<file>: File to show log for (optional - prompts for selection if omitted).\n' >&2
  printf -- '--browse-root: Browse full repository scope in file selector UI (default: current directory).\n' >&2
  printf -- '-<N>: Limit to last N commits (e.g., -1 for most recent).\n' >&2
  printf -- '-p: Show patches.\n' >&2
  printf 'Usage: hug llf [<file>] [-N] [-p] [--browse-root] [log options]\n' >&2
  printf 'Examples:\n' >&2
  printf '  hug llf                       # Interactive file selection (current directory)\n' >&2
  printf '  hug llf --browse-root         # Interactive file selection (full repository)\n' >&2
  printf '  hug llf file.txt -1           # Most recent commit touching file\n' >&2
  printf '  hug llf file.txt -2 --stat   # Last 2 commits with stats\n' >&2
}

# Parse common flags (handles --browse-root, etc.)
eval "$(parse_common_flags "$@")"

# Initialize common flag variables if not set by parse_common_flags
: "${browse_root:=false}"

# If no file provided, show interactive selection or help
if [ $# -eq 0 ]; then
  # Only show interactive selection if gum is available
  if gum_available; then
    declare -a select_opts=("--single")
    
    # Default to --cwd (current directory scope) unless --browse-root is specified
    if ! $browse_root; then
      select_opts+=("--cwd")
    fi
    
    select_opts+=("--prompt" "Select file to view log...")
    
    file=""
    if ! file=$(select_files_with_status "${select_opts[@]}"); then
      info "No file selected or cancelled."
      exit 0
    fi
    exec hug ll --follow -- "$file"
  else
    # Fall back to showing help when gum is not available
    show_help
    exit 1
  fi
fi

file="$1"; shift

exec hug ll "$@" --follow -- "$file"

