#!/usr/bin/env bash
# Assume HUG_HOME is set (exported by hug or environment)
# shellcheck source=git-config/lib/hug-common
. "$HUG_HOME/git-config/lib/hug-common"
# shellcheck source=git-config/lib/hug-git-kit
. "$HUG_HOME/git-config/lib/hug-git-kit"
set -euo pipefail  # Exit on error, undefined vars, pipe failures
# Part of the Hug tool suite

show_help() {
    cat << EOF
hug us: UnStage one or more files

USAGE:
    hug us [<file>...] [--dry-run] [-f, --force] [--quiet] [-h, --help]

ARGUMENTS:
    <file>...          One or more file paths to unstage
                       If not provided, shows interactive list for selection

OPTIONS:
    --dry-run          Preview the unstage operation without applying changes
    -f, --force        Skip confirmation prompts (sets HUG_FORCE=true)
    --quiet            Suppress output (sets HUG_QUIET=T)
    -h, --help         Show this help

DESCRIPTION:
    Unstages one or more files (removes them from the staging area while keeping
    the changes in the working directory). This is equivalent to 'git restore --staged'.

    When no file names are provided, displays an interactive menu using gum filter
    (if installed) for multi-selection. This makes it easy to select multiple
    files to unstage at once.

    If no staged files exist, displays an informative message.

EXAMPLES:
    hug us                              # Interactive: select files to unstage
    hug us file.txt                     # Unstage single file
    hug us src/main.js tests/test.js    # Unstage multiple files
    hug us --dry-run                    # Preview which files would be unstaged

SEE ALSO:
    hug a          Stage tracked files
    hug aa         Stage all files (including untracked)
    hug usa        Unstage all files
EOF
}

# Parse common flags (--dry-run, -f|--force, --quiet, -h|--help)
eval "$(parse_common_flags "$@")"

# Collect file names
files_to_unstage=()
while [[ $# -gt 0 ]]; do
  case "$1" in
    -*)
      error "Unknown option: $1. See 'hug us --help'."
      ;;
    *)
      files_to_unstage+=("$1")
      shift
      ;;
  esac
done

check_git_repo

# --- Main function for 'hug us' ---
hug_us() {
  local -a files_to_unstage=("$@")
  
  # If no files specified, show interactive menu
  if [[ ${#files_to_unstage[@]} -eq 0 ]]; then
    local -a staged_files=()
    
    # Get all staged files
    mapfile -t staged_files < <(
      git diff --cached --name-only 2>/dev/null || true
    )
    
    if [[ ${#staged_files[@]} -eq 0 ]]; then
      info "No staged files to unstage."
      exit 0
    fi
    
    # Check if gum is available
    if ! gum_available; then
      error "Interactive mode requires 'gum' to be installed. Please install it or specify file names directly.
       Install: https://github.com/charmbracelet/gum"
    fi
    
    # Prepare formatted options for gum with file details
    local -a formatted_options=()
    
    for file in "${staged_files[@]}"; do
      # Skip empty file names (defensive)
      [[ -z "$file" ]] && continue
      
      # Get file status (new, modified, etc.)
      local status
      status=$(git diff --cached --name-status "$file" 2>/dev/null | cut -f1 || echo "M")
      
      local status_text
      case "$status" in
        A) status_text="${GREEN}new${NC}" ;;
        M) status_text="${YELLOW}modified${NC}" ;;
        D) status_text="${RED}deleted${NC}" ;;
        R*) status_text="${BLUE}renamed${NC}" ;;
        C*) status_text="${BLUE}copied${NC}" ;;
        *) status_text="${GREY}changed${NC}" ;;
      esac
      
      # Format for gum: plain text with details
      local formatted="${file} ${status_text}"
      # Only add non-empty formatted options
      [[ -n "$formatted" ]] && formatted_options+=("$formatted")
    done
    
    # Additional safety check: ensure we have formatted options
    if [[ ${#formatted_options[@]} -eq 0 ]]; then
      error "No valid staged files found to display. This may be a bug - please report it."
    fi
    
    # Use gum filter for multi-selection
    local gum_height
    gum_height=$(gum_calculate_height "${#formatted_options[@]}")
    
    local selection
    selection=$(printf '%s\n' "${formatted_options[@]}" | \
      gum filter --placeholder="Select files to unstage (<TAB> to select, Enter to confirm)..." \
                  --height="$gum_height" \
                  --no-limit \
                  --no-strip-ansi \
                  --reverse || true)
    
    if [[ -z "$selection" ]]; then
      info "Cancelled."
      exit 0
    fi
    
    # Extract file names from selection
    files_to_unstage=()
    while IFS= read -r line; do
      [[ -z "$line" ]] && continue
      # Extract file name (first word before status)
      local file_name="${line%% *}"
      files_to_unstage+=("$file_name")
    done <<< "$selection"
    
    if [[ ${#files_to_unstage[@]} -eq 0 ]]; then
      info "No files selected."
      exit 0
    fi
  fi
  
  # Validate that files exist and are staged
  for file in "${files_to_unstage[@]}"; do
    if ! git ls-files --error-unmatch "$file" >/dev/null 2>&1; then
      error "File '$file' is not tracked by git."
    fi
    
    # Check if file is actually staged
    if git diff --cached --quiet -- "$file" 2>/dev/null; then
      error "File '$file' is not staged."
    fi
  done
  
  # Set dry_run default if not already set by parse_common_flags
  local dry_run="${dry_run:-false}"
  
  # Preview mode
  if [[ "${dry_run}" == "true" ]]; then
    info "Dry run: Would unstage ${#files_to_unstage[@]} file(s):"
    for file in "${files_to_unstage[@]}"; do
      printf "  - %s\n" "$file" >&2
    done
    print_dry_run_preview "unstage the listed files"
    return 0
  fi
  
  # Perform unstaging
  if ! git restore --staged -- "${files_to_unstage[@]}" 2>/dev/null; then
    error "Failed to unstage files. Check file paths and permissions."
  fi
  
  # Report results
  local count=${#files_to_unstage[@]}
  local file_word="file"
  [[ $count -gt 1 ]] && file_word="files"
  
  success "Unstaged $count $file_word:"
  for file in "${files_to_unstage[@]}"; do
    printf "  âœ“ %s\n" "$file" >&2
  done
}

hug_us "${files_to_unstage[@]}"
