#!/usr/bin/env bash
# Assume HUG_HOME is set (exported by hug or environment)
# shellcheck source=git-config/lib/hug-common
. "$HUG_HOME/git-config/lib/hug-common"
# shellcheck source=git-config/lib/hug-git-kit
. "$HUG_HOME/git-config/lib/hug-git-kit"
set -euo pipefail  # Exit on error, undefined vars, pipe failures
# Part of the Hug tool suite

show_help() {
    cat << EOF
hug bdel: Delete one or more local branches safely

USAGE:
    hug bdel [<branch>...] [--dry-run] [-f, --force] [-q, --quiet] [-h, --help]

ARGUMENTS:
    <branch>...        One or more branch names to delete
                       If not provided, shows interactive list for selection

OPTIONS:
    --dry-run          Preview the delete operation without applying changes
    -f, --force        Skip confirmation prompts and force delete unmerged branches
    -q, --quiet        Suppress output (sets HUG_QUIET=T)
    -h, --help         Show this help

DESCRIPTION:
    Safely deletes one or more local branches. By default, only merged branches
    can be deleted. Use --force to delete unmerged branches.

    When no branch names are provided, displays an interactive menu using gum filter
    (if installed) for multi-selection. This makes it easy to select multiple
    branches to delete at once.

    Backup branches (hug-backups/**) are not shown in the list. Use 'hug bdel-backup'
    to manage backup branches.

    Before deletion, a confirmation prompt shows the count and names of selected
    branches. Use --force to skip confirmation.

EXAMPLES:
    hug bdel                              # Interactive: select branches to delete
    hug bdel feature/old                  # Delete single branch
    hug bdel feat-1 feat-2 feat-3        # Delete multiple branches
    hug bdel --dry-run                    # Preview which branches would be deleted
    hug bdel feature/old --force          # Force delete even if unmerged

SEE ALSO:
    hug bdel-backup    Delete backup branches with filtering options
    hug bl             List local branches
    hug brestore       Restore a branch from backup
EOF
}

# Parse common flags (--dry-run, -f|--force, -q|--quiet, -h|--help)
eval "$(parse_common_flags "$@")"

# Collect branch names
branches_to_delete=()
while [[ $# -gt 0 ]]; do
  case "$1" in
    -*)
      error "Unknown option: $1. See 'hug bdel --help'."
      ;;
    *)
      branches_to_delete+=("$1")
      shift
      ;;
  esac
done

check_git_repo

# Get current branch name to prevent deletion
current_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "")

# --- Main function for 'hug bdel' ---
hug_bdel() {
  local -a branches_to_delete=("$@")
  local -a formatted_to_delete=()
  
  # If no branches specified, show interactive menu using library functions
  if [[ ${#branches_to_delete[@]} -eq 0 ]]; then
    # Check if there are any branches available for deletion before showing interface
    declare -a available_branches=() available_hashes=() available_subjects=() available_tracks=()
    local available_current_branch="" available_max_len=""

    if compute_local_branch_details available_current_branch available_max_len available_hashes available_branches available_tracks available_subjects "true"; then
      declare -a filtered_branches=()
      declare -a filtered_hashes=() filtered_subjects=() filtered_tracks=()
      filter_branches available_branches available_hashes available_subjects available_tracks "$available_current_branch" \
          filtered_branches filtered_hashes filtered_subjects filtered_tracks \
          "true" "true" ""

      if [[ ${#filtered_branches[@]} -eq 0 ]]; then
        if [[ -n "$available_current_branch" && "$available_current_branch" != "HEAD" ]]; then
          info "No other branches to delete (only current branch '$available_current_branch' exists)."
        else
          info "No branches to delete."
        fi
        exit 0
      fi
    else
      info "No branches to delete."
      exit 0
    fi

    # Use existing select_branches function for consistent UX
    if ! select_branches branches_to_delete \
            --multi-select \
            --exclude-current \
            --exclude-backup \
            --placeholder "Select branches to delete (<TAB> to select, Enter to confirm)..."; then
      info "No branches selected."
      exit 0
    fi
  fi
  
  # Validate that none of the branches is the current branch
  for branch in "${branches_to_delete[@]}"; do
    if [[ "$branch" == "$current_branch" ]]; then
      error "Cannot delete current branch '$current_branch'. Switch to another branch first."
    fi
    
    validate_commitish "bdel argument" "$branch"
  done
  
  # Set dry_run default if not already set by parse_common_flags
  local dry_run="${dry_run:-false}"
  
  # Preview mode
  if [[ "${dry_run}" == "true" ]]; then
    info "Dry run: Would delete ${#branches_to_delete[@]} branch(es):"
    if [[ ${#formatted_to_delete[@]} -gt 0 ]]; then
      for formatted in "${formatted_to_delete[@]}"; do
        printf "  - %s\n" "$formatted" >&2
      done
    else
      # Fallback for CLI args (no formatted)
      for branch in "${branches_to_delete[@]}"; do
        local hash
        hash=$(git rev-parse --short "$branch" 2>/dev/null || echo "???????")
        printf "  - %s (%s)\n" "$branch" "$hash" >&2
      done
    fi
    print_dry_run_preview "delete the listed branches"
    return 0
  fi
  
  # Confirmation prompt (unless --force)
  if [[ ${HUG_FORCE:-} != true ]]; then
    local count=${#branches_to_delete[@]}
    local branch_word="branch"
    [[ $count -gt 1 ]] && branch_word="branches"
    
    warning "About to delete $count $branch_word:"
    if [[ ${#formatted_to_delete[@]} -gt 0 ]]; then
      for formatted in "${formatted_to_delete[@]}"; do
        printf "  - %s\n" "$formatted" >&2
      done
    else
      # Fallback for CLI args (no formatted)
      for branch in "${branches_to_delete[@]}"; do
        local hash
        hash=$(git rev-parse --short "$branch" 2>/dev/null || echo "???????")
        printf "  - %s (%s)\n" "$branch" "$hash" >&2
      done
    fi
    printf "\n" >&2
    prompt_confirm "⚠️  Delete these ${branch_word}? [y/N]: "
  fi
  
  # Perform deletion
  local deleted_count=0
  local failed_count=0
  local -a deleted_branches=()
  local -a failed_branches=()
  
  for branch in "${branches_to_delete[@]}"; do
    # Determine delete flag based on force option
    local delete_flag="-d"  # Safe delete (only merged)
    if [[ ${HUG_FORCE:-} == true ]]; then
      delete_flag="-D"  # Force delete (even unmerged)
    fi
    
    if git branch "$delete_flag" "$branch" >/dev/null 2>&1; then
      deleted_branches+=("$branch")
      deleted_count=$((deleted_count + 1))
    else
      failed_branches+=("$branch")
      failed_count=$((failed_count + 1))
    fi
  done
  
  # Report results
  if [[ $deleted_count -gt 0 ]]; then
    local branch_word="branch"
    [[ $deleted_count -gt 1 ]] && branch_word="branches"
    success "Deleted $deleted_count $branch_word:"
    if [[ ${#formatted_to_delete[@]} -gt 0 ]]; then
      for i in "${!deleted_branches[@]}"; do
        if [[ "${deleted_branches[$i]}" == "${branches_to_delete[$i]}" ]]; then
          printf "  ✓ %s\n" "${formatted_to_delete[$i]}" >&2
        else
          printf "  ✓ %s\n" "${deleted_branches[$i]}" >&2
        fi
      done
    else
      for branch in "${deleted_branches[@]}"; do
        printf "  ✓ %s\n" "$branch" >&2
      done
    fi
  fi
  
  if [[ $failed_count -gt 0 ]]; then
    local branch_word="branch"
    [[ $failed_count -gt 1 ]] && branch_word="branches"
    printf "\n" >&2
    warning "Failed to delete $failed_count $branch_word:"
    for branch in "${failed_branches[@]}"; do
      printf "  ✗ %s (not fully merged - use --force to delete anyway)\n" "$branch" >&2
    done
    
    if [[ $deleted_count -eq 0 ]]; then
      exit 1
    fi
  fi
}

hug_bdel "${branches_to_delete[@]}"
