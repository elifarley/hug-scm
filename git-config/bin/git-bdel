#!/usr/bin/env bash
# Assume HUG_HOME is set (exported by hug or environment)
# shellcheck source=git-config/lib/hug-common
. "$HUG_HOME/git-config/lib/hug-common"
# shellcheck source=git-config/lib/hug-git-kit
. "$HUG_HOME/git-config/lib/hug-git-kit"
set -euo pipefail  # Exit on error, undefined vars, pipe failures
# Part of the Hug tool suite

show_help() {
    cat << EOF
hug bdel: Delete one or more local branches safely

USAGE:
    hug bdel [<branch>...] [--dry-run] [-f, --force] [-q, --quiet] [-h, --help]

ARGUMENTS:
    <branch>...        One or more branch names to delete
                       If not provided, shows interactive list for selection

OPTIONS:
    --dry-run          Preview the delete operation without applying changes
    -f, --force        Skip confirmation prompts and force delete unmerged branches
    -q, --quiet        Suppress output (sets HUG_QUIET=T)
    -h, --help         Show this help

DESCRIPTION:
    Safely deletes one or more local branches. By default, only merged branches
    can be deleted. Use --force to delete unmerged branches.

    When no branch names are provided, displays an interactive menu using gum filter
    (if installed) for multi-selection. This makes it easy to select multiple
    branches to delete at once.

    Backup branches (hug-backups/**) are not shown in the list. Use 'hug bdel-backup'
    to manage backup branches.

    Before deletion, a confirmation prompt shows the count and names of selected
    branches. Use --force to skip confirmation.

EXAMPLES:
    hug bdel                              # Interactive: select branches to delete
    hug bdel feature/old                  # Delete single branch
    hug bdel feat-1 feat-2 feat-3        # Delete multiple branches
    hug bdel --dry-run                    # Preview which branches would be deleted
    hug bdel feature/old --force          # Force delete even if unmerged

SEE ALSO:
    hug bdel-backup    Delete backup branches with filtering options
    hug bl             List local branches
    hug brestore       Restore a branch from backup
EOF
}

# Parse common flags (--dry-run, -f|--force, -q|--quiet, -h|--help)
eval "$(parse_common_flags "$@")"

# Collect branch names
branches_to_delete=()
while [[ $# -gt 0 ]]; do
  case "$1" in
    -*)
      error "Unknown option: $1. See 'hug bdel --help'."
      ;;
    *)
      branches_to_delete+=("$1")
      shift
      ;;
  esac
done

check_git_repo

# Get current branch name to prevent deletion
current_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "")

# --- Main function for 'hug bdel' ---
hug_bdel() {
  local -a branches_to_delete=("$@")
  local -a formatted_to_delete=()
  
  # If no branches specified, show interactive menu
  if [[ ${#branches_to_delete[@]} -eq 0 ]]; then
    local -a all_branches=()
    
    # Get all local branches except backup branches and current branch
    mapfile -t all_branches < <(
      git for-each-ref --format='%(refname:short)' refs/heads/ |
      grep -v '^hug-backups/' |
      grep -v "^${current_branch}$" || true
    )
    
    if [[ ${#all_branches[@]} -eq 0 ]]; then
      if [[ -n "$current_branch" && "$current_branch" != "HEAD" ]]; then
        info "No other branches to delete (only current branch '$current_branch' exists)."
      else
        info "No branches to delete."
      fi
      exit 0
    fi
    
    # Check if gum is available
    if ! gum_available; then
      error "Interactive mode requires 'gum' to be installed. Please install it or specify branch names directly.
       Install: https://github.com/charmbracelet/gum"
    fi
    
    # Prepare formatted options for gum with branch details
    local -a formatted_options=()
    
    for branch in "${all_branches[@]}"; do
      local hash
      hash=$(git rev-parse --short "$branch" 2>/dev/null || echo "???????")
      local subject
      subject=$(git log -1 --format='%s' "$branch" 2>/dev/null || echo "(no commit)")
      
      # Format for gum: plain text with details
      local formatted="${branch} ${YELLOW}${hash}${NC} ${GREY}${subject}${NC}"
      formatted_options+=("$formatted")
    done
    
    # Use gum_filter_by_index for selection with exact matching
    local -a selected_indices=()
    mapfile -t selected_indices < <(
      gum_filter_by_index formatted_options \
                          "Select branches to delete (<TAB> to select, Enter to confirm)..." \
                          --no-limit
    )
    
    if [ ${#selected_indices[@]} -eq 0 ]; then
      info "No branches selected."
      exit 0
    fi
    
    # Extract selected branches and formatted lines using indices
    branches_to_delete=()
    for idx in "${selected_indices[@]}"; do
      local branch="${all_branches[$idx]}"
      branches_to_delete+=("$branch")
      formatted_to_delete+=("${formatted_options[$idx]}")
    done
  fi
  
  # Validate that none of the branches is the current branch
  for branch in "${branches_to_delete[@]}"; do
    if [[ "$branch" == "$current_branch" ]]; then
      error "Cannot delete current branch '$current_branch'. Switch to another branch first."
    fi
    
    # Validate that branch exists
    if ! git rev-parse --verify "$branch" >/dev/null 2>&1; then
      error "Branch '$branch' does not exist."
    fi
  done
  
  # Set dry_run default if not already set by parse_common_flags
  local dry_run="${dry_run:-false}"
  
  # Preview mode
  if [[ "${dry_run}" == "true" ]]; then
    info "Dry run: Would delete ${#branches_to_delete[@]} branch(es):"
    if [[ ${#formatted_to_delete[@]} -gt 0 ]]; then
      for formatted in "${formatted_to_delete[@]}"; do
        printf "  - %s\n" "$formatted" >&2
      done
    else
      # Fallback for CLI args (no formatted)
      for branch in "${branches_to_delete[@]}"; do
        local hash
        hash=$(git rev-parse --short "$branch" 2>/dev/null || echo "???????")
        printf "  - %s (%s)\n" "$branch" "$hash" >&2
      done
    fi
    print_dry_run_preview "delete the listed branches"
    return 0
  fi
  
  # Confirmation prompt (unless --force)
  if [[ ${HUG_FORCE:-} != true ]]; then
    local count=${#branches_to_delete[@]}
    local branch_word="branch"
    [[ $count -gt 1 ]] && branch_word="branches"
    
    warning "About to delete $count $branch_word:"
    if [[ ${#formatted_to_delete[@]} -gt 0 ]]; then
      for formatted in "${formatted_to_delete[@]}"; do
        printf "  - %s\n" "$formatted" >&2
      done
    else
      # Fallback for CLI args (no formatted)
      for branch in "${branches_to_delete[@]}"; do
        local hash
        hash=$(git rev-parse --short "$branch" 2>/dev/null || echo "???????")
        printf "  - %s (%s)\n" "$branch" "$hash" >&2
      done
    fi
    printf "\n" >&2
    prompt_confirm "⚠️  Delete these ${branch_word}? [y/N]: "
  fi
  
  # Perform deletion
  local deleted_count=0
  local failed_count=0
  local -a deleted_branches=()
  local -a failed_branches=()
  
  for branch in "${branches_to_delete[@]}"; do
    # Determine delete flag based on force option
    local delete_flag="-d"  # Safe delete (only merged)
    if [[ ${HUG_FORCE:-} == true ]]; then
      delete_flag="-D"  # Force delete (even unmerged)
    fi
    
    if git branch "$delete_flag" "$branch" >/dev/null 2>&1; then
      deleted_branches+=("$branch")
      deleted_count=$((deleted_count + 1))
    else
      failed_branches+=("$branch")
      failed_count=$((failed_count + 1))
    fi
  done
  
  # Report results
  if [[ $deleted_count -gt 0 ]]; then
    local branch_word="branch"
    [[ $deleted_count -gt 1 ]] && branch_word="branches"
    success "Deleted $deleted_count $branch_word:"
    if [[ ${#formatted_to_delete[@]} -gt 0 ]]; then
      for i in "${!deleted_branches[@]}"; do
        if [[ "${deleted_branches[$i]}" == "${branches_to_delete[$i]}" ]]; then
          printf "  ✓ %s\n" "${formatted_to_delete[$i]}" >&2
        else
          printf "  ✓ %s\n" "${deleted_branches[$i]}" >&2
        fi
      done
    else
      for branch in "${deleted_branches[@]}"; do
        printf "  ✓ %s\n" "$branch" >&2
      done
    fi
  fi
  
  if [[ $failed_count -gt 0 ]]; then
    local branch_word="branch"
    [[ $failed_count -gt 1 ]] && branch_word="branches"
    printf "\n" >&2
    warning "Failed to delete $failed_count $branch_word:"
    for branch in "${failed_branches[@]}"; do
      printf "  ✗ %s (not fully merged - use --force to delete anyway)\n" "$branch" >&2
    done
    
    if [[ $deleted_count -eq 0 ]]; then
      exit 1
    fi
  fi
}

hug_bdel "${branches_to_delete[@]}"
