#!/usr/bin/env bash
CMD_BASE="$(readlink -f "$0" 2> /dev/null || greadlink -f "$0")" || CMD_BASE="$0"
CMD_BASE="$(dirname "$CMD_BASE")"
. "$CMD_BASE/../lib/hug-common"
. "$CMD_BASE/../lib/output_json_status_summary"
set -euo pipefail

# TODO

# Parse arguments
json_output=false
test "${1:-}" = '-h' -o "${1:-}" = '--help' && {
  printf 's: Quick summary of working and staged changes\n' >&2
  printf 'Usage: hug s [--json]\n' >&2
  exit 1
}

# Check for --json flag
for arg in "$@"; do
  case "$arg" in
  --json)
    json_output=true
    ;;
  esac
done

# Quick changes summary
if $json_output; then
  output_json_status_summary
  exit 0
fi

# HEAD status line (inspired by hug sl)
hash=$(git rev-parse --short HEAD 2> /dev/null || echo "")
branch=$(git branch --show-current 2> /dev/null || echo "(detached HEAD)")
upstream=$(git rev-parse --abbrev-ref --symbolic-full-name "@{u}" 2> /dev/null || echo "")
if [ -n "$upstream" ]; then
  status="${branch}...${upstream}"
  counts=$(git rev-list --left-right --count HEAD...@{u} 2> /dev/null || echo "0	0")
  left_count=$(echo "$counts" | cut -f1)
  right_count=$(echo "$counts" | cut -f2)
  indicators=""
  if [ "$left_count" != "0" ] || [ "$right_count" != "0" ]; then
    ahead_part=""
    behind_part=""
    [ "$left_count" != "0" ] && ahead_part="ahead ${GREEN}${left_count}${NC}"
    [ "$right_count" != "0" ] && behind_part="behind ${RED}${right_count}${NC}"
    sep=""
    [ -n "$ahead_part" ] && [ -n "$behind_part" ] && sep=", "
    indicators="[${ahead_part}${sep}${behind_part}]"
    status="${status} ${indicators}"
  fi
  local_part="${GREEN}${branch}${NC}"
  upstream_part="${RED}${upstream}${NC}"
  status_colored="${local_part}...${upstream_part}"
  if [ -n "$indicators" ]; then
    status_colored="${status_colored} ${indicators}"
  fi
else
  status="$branch"
  status_colored="${GREEN}${status}${NC}"
fi
hash_colored="${YELLOW}${hash}${NC}"

unstaged_files=0 unstaged_insertions=0 unstaged_deletions=0
staged_files=0 staged_insertions=0 staged_deletions=0
if ! git diff --quiet; then
  unstaged_files=$(git diff --name-only | wc -l)
  unstaged_insertions=$(git diff --numstat | awk '{sum += $1} END {print sum}')
  unstaged_deletions=$(git diff --numstat | awk '{sum += $2} END {print sum}')
fi

if ! git diff --quiet --cached; then
  staged_files=$(git diff --cached --name-only | wc -l)
  staged_insertions=$(git diff --cached --numstat | awk '{sum += $1} END {print sum}')
  staged_deletions=$(git diff --cached --numstat | awk '{sum += $2} END {print sum}')
fi

untracked_count=$(git ls-files --others --exclude-standard | wc -l)
ignored_count=$(git ls-files --others --exclude-standard --ignored | wc -l)

# Determine ball emoji color based on precedence:
# Regardless of untracked and ignored:
# - ðŸŸ¡ Yellow: both staged and unstaged files
# - ðŸ”´ Red: unstaged files only
# - ðŸŸ¢ Green: staged files only
# Regardless of ignored:
# - ðŸŸ£ Magenta: untracked files only
# Other colors:
# - âš« Black: ignored files only
# - âšª White: clean repo
if [ "$unstaged_files" -gt 0 ] && [ "$staged_files" -eq 0 ]; then
  head_color="${RED}"
  ball_emoji="ðŸ”´"
elif [ "$staged_files" -gt 0 ] && [ "$unstaged_files" -eq 0 ]; then
  head_color="${GREEN}"
  ball_emoji="ðŸŸ¢"
elif [ "$unstaged_files" -gt 0 ] && [ "$staged_files" -gt 0 ]; then
  head_color="${YELLOW}"
  ball_emoji="ðŸŸ¡"
elif [ "$untracked_count" -gt 0 ]; then
  head_color="${MAGENTA}"
  ball_emoji="ðŸŸ£"
elif [ "$ignored_count" -gt 0 ]; then
  head_color="${GREY}"
  ball_emoji="âš«"
else
  head_color=""
  ball_emoji="âšª"
fi
head_colored="${head_color}HEAD${NC}"
head_emoji="${ball_emoji} ${head_colored}:"

# Helper function to format a section consistently
# Usage: format_section <emoji> <label> <color> <file_count> <insertions> <deletions>
format_section() {
  local emoji="$1"
  local label="$2"
  local color="$3"
  local files="$4"
  local insertions="$5"
  local deletions="$6"

  if [[ $files -eq 0 ]]; then
    echo "${emoji} ${label}: -"
  else
    echo "${color}${emoji} ${label}: ${files} files, +${insertions}/-${deletions} lines${NC}"
  fi
}

# Build output components
unstaged_output=""
staged_output=""

unstaged_output=$(format_section "ðŸ“" "Unstaged" "${RED}" "$unstaged_files" "$unstaged_insertions" "$unstaged_deletions")
staged_output=$(format_section "ðŸ“¦" "Staged" "${GREEN}" "$staged_files" "$staged_insertions" "$staged_deletions")

uncommitted_output=''
# If no uncommitted changes at all, don't show uncommitted output
((staged_files + unstaged_files)) && uncommitted_output=" â”‚ $staged_output â”‚ $unstaged_output"

non_tracked_output=''
((untracked_count + ignored_count)) && non_tracked_output=" â”‚ ${MAGENTA}K:${untracked_count}$NC ${GREY}I:${ignored_count}$NC"

# Combine and print full status line
printf '%s %s ðŸŒ¿%s%s%s\n' "$head_emoji" "$hash_colored" "$status_colored" "$uncommitted_output" "$non_tracked_output" >&2
