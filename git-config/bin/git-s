#!/usr/bin/env bash
CMD_BASE="$(readlink -f "$0" 2>/dev/null || greadlink -f "$0")" || CMD_BASE="$0"; CMD_BASE="$(dirname "$CMD_BASE")"
. "$CMD_BASE/../lib/hug-common"
set -euo pipefail

# TODO if no uncommitted changes:
#   - Show Black circle if no untracked AND no ignored files (currently it does show regardless of this)
#   - Show White circle if only ignored files
#   - Show orange circle if only untracked
#   - Show purple circle if both untracked and ignored

# Quick changes summary
test "${1:-}" = '-h' -o "${1:-}" = '--help' && {
  printf 's: Quick summary of working and staged changes\n' >&2
  printf 'Usage: hug s\n' >&2
  exit 1
}

# HEAD status line (inspired by hug sl)
hash=$(git rev-parse --short HEAD)
branch=$(git branch --show-current 2>/dev/null || echo "(detached HEAD)")
upstream=$(git rev-parse --abbrev-ref --symbolic-full-name "@{u}" 2>/dev/null || echo "")
if [ -n "$upstream" ]; then
  status="${branch}...${upstream}"
  counts=$(git rev-list --left-right --count HEAD...@{u} 2>/dev/null || echo "0	0")
  left_count=$(echo "$counts" | cut -f1)
  right_count=$(echo "$counts" | cut -f2)
  indicators=""
  if [ "$left_count" != "0" ] || [ "$right_count" != "0" ]; then
    ahead_part=""
    behind_part=""
    [ "$left_count" != "0" ] && ahead_part="ahead ${GREEN}${left_count}${NC}"
    [ "$right_count" != "0" ] && behind_part="behind ${RED}${right_count}${NC}"
    sep=""
    [ -n "$ahead_part" ] && [ -n "$behind_part" ] && sep=", "
    indicators="[${ahead_part}${sep}${behind_part}]"
    status="${status} ${indicators}"
  fi
  local_part="${GREEN}${branch}${NC}"
  upstream_part="${RED}${upstream}${NC}"
  status_colored="${local_part}...${upstream_part}"
  if [ -n "$indicators" ]; then
    status_colored="${status_colored} ${indicators}"
  fi
else
  status="$branch"
  status_colored="${GREEN}${status}${NC}"
fi
hash_colored="${YELLOW}${hash}${NC}"

unstaged_files=0 unstaged_insertions=0 unstaged_deletions=0
staged_files=0 staged_insertions=0 staged_deletions=0
if ! git diff --quiet; then
  unstaged_files=$(git diff --name-only | wc -l)
  unstaged_insertions=$(git diff --numstat | awk '{sum += $1} END {print sum}')
  unstaged_deletions=$(git diff --numstat | awk '{sum += $2} END {print sum}')
fi

if ! git diff --quiet --cached; then
  staged_files=$(git diff --cached --name-only | wc -l)
  staged_insertions=$(git diff --cached --numstat | awk '{sum += $1} END {print sum}')
  staged_deletions=$(git diff --cached --numstat | awk '{sum += $2} END {print sum}')
fi

# Determine HEAD color and ball emoji based on changes
if [ "$unstaged_files" -gt 0 ] && [ "$staged_files" -eq 0 ]; then
  head_color="${RED}"
  ball_emoji="🔴"
elif [ "$staged_files" -gt 0 ] && [ "$unstaged_files" -eq 0 ]; then
  head_color="${GREEN}"
  ball_emoji="🟢"
elif [ "$unstaged_files" -gt 0 ] && [ "$staged_files" -gt 0 ]; then
  head_color="${YELLOW}"
  ball_emoji="🟡"
else
  head_color=""
  ball_emoji="⚫"
fi
head_colored="${head_color}HEAD${NC}"
head_emoji="${ball_emoji} ${head_colored}:"

# Build output components
unstaged_output=""
staged_output=""

if [[ $unstaged_files -eq 0 ]]; then
  unstaged_output="📝 - (Unstaged)"
else
  unstaged_output="${RED}📝 $unstaged_files files, +$unstaged_insertions/-$unstaged_deletions lines (Unstaged)${NC}"
fi

if [[ $staged_files -eq 0 ]]; then
  staged_output="📦 - (Staged)"
else
  staged_output="${GREEN}📦 $staged_files files, +$staged_insertions/-$staged_deletions lines (Staged)${NC}"
fi

uncommitted_output=''
# If no uncommitted changes at all, don't show uncommitted output
(( staged_files + unstaged_files )) && uncommitted_output=" │ $unstaged_output │ $staged_output"

untracked_count=$(git ls-files --others --exclude-standard | wc -l)
ignored_count=$(  git ls-files --others --exclude-standard --ignored | wc -l)
non_tracked_output=''
(( untracked_count + ignored_count )) && non_tracked_output=" │ ${MAGENTA}U$untracked_count$NC ${GREY}I$ignored_count$NC"

# Combine and print full status line
printf '%s %s 🌿%s%s%s\n' "$head_emoji" "$hash_colored" "$status_colored" "$uncommitted_output" "$non_tracked_output" >&2
