#!/usr/bin/env bash
CMD_BASE="$(readlink -f "$0" 2>/dev/null || greadlink -f "$0")" || CMD_BASE="$0"; CMD_BASE="$(dirname "$CMD_BASE")"
for f in hug-common hug-git-kit; do . "$CMD_BASE/../lib/$f"; done # Load common constants and functions
set -euo pipefail  # Exit on error, undefined vars, pipe failures

# Part of the Hug tool suite

show_help() {
  cat <<'EOF'
Usage: hug w discard [OPTIONS] <path> [<path>...]

Discard tracked changes for the given paths.

Options:
  -u, --unstaged   Discard unstaged changes only (default when no flags provided)
  -s, --staged     Discard staged changes only (unstaged changes are preserved)
      --dry-run    Show what would be discarded without applying changes
  -f, --force      Skip confirmation prompt
  -h, --help       Show this help

Notes:
  • Requires at least one path argument.
  • Use `hug w discard-all` for repository-wide scope.
  • When discarding staged changes, any unstaged changes in those files are preserved (WD = committed + unstaged).
  • When discarding both, all uncommitted changes are discarded (WD and index = committed).
See also:
  • `w wipe` (to discard both staged and unstaged uncommitted changes)
EOF
}

dry_run=false
target_unstaged=false
target_staged=false
flags_explicit=false
force=false

while [[ $# -gt 0 ]]; do
  case "$1" in
    -u|--unstaged)
      target_unstaged=true
      flags_explicit=true
      shift
      ;;
    -s|--staged)
      target_staged=true
      flags_explicit=true
      shift
      ;;
    --dry-run)
      dry_run=true
      shift
      ;;
    -f|--force)
      force=true
      shift
      ;;
    -h|--help)
      show_help
      exit 0
      ;;
    --)
      shift
      break
      ;;
    -*)
      error "unknown option: $1"
      show_help >&2
      exit 2
      ;;
    *)
      break
      ;;
  esac
done

if ! $flags_explicit; then
  target_unstaged=true
fi

if [[ $# -lt 1 ]]; then
  error "this command requires at least one path (or use 'git w discard-all')"
  show_help >&2
  exit 2
fi

check_git_repo
repo_root="$(git rev-parse --show-toplevel)"

paths=("$@")

declare -a unstaged_paths=()
declare -a staged_paths=()

if $target_unstaged; then
  mapfile -t unstaged_paths < <(git diff --name-only -- "${paths[@]}" 2>/dev/null || true)
  dedupe_array unstaged_paths
fi

if $target_staged; then
  mapfile -t staged_paths < <(git diff --cached --name-only -- "${paths[@]}" 2>/dev/null || true)
  dedupe_array staged_paths
fi

if [[ ${#unstaged_paths[@]} -eq 0 && ${#staged_paths[@]} -eq 0 ]]; then
  print_nothing_to_do "discard" "for the specified paths."
  exit 0
fi

# Main orchestrator for staged-only mode: Loops over files, checks flags, delegates to sub-functions
handle_staged_only() {
  local repo_root="$1"  # First arg: repo_root (passed explicitly)
  shift  # Consume root, leaving paths as remaining args

  local -a staged_paths=("$@")  # Now captures only the expanded paths array

  for file in "${staged_paths[@]}"; do
    local has_unstaged_flag=false
    # Direct access to global has_unstaged assoc array (no nameref needed)
    if [[ -n "${has_unstaged[$file]+set}" ]]; then
      has_unstaged_flag=true
    fi

    # Early errors for unsafe cases
    if $has_unstaged_flag && is_binary_staged "$file"; then
      error "Cannot safely discard staged changes for binary path '$file' while preserving unstaged changes. Please stash or commit the unstaged content first."
    fi

    local local_file="$repo_root/$file"
    if $has_unstaged_flag && is_symlink "$local_file"; then
      error "Cannot safely discard staged changes for symbolic link '$file' while preserving unstaged changes. Please stash or commit the unstaged content first."
    fi

    # Delegate based on unstaged flag (simple case first)
    if ! $has_unstaged_flag; then
      # Simple case: No unstaged changes - direct discard
      discard_staged_no_unstaged "$file"
      continue
    fi

    # Complex case: Has unstaged changes - handle patch reversal (or merge-file from previous fix)
    local failed_patch=""  # Temp for failure output (scoped to complex path)
    if ! discard_staged_with_unstaged "$file" "$repo_root" failed_patch; then
      exit 1  # Propagate failure (prints already done in sub-function)
    fi
  done
}

# For staged-only mode, prepare a map of files with unstaged changes (compute if needed)
declare -A has_unstaged
if $target_staged && ! $target_unstaged && [[ $dry_run == false ]]; then
  mapfile -t temp_unstaged_paths < <(git diff --name-only -- "${paths[@]}" 2>/dev/null || true)
  dedupe_array temp_unstaged_paths
  for file in "${temp_unstaged_paths[@]}"; do
    has_unstaged["$file"]=true
  done
fi

if $dry_run; then
  print_dry_run_preview "be discarded" "from the specified paths."
  printf '\n'
  if [[ ${#staged_paths[@]} -gt 0 ]]; then
    if $target_staged && ! $target_unstaged; then
      printf '  Staged paths (unstaged changes in these files would be preserved):\n'
    else
      printf '  Staged paths:\n'
    fi
    print_list '    ' "${staged_paths[@]}"
  fi
  if [[ ${#unstaged_paths[@]} -gt 0 ]]; then
    printf '  Unstaged paths:\n'
    print_list '    ' "${unstaged_paths[@]}"
  fi
  if $target_staged && $target_unstaged; then
    printf '  (Both staged and unstaged would be fully discarded for affected paths)\n'
  fi
  exit 0
fi

if ! $force; then
  print_action_preview "discard the listed changes" "from the specified paths."
  printf '\n'
  if [[ ${#staged_paths[@]} -gt 0 ]]; then
    if $target_staged && ! $target_unstaged; then
      printf '  Staged paths (unstaged changes in these files would be preserved):\n'
    else
      printf '  Staged paths:\n'
    fi
    print_list '    ' "${staged_paths[@]}"
  fi
  if [[ ${#unstaged_paths[@]} -gt 0 ]]; then
    printf '  Unstaged paths:\n'
    print_list '    ' "${unstaged_paths[@]}"
  fi
  if $target_staged && $target_unstaged; then
    printf '  (Both staged and unstaged would be fully discarded for affected paths)\n'
  fi
  confirm_action 'discard'
fi

# Handle both targets: Simple full discard to HEAD for union of affected paths
if $target_staged && $target_unstaged; then
  declare -a affected_paths=("${unstaged_paths[@]}")
  for path in "${staged_paths[@]}"; do
    affected_paths+=("$path")
  done
  dedupe_array affected_paths

  # Optional: Pass --dry-run if global $dry_run is true
  dry_arg=""
  [[ $dry_run == true ]] && dry_arg="--dry-run"

  discard_uncommitted_changes affected_paths "$dry_arg"
  exit 0

fi

# Handle unstaged only: Restore WD to index (preserves staged)
if $target_unstaged && ! $target_staged; then
  discard_unstaged unstaged_paths # Pass the array name; function handles the rest
  exit 0
fi

# Handle staged only: remove staged delta while preserving unstaged edits
if $target_staged && ! $target_unstaged; then
  handle_staged_only "$repo_root" "${staged_paths[@]}"
  exit 0
fi
