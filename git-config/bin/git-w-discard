#!/usr/bin/env bash
CMD_BASE="$(readlink -f "$0" 2>/dev/null || greadlink -f "$0")" || CMD_BASE="$0"; CMD_BASE="$(dirname "$CMD_BASE")"
for f in hug-common hug-git-kit; do . "$CMD_BASE/../lib/$f"; done # Load common constants and functions
set -euo pipefail  # Exit on error, undefined vars, pipe failures

# Part of the Hug tool suite

show_help() {
  cat <<'EOF'
Usage: hug w discard [OPTIONS] [<path>...]

Discard tracked changes for the given paths.

Options:
  -u, --unstaged     Discard unstaged changes only (default when no flags provided)
  -s, --staged       Discard staged changes only (unstaged changes are preserved)
      --browse-root  Browse full repository scope in file selector UI (default: current directory)
      --dry-run      Show what would be discarded without applying changes
  -f, --force        Skip confirmation prompt
  -h, --help         Show this help

Behavior:
  • When run with no paths, shows an interactive file selection UI (requires gum).
  • By default, file selection is scoped to the current directory and subdirectories.
  • Use --browse-root to browse files across the entire repository in the UI.
  • When explicit paths are provided, they are interpreted relative to the current directory.
  • Use `hug w discard-all` for repository-wide discard without interactive selection.

Notes:
  • When discarding staged changes, any unstaged changes in those files are preserved (WD = committed + unstaged).
  • When discarding both, all uncommitted changes are discarded (WD and index = committed).

Examples:
  hug w discard                    # Interactive UI, current directory scope
  hug w discard --browse-root      # Interactive UI, full repository scope
  hug w discard file.txt           # Discard changes to file.txt (CWD-relative)
  hug w discard src/main.js        # Discard changes to src/main.js (CWD-relative)

See also:
  • `w wipe` (to discard both staged and unstaged uncommitted changes)
  • `w discard-all` (to discard across entire repository without UI)
EOF
}

# Initialize custom flag variables
target_unstaged=false
target_staged=false
flags_explicit=false

# Parse custom flags first (non-common flags)
while [[ $# -gt 0 ]]; do
  case "$1" in
    -u|--unstaged)
      target_unstaged=true
      flags_explicit=true
      shift
      ;;
    -s|--staged)
      target_staged=true
      flags_explicit=true
      shift
      ;;
    *)
      break
      ;;
  esac
done

# Parse common flags (--browse-root, --dry-run, -f|--force, -h|--help, --)
eval "$(parse_common_flags "$@")"

# Initialize common flag variables if not set by parse_common_flags
: "${browse_root:=false}"
: "${dry_run:=false}"
: "${force:=false}"

if ! $flags_explicit; then
  target_unstaged=true
fi

check_git_repo
repo_root="$(git rev-parse --show-toplevel)"

# Handle interactive file selection when no paths provided
if [[ $# -lt 1 ]]; then
  # Check for conflicting flags
  if $browse_root; then
    # --browse-root without explicit paths is valid (triggers UI with full scope)
    :
  fi
  
  # Determine which file types to show based on flags
  declare -a select_opts=("--multi")
  
  # Default to --cwd (current directory scope) unless --browse-root is specified
  if ! $browse_root; then
    select_opts+=("--cwd")
  fi
  
  if $target_staged && ! $target_unstaged; then
    select_opts+=("--staged")
    select_opts+=("--prompt" "Select staged files to discard...")
  elif $target_unstaged && ! $target_staged; then
    select_opts+=("--unstaged")
    select_opts+=("--prompt" "Select unstaged files to discard...")
  else
    # Both or default (unstaged)
    select_opts+=("--staged" "--unstaged")
    select_opts+=("--prompt" "Select files to discard...")
  fi
  
  paths=()
  if ! mapfile -t paths < <(select_files_with_status "${select_opts[@]}"); then
    info "No files selected or cancelled."
    exit 0
  fi
  
  if [[ ${#paths[@]} -eq 0 ]]; then
    info "No files selected."
    exit 0
  fi
else
  # Explicit paths provided - check for conflicting flags
  check_browse_root_no_paths "$browse_root" true
  
  paths=("$@")
fi

declare -a unstaged_paths=()
declare -a staged_paths=()

if $target_unstaged; then
  mapfile -t unstaged_paths < <(git diff --name-only -- "${paths[@]}" 2>/dev/null || true)
  dedupe_array unstaged_paths
fi

if $target_staged; then
  mapfile -t staged_paths < <(git diff --cached --name-only -- "${paths[@]}" 2>/dev/null || true)
  dedupe_array staged_paths
fi

if [[ ${#unstaged_paths[@]} -eq 0 && ${#staged_paths[@]} -eq 0 ]]; then
  print_nothing_to_do "discard" "for the specified paths."
  exit 0
fi

# Main orchestrator for staged-only mode: Loops over files, checks flags, delegates to sub-functions
handle_staged_only() {
  local repo_root="$1"  # First arg: repo_root (passed explicitly)
  shift  # Consume root, leaving paths as remaining args

  local -a staged_paths=("$@")  # Now captures only the expanded paths array

  for file in "${staged_paths[@]}"; do
    local has_unstaged_flag=false
    # Direct access to global has_unstaged assoc array (no nameref needed)
    if [[ -n "${has_unstaged[$file]+set}" ]]; then
      has_unstaged_flag=true
    fi

    # Early errors for unsafe cases
    if $has_unstaged_flag && is_binary_staged "$file"; then
      error "Cannot safely discard staged changes for binary path '$file' while preserving unstaged changes. Please stash or commit the unstaged content first."
    fi

    local local_file="$repo_root/$file"
    if $has_unstaged_flag && is_symlink "$local_file"; then
      error "Cannot safely discard staged changes for symbolic link '$file' while preserving unstaged changes. Please stash or commit the unstaged content first."
    fi

    # Delegate based on unstaged flag (simple case first)
    if ! $has_unstaged_flag; then
      # Simple case: No unstaged changes - direct discard
      discard_staged_no_unstaged "$file"
      continue
    fi

    # Complex case: Has unstaged changes - handle patch reversal (or merge-file from previous fix)
    local failed_patch=""  # Temp for failure output (scoped to complex path)
    if ! discard_staged_with_unstaged "$file" "$repo_root" failed_patch; then
      exit 1  # Propagate failure (prints already done in sub-function)
    fi
  done
}

# For staged-only mode, prepare a map of files with unstaged changes (compute if needed)
declare -A has_unstaged
if $target_staged && ! $target_unstaged && [[ $dry_run == false ]]; then
  mapfile -t temp_unstaged_paths < <(git diff --name-only -- "${paths[@]}" 2>/dev/null || true)
  dedupe_array temp_unstaged_paths
  for file in "${temp_unstaged_paths[@]}"; do
    has_unstaged["$file"]=true
  done
fi

if $dry_run; then
  print_dry_run_preview "be discarded" "from the specified paths."
  printf '\n'
  print_staged_unstaged_paths staged_paths unstaged_paths "$target_staged" "$target_unstaged"
  exit 0
fi

if ! $force; then
  print_action_preview "discard the listed changes" "from the specified paths."
  printf '\n'
  print_staged_unstaged_paths staged_paths unstaged_paths "$target_staged" "$target_unstaged"
  confirm_action_danger 'discard'
fi

# Handle both targets: Simple full discard to HEAD for union of affected paths
if $target_staged && $target_unstaged; then
  declare -a affected_paths=("${unstaged_paths[@]}")
  for path in "${staged_paths[@]}"; do
    affected_paths+=("$path")
  done
  dedupe_array affected_paths

  # Optional: Pass --dry-run if global $dry_run is true
  dry_arg=""
  [[ $dry_run == true ]] && dry_arg="--dry-run"

  discard_uncommitted_changes affected_paths "$dry_arg"
  exit 0

fi

# Handle unstaged only: Restore WD to index (preserves staged)
if $target_unstaged && ! $target_staged; then
  discard_unstaged unstaged_paths # Pass the array name; function handles the rest
  exit 0
fi

# Handle staged only: remove staged delta while preserving unstaged edits
if $target_staged && ! $target_unstaged; then
  handle_staged_only "$repo_root" "${staged_paths[@]}"
  exit 0
fi
