#!/usr/bin/env bash
# Assume HUG_HOME is set (exported by hug or environment)
# shellcheck source=git-config/lib/hug-common
. "$HUG_HOME/git-config/lib/hug-common"
# shellcheck source=git-config/lib/hug-git-kit
. "$HUG_HOME/git-config/lib/hug-git-kit"
# shellcheck source=git-config/lib/hug-file-input
. "$HUG_HOME/git-config/lib/hug-file-input"
# shellcheck source=git-config/lib/hug-select-files
. "$HUG_HOME/git-config/lib/hug-select-files"
set -euo pipefail # Exit on error, undefined vars, pipe failures

# Part of the Hug tool suite

show_help() {
  cat << 'EOF'
hug a: Stage tracked files, or specific files if provided.

USAGE:
  hug a                # Stage all tracked files (updates only)
  hug a .              # Stage current directory
  hug a <file>         # Stage specific files
  hug a --             # Interactive file selection (current directory scope)
  hug a --browse-root  # Interactive file selection (full repository scope)
  hug a --from-file <file>     # Stage files from list file or stdin
  hug a --from-commit <commit> # Stage files changed in specified commit

OPTIONS:
  --             Trigger interactive file selection UI
  --browse-root  Browse full repository scope in file selector UI (default: current directory)
  --from-file <file>    Read file list from file or stdin (use '-' for stdin)
  --from-commit <commit> Use files changed in the specified commit
  -h, --help     Show this help message and exit.

DESCRIPTION:
  Stage tracked files for commit. When no arguments are provided, stages all
  tracked files that have been modified. Use '--' to interactively select
  files to stage. By default, interactive selection is scoped to the current
  directory and subdirectories. Use --browse-root to browse the entire repository.

  The --from-file flag reads file names from a file or stdin. It intelligently
  parses both simple file lists (one per line) and the output from 'hug sh'.

  The --from-commit flag directly extracts files from a commit's changes,
  providing an optimized workflow for staging the same files as a previous commit.

EXAMPLES:
  hug a --from-file files.txt          # Stage files from list
  hug a --from-commit HEAD~1           # Stage files from previous commit
  hug sh HEAD~2 | hug a --from-file -   # Stage files from hug sh output

SEE ALSO:
  hug aa: Stage everything (tracked + untracked + deletions)
  hug ai: Invoke interactive add menu
  hug ap: Add patches interactively (no commit)
EOF
}

# Parse custom flags (excluding -- which will be handled by parse_common_flags)
from_file=""
from_commit=""
remaining_args=()

while [[ $# -gt 0 ]]; do
  case "$1" in
  --from-file)
    from_file="$2"
    shift 2
    ;;
  --from-commit)
    from_commit="$2"
    shift 2
    ;;
  -h | --help)
    show_help
    exit 0
    ;;
  --)
    # Don't process -- here, let parse_common_flags handle it
    break
    ;;
  *)
    remaining_args+=("$1")
    shift
    ;;
  esac
done

# Parse common flags (handles --, --browse-root, etc.)
eval "$(parse_common_flags "$@")"

# Initialize common flag variables if not set by parse_common_flags
: "${browse_root:=false}"

# Early exit if not in Git repo
check_git_repo

# Handle file input flags
if [[ -n "$from_file" || -n "$from_commit" ]]; then
  files=()
  files_from_source=()

  if [[ -n "$from_commit" ]]; then
    mapfile -t files_from_source < <(extract_files_from_commit "$from_commit")
  elif [[ -n "$from_file" ]]; then
    mapfile -t files_from_source < <(read_files_from_source "$from_file")
  fi

  # Add any remaining arguments
  files+=("${files_from_source[@]}" "${remaining_args[@]}")

  if [[ ${#files[@]} -eq 0 ]]; then
    info "No files to stage."
    exit 0
  fi

  exec git add "${files[@]}"
fi

# Handle interactive file selection if requested
if [[ "${HUG_INTERACTIVE_FILE_SELECTION:-}" = "true" ]]; then
  # Get list of files with changes (including untracked files)
  declare -a select_opts=("--multi" "--unstaged" "--untracked")

  # Default to --cwd (current directory scope) unless --browse-root is specified
  if ! $browse_root; then
    select_opts+=("--cwd")
  fi

  select_opts+=("--prompt" "Select files to stage...")

  files=()
  if ! mapfile -t files < <(select_files_with_status "${select_opts[@]}"); then
    info "No files selected or cancelled."
    exit 0
  fi

  if [ ${#files[@]} -eq 0 ]; then
    info "No files selected."
    exit 0
  fi

  exec git add "${files[@]}"
fi

# Check if no arguments - stage all tracked modified files
test ${#remaining_args[@]} -eq 0 && exec git add -u

exec git add "${remaining_args[@]}"
