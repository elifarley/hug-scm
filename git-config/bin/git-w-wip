#!/usr/bin/env bash
CMD_BASE="$(readlink -f "$0" 2>/dev/null || greadlink -f "$0")" || CMD_BASE="$0"; CMD_BASE="$(dirname "$CMD_BASE")"
for f in hug-common hug-git-kit; do . "$CMD_BASE/../lib/$f"; done
set -euo pipefail

# Part of the Hug tool suite

PROG_NAME="hug w wip"

show_help() {
  cat <<'EOF'
hug w wip: Park all uncommitted changes (tracked and untracked) on a new, separate WIP branch.
Use WIP branches as pushable work-in-progress snapshots.

USAGE:
  hug w wip [OPTIONS] "<message>"

OPTIONS:
  --stay           Check out the new WIP branch so that you can stay on the same task, but separate from the original branch.
  -h, --help       Show this help message and exit.

DESCRIPTION:
  Collects staged, unstaged, and untracked changes; creates a WIP commit on
  a new `WIP/YY-MM-DD/HHmm.slug` branch;

  WITH    `--stay`:
     The new WIP branch is checked out so that you can *stay* on the same task.
     Good for immersive sessions.
  WITHOUT `--stay`
     Your changes are moved out of your way and
     your working directory is clean for new, unrelated tasks.
     Good for interruptions (e.g., switch to hotfix, resume later).

EXAMPLES:
  hug w wip "Draft responsive navbar"
  hug w wip --stay "Spike auth refactor"

TIPS:
  - Resume later with: hug b WIP/YY-MM-DD/HHmm.slug
  - Clean up when finished: hug w unwip WIP/YY-MM-DD/HHmm.slug
EOF
}

usage_error() {
  printf '%s: %s\n\n' "$PROG_NAME" "$1" >&2
  show_help >&2
  exit 1
}

generate_branch_name() {
  local message="$1"
  local slug
  slug="$(printf '%s' "$message" | tr '[:upper:]' '[:lower:]' | tr -d '[:space:][:punct:]')"
  slug="${slug:0:24}"
  if [ -z "$slug" ]; then
    slug="work"
  fi
  local date_part="$(date +%y-%m-%d)"
  local time_part="$(date +%H%M)"
  printf 'WIP/%s/%s.%s\n' "$date_part" "$time_part" "$slug"
}

stay_on_wip=false
declare -a message_parts=()

while (($#)); do
  case "$1" in
    -h|--help)
      show_help
      exit 0
      ;;
    --stay)
      stay_on_wip=true
      ;;
    --)
      shift
      while (($#)); do
        message_parts+=("$1")
        shift
      done
      break
      ;;
    -*)
      usage_error "Unknown option '$1'."
      ;;
    *)
      message_parts+=("$1")
      ;;
  esac
  shift || break
done

if ((${#message_parts[@]} == 0)); then
  usage_error "Missing message. Provide a description of your work-in-progress."
fi

message="$(trim_message "${message_parts[*]}")"
if [ -z "$message" ]; then
  usage_error "Message must contain non-whitespace characters."
fi

check_git_repo

if ! has_pending_changes; then
  printf '%s: No changes detected. Run "hug sl" to confirm the working tree state.\n' "$PROG_NAME" >&2
  exit 0
fi

previous_branch="$(git branch --show-current)"
if [ -z "$previous_branch" ]; then
  error "$PROG_NAME: Cannot determine the current branch (detached HEAD?)."
fi

branch_name="$(generate_branch_name "$message")"
if git rev-parse --verify --quiet "refs/heads/$branch_name"; then
  error "$PROG_NAME: Branch '$branch_name' already exists. Try a different message."
fi

git switch -c "$branch_name" >/dev/null

cleanup() {
  git switch "$previous_branch" >/dev/null 2>&1 || true
}

if [ "$stay_on_wip" = false ]; then
  trap cleanup EXIT
fi

git add -A

if git diff --cached --quiet; then
  trap - EXIT
  cleanup
  git branch -D "$branch_name" >/dev/null 2>&1 || true
  error "$PROG_NAME: Nothing to commit after staging. Check .gitignore or file filters."
fi

git commit --quiet -m "[WIP] $message"
wip_commit="$(git rev-parse --short HEAD)"

if [ "$stay_on_wip" = true ]; then
  printf 'WIP saved on %s (commit %s). Stay on this branch to continue.\n' "$branch_name" "$wip_commit"
  printf 'Switch back anytime with: hug b %s\n' "$previous_branch"
else
  git switch "$previous_branch" >/dev/null
  trap - EXIT
  printf 'WIP saved on %s (commit %s). Switched back to %s.\n' "$branch_name" "$wip_commit" "$previous_branch"
  printf 'Resume later with: hug b %s\n' "$branch_name"
fi
