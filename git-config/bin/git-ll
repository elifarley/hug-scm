#!/usr/bin/env bash
CMD_BASE="$(readlink -f "$0" 2>/dev/null || greadlink -f "$0")" || CMD_BASE="$0"; CMD_BASE="$(dirname "$CMD_BASE")"
for f in hug-common hug-git-kit; do . "$CMD_BASE/../lib/$f"; done
set -euo pipefail

show_help() {
  cat << 'EOF'
hug ll: Log commits with detailed formatting (graph, date, author, message).

USAGE:
    hug ll [options] [<revision-range>] [-- <path>]

OPTIONS:
    -<n>           Show last n commits (e.g., -10)
    --all          Show all branches
    --json         Output as JSON (machine-readable)
    --with-stats   Include file change statistics (JSON mode only)
    --no-body      Omit commit message body (JSON mode only)
    -h, --help     Show this help

DESCRIPTION:
    Displays commit log with graph visualization, short hash, date, author,
    and commit message. Default output is human-readable with color formatting.
    Use --json for machine-readable output suitable for automation.

EXAMPLES:
    hug ll                         # Show commits on current branch
    hug ll -10                     # Show last 10 commits
    hug ll --all                   # Show all branches
    hug ll --json                  # Output as JSON
    hug ll --json --with-stats     # JSON with file change stats
    hug ll --json --no-body        # JSON with subject only (faster)
    hug ll --json --with-stats --no-body  # Combined flags
    hug ll main..feature           # Commits in feature not in main

JSON OUTPUT (GitHub-compatible + Hug enhancements):
    {
      "commits": [
        {
          "sha": "full_hash",
          "sha_short": "short_hash",
          "author": {
            "name": "...",
            "email": "...",
            "date": "ISO8601",
            "date_relative": "2 hours ago"
          },
          "committer": {
            "name": "...",
            "email": "...",
            "date": "ISO8601",
            "date_relative": "2 hours ago"
          },
          "message": "subject\n\nbody",
          "subject": "subject line",
          "body": "body text",
          "tree": {"sha": "tree_hash"},
          "parents": [{"sha": "parent_hash"}],
          "refs": ["HEAD", "main"],
          "stats": {"files_changed": 3, "insertions": 10, "deletions": 5}
        }
      ],
      "summary": {
        "total_commits": 5,
        "date_range": {"earliest": "...", "latest": "..."}
      }
    }

SEE ALSO:
    hug l        : Simpler one-line log
    hug la       : Log all branches
    hug lp       : Log with patches
    hug lf       : Search commits by message
EOF
}

# Parse flags
json_output=false
with_stats=false
no_body=false
git_args=()

while [ $# -gt 0 ]; do
  case "$1" in
    -h|--help)
      show_help
      exit 0
      ;;
    --json)
      json_output=true
      shift
      ;;
    --with-stats)
      with_stats=true
      shift
      ;;
    --no-body)
      no_body=true
      shift
      ;;
    --all)
      git_args+=("--all")
      shift
      ;;
    -[0-9]*)
      git_args+=("$1")
      shift
      ;;
    *)
      git_args+=("$1")
      shift
      ;;
  esac
done

check_git_repo

if $json_output; then
  # JSON output mode - use batched operations for performance
  # Load batch JSON utilities for optimized performance
  . "$CMD_BASE/../lib/hug-git-json"

  # Build batch log arguments
  log_args=()
  $with_stats && log_args+=("--numstat")
  $no_body && log_args+=("--no-body")

  # Add git arguments passed from command line
  log_args+=("${git_args[@]}")

  # Determine if we should use streaming mode for large result sets
  local commit_count=""
  if [[ ${#git_args[@]} -gt 0 ]]; then
    # Extract commit limit if provided (e.g., -10, -100)
    for arg in "${git_args[@]}"; do
      if [[ "$arg" =~ ^-[0-9]+$ ]]; then
        commit_count="${arg:1}"
        break
      fi
    done
  fi

  # Use streaming mode for large result sets (>100 commits)
  if [[ -z "$commit_count" ]] || [[ "$commit_count" -gt 100 ]]; then
    # Streaming mode: output NDJSON for memory efficiency
    echo '{"type":"log_start","data":{"format":"ndjson","command":"hug ll"}}'
    batch_log_output --stream --max "${commit_count:-1000}" "${log_args[@]}"
    echo '{"type":"log_end","data":{}}'
  else
    # Normal mode: array of commits for smaller result sets
    local log_results
    log_results=$(batch_log_output --max "${commit_count:-100}" "${log_args[@]}")

    # Wrap with metadata and output
    local data_json="{\"commits\":$log_results}"
    if $with_stats; then
      data_json="${data_json%}},\"with_stats\":true}"
    fi
    if $no_body; then
      data_json="${data_json%}},\"no_body\":true}"
    fi

    output_json_response "hug ll" "$data_json" --with-branch --with-head
  fi

else
  # Human-readable output (fallback to existing alias behavior)
  git log --graph --pretty=log1 --date=short "${git_args[@]}"
fi
