#!/usr/bin/env bash
CMD_BASE="$(readlink -f "$0" 2> /dev/null || greadlink -f "$0")" || CMD_BASE="$0"
CMD_BASE="$(dirname "$CMD_BASE")"
for f in hug-common hug-git-kit hug-git-worktree; do . "$CMD_BASE/../lib/$f"; done # Load common constants and functions
set -euo pipefail                                                                  # Exit on error, undefined vars, pipe failures

# Part of the Hug tool suite

show_help() {
  cat << 'EOF'
hug wt: Git worktree management for parallel development

USAGE:
  hug wt [options] [path|branch]

ARGUMENTS:
    [path|branch]   Path to worktree OR branch name with worktree

OPTIONS:
  -h, --help            Show this help message and exit.
  --summary             Show non-interactive summary of all worktrees.
  --json                Output worktree information in JSON format.

DESCRIPTION:
  Selects a worktree to switch to. This command is used by the 'wt' shell function
  which performs the actual directory change.

  If a worktree path is provided, selects that worktree directly.
  If a branch name is provided, finds and switches to the worktree for that branch.
  If no argument is given, displays an interactive menu of all worktrees.
  Each entry shows: branch name (short commit), status indicators, and path.
  The current worktree is highlighted with [CURRENT] and marked in green.

  Status indicators:
    [CURRENT] - The worktree you're currently in
    [DIRTY]   - Worktree has uncommitted changes
    [LOCKED]  - Worktree is locked (cannot be removed)

  For repositories with 10 or more worktrees, uses gum filter (if installed) for
  easier searching and selection. Otherwise, displays a numbered list.

  Note: This script outputs WORKTREE_PATH:/path/to/worktree for shell integration.
  Use the 'wt' command (shell function) to actually change directories.

EXAMPLES:
  wt                      # Show interactive menu of worktrees and switch to selection
  wt ../feature-auth     # Switch to feature-auth worktree directly
  hug wt                  # Show interactive menu (use 'wt' to actually switch)
  hug wt --json           # Output worktree info in JSON format

SEE ALSO:
  hug wtc    : Create worktree for existing branch
  hug wtdel  : Remove worktree safely

FURTHER READING:
  See 'git worktree --help' for more information about Git worktrees.
EOF
}

# Parse flags
json_output=false
summary_output=false
declare -a args=()

while [[ $# -gt 0 ]]; do
  case "$1" in
  -h | --help)
    show_help
    exit 0
    ;;
  --summary)
    summary_output=true
    shift
    ;;
  --json)
    json_output=true
    shift
    ;;
  -*)
    error "Unknown option: $1"
    show_help
    exit 1
    ;;
  *)
    args+=("$1")
    shift
    ;;
  esac
done

# Early exit if not in Git repo
check_git_repo

# Handle summary output (non-interactive listing)
if "$summary_output"; then
  declare -a worktree_paths=() branches=() commits=() status_dirty=() locked_status=()

  # NOTE: Using get_all_worktrees_including_main to show complete worktree status
  if ! get_all_worktrees_including_main worktree_paths branches commits status_dirty locked_status; then
    info "No worktrees found."
    exit 0
  fi

  current_worktree=$(get_current_worktree_path)
  count=${#worktree_paths[@]}
  # Count of ADDITIONAL worktrees (excluding main)
  additional_count=$((count > 0 ? count - 1 : 0))

  printf "${BLUE}Worktrees (%d)${NC}\n" "$additional_count"
  echo

  for i in "${!worktree_paths[@]}"; do
    path="${worktree_paths[$i]}"
    branch="${branches[$i]}"
    commit="${commits[$i]}"
    dirty="${status_dirty[$i]}"
    locked="${locked_status[$i]}"

    # Build status indicators
    status_indicators=""
    [[ "$path" == "$current_worktree" ]] && status_indicators="${GREEN}[CURRENT]${NC} "
    [[ "$dirty" == "true" ]] && status_indicators="${status_indicators}${YELLOW}[DIRTY]${NC} "
    [[ "$locked" == "true" ]] && status_indicators="${status_indicators}${RED}[LOCKED]${NC} "

    # Format path relative to home if possible
    display_path="${path/#$HOME/\~}"

    # Print worktree line
    printf "  %s%s (%s) → %s\n" "$status_indicators" "$branch" "$commit" "$display_path"
  done

  echo
  exit 0
fi

# Handle JSON output
if "$json_output"; then
  declare -a worktree_paths=() branches=() commits=() status_dirty=() locked_status=()

  # NOTE: Using get_all_worktrees_including_main to allow JSON output for all worktrees
  if ! get_all_worktrees_including_main worktree_paths branches commits status_dirty locked_status; then
    printf '{"worktrees":[],"current":"","count":0}\n'
    exit 0
  fi

  current_worktree=$(get_current_worktree_path)
  count=${#worktree_paths[@]}
  # Count of ADDITIONAL worktrees (excluding main) - matches user mental model
  # 0 = only main, 1 = user created 1 additional worktree
  additional_count=$((count > 0 ? count - 1 : 0))

  printf '{'
  printf '"worktrees":['

  for i in "${!worktree_paths[@]}"; do
    path="${worktree_paths[$i]}"
    branch="${branches[$i]}"
    commit="${commits[$i]}"
    dirty="${status_dirty[$i]}"
    locked="${locked_status[$i]}"
    is_current="false"

    [[ "$path" == "$current_worktree" ]] && is_current="true"

    if [[ $i -gt 0 ]]; then printf ','; fi
    printf '{'
    printf '"path":"%s",' "$path"
    printf '"branch":"%s",' "$branch"
    printf '"commit":"%s",' "$commit"
    printf '"dirty":%s,' "$dirty"
    printf '"locked":%s,' "$locked"
    printf '"current":%s' "$is_current"
    printf '}'
  done

  printf '],'
  printf '"current":"%s",' "$current_worktree"
  printf '"count":%d' "$additional_count"
  printf '}\n'
  exit 0
fi

# Handle case where worktree path or branch name is provided
if [[ ${#args[@]} -gt 0 ]]; then
  input="${args[0]}"
  worktree_path=""

  # First, try to treat as a path (current behavior)
  if [[ -e "$input" ]]; then
    # It's an existing path, use it directly
    worktree_path="$input"
  else
    # Not an existing path, try as branch name
    worktree_path=$(get_worktree_path_by_branch "$input" || true)

    if [[ -z "$worktree_path" ]]; then
      info "Run 'hug wt' to browse and switch between existing worktrees"
      info "Use 'hug wtc $input --new' to create the branch AND the worktree for it"
      error "Cannot switch to worktree: '$input' is not a valid path or branch with worktree"
    fi
  fi

  switch_to_worktree "$worktree_path"
  exit $?
fi

# No path argument provided - show interactive menu
declare -a worktree_paths=() branches=() commits=() status_dirty=() locked_status=()

# NOTE: Using get_worktrees (excludes main) because wt is for SWITCHING between worktrees.
#       If only main worktree exists, there's nothing to switch to.
if ! get_worktrees worktree_paths branches commits status_dirty locked_status; then
  info "No worktrees found. Use 'hug wtc <branch>' to create one."
  info "Example: hug wtc feature-auth"
  exit 0
fi
current_worktree=$(get_current_worktree_path)

# Build menu items with context
declare -a menu_items=()
declare -a worktree_selection_paths=()

for i in "${!worktree_paths[@]}"; do
  path="${worktree_paths[$i]}"
  branch="${branches[$i]}"
  commit="${commits[$i]}"
  dirty="${status_dirty[$i]}"
  locked="${locked_status[$i]}"

  # Build status indicators
  status_indicators=""
  [[ "$path" == "$current_worktree" ]] && status_indicators="${GREEN}[CURRENT]${NC} "
  [[ "$dirty" == "true" ]] && status_indicators="${status_indicators}${YELLOW}[DIRTY]${NC} "
  [[ "$locked" == "true" ]] && status_indicators="${status_indicators}${RED}[LOCKED]${NC} "

  # Format path relative to home if possible
  display_path="${path/#$HOME/\~}"

  # Create menu item
  menu_item="${status_indicators}${branch} (${commit}) → ${display_path}"
  menu_items+=("$menu_item")
  worktree_selection_paths+=("$path")
done

# Interactive selection
echo
printf "${BLUE}Select worktree to switch to:${NC}\n"

selected_index=-1

if [[ ${#menu_items[@]} -lt 10 ]]; then
  # Show numbered menu for fewer worktrees
  echo
  for i in "${!menu_items[@]}"; do
    printf "  %2d) %s\n" $((i + 1)) "${menu_items[i]}"
  done
  echo

  # Get user selection
  while true; do
    printf "${BLUE}Enter number (1-%d) or press Enter to cancel:${NC} " ${#menu_items[@]}
    read -r selection

    if [[ -z "$selection" ]]; then
      info "Worktree selection cancelled"
      exit 0
    fi

    if [[ "$selection" =~ ^[0-9]+$ ]] && [[ $selection -ge 1 ]] && [[ $selection -le ${#menu_items[@]} ]]; then
      selected_index=$((selection - 1))
      break
    else
      printf "${RED}Invalid selection. Please enter a number between 1 and %d.${NC}\n" ${#menu_items[@]}
    fi
  done
else
  # Use gum filter for many worktrees
  if gum_available; then
    if selection_output=$(printf '%s\n' "${menu_items[@]}" | gum filter --header="Select worktree to switch to (ESC to cancel)"); then
      # Find the index of the selected item
      for i in "${!menu_items[@]}"; do
        if [[ "${menu_items[i]}" == "$selection_output" ]]; then
          selected_index=$i
          break
        fi
      done
    else
      info "Worktree selection cancelled"
      exit 0
    fi
  else
    # Fallback to numbered menu even for many items if gum is not available
    echo
    for i in "${!menu_items[@]}"; do
      printf "  %2d) %s\n" $((i + 1)) "${menu_items[i]}"
    done
    echo

    while true; do
      printf "${BLUE}Enter number (1-%d) or press Enter to cancel:${NC} " ${#menu_items[@]}
      read -r selection

      if [[ -z "$selection" ]]; then
        info "Worktree selection cancelled"
        exit 0
      fi

      if [[ "$selection" =~ ^[0-9]+$ ]] && [[ $selection -ge 1 ]] && [[ $selection -le ${#menu_items[@]} ]]; then
        selected_index=$((selection - 1))
        break
      else
        printf "${RED}Invalid selection. Please enter a number between 1 and %d.${NC}\n" ${#menu_items[@]}
      fi
    done
  fi
fi

# Switch to selected worktree
if [[ $selected_index -ge 0 ]]; then
  selected_path="${worktree_selection_paths[selected_index]}"

  # Check if it's the current worktree
  if [[ "$selected_path" == "$current_worktree" ]]; then
    info "Already in worktree: $selected_path"
    current_branch=$(git branch --show-current 2> /dev/null || echo "detached")
    info "Current branch: $current_branch"
    exit 0
  fi

  switch_to_worktree "$selected_path"
  exit $?
else
  error "Invalid worktree selection"
  exit 1
fi
