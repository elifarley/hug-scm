#!/usr/bin/env bash
CMD_BASE="$(readlink -f "$0" 2> /dev/null || greadlink -f "$0")" || CMD_BASE="$0"
CMD_BASE="$(dirname "$CMD_BASE")"
for f in hug-common hug-git-kit; do . "$CMD_BASE/../lib/$f"; done # Load common constants and functions
set -euo pipefail                                                 # Exit on error, undefined vars, pipe failures

# Part of the Hug tool suite

show_help() {
  cat << 'EOF'
Usage: hug w purge-all [OPTIONS]

Remove untracked and/or ignored files across the entire repository.

Options:
  -u, --untracked  Remove untracked files (default when no flags provided)
  -i, --ignored    Remove ignored files
      --dry-run    Show what would be removed without deleting anything
  -f, --force      Skip confirmation prompt
  -h, --help       Show this help

Notes:
  • Combine -u and -i to remove both untracked and ignored content.
  • Without flags, only untracked files are removed.
EOF
}

dry_run=false
force=false
target_untracked=false
target_ignored=false
flags_explicit=false

while [[ $# -gt 0 ]]; do
  case "$1" in
  -u | --untracked)
    target_untracked=true
    flags_explicit=true
    shift
    ;;
  -i | --ignored)
    target_ignored=true
    flags_explicit=true
    shift
    ;;
  --dry-run)
    dry_run=true
    shift
    ;;
  -f | --force)
    force=true
    shift
    ;;
  -h | --help)
    show_help
    exit 0
    ;;
  -*)
    error "unknown option: $1"
    show_help >&2
    exit 2
    ;;
  *)
    error "positional arguments are not accepted (use 'git w purge' for path-specific)"
    show_help >&2
    exit 2
    ;;
  esac
done

if ! $flags_explicit; then
  target_untracked=true
fi

# Early exit if not in Git repo
check_git_repo

build_preview() {
  local preview_cmd=("git" "clean" "-n" "-d")
  if $target_untracked && $target_ignored; then
    preview_cmd+=("-x")
  elif $target_ignored; then
    preview_cmd+=("-X")
  fi
  "${preview_cmd[@]}" 2> /dev/null
}

preview_output=$(build_preview)

# git clean -n produces no output when there's nothing to clean
if [[ -z "$preview_output" ]]; then
  print_nothing_to_do "purge"
  exit 0
fi

if $dry_run; then
  print_dry_run_preview "be removed"
  printf '\n%s\n' "$preview_output"
  exit 0
fi

if ! $force; then
  print_action_preview "remove the listed entries"
  printf '\n%s\n' "$preview_output"
  prompt_confirm_danger 'purge-all'
fi

run_cmd=("git" "clean" "-f" "-d")
if $target_untracked && $target_ignored; then
  run_cmd+=("-x")
elif $target_ignored; then
  run_cmd+=("-X")
fi

"${run_cmd[@]}"

exit 0
