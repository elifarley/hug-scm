#!/usr/bin/env bash
CMD_BASE="$(readlink -f "$0" 2>/dev/null || greadlink -f "$0")" || CMD_BASE="$0"; CMD_BASE="$(dirname "$CMD_BASE")"
for f in hug-common hug-git-kit; do . "$CMD_BASE/../lib/$f"; done # Load common constants and functions
set -euo pipefail  # Exit on error, undefined vars, pipe failures

# Part of the Hug tool suite

show_help() {
  cat <<'EOF'
Usage: hug w discard-all [OPTIONS]

Discard uncommitted changes on all tracked files across the entire working directory.
All tracked files will match HEAD.

Options:
  -u, --unstaged   Discard unstaged changes (default when no flags provided)
  -s, --staged     Discard staged changes
      --dry-run    Show what would be discarded without applying changes
  -f, --force      Skip confirmation prompt
  -h, --help       Show this help

Notes:
  • Without flags, only unstaged changes are discarded (staged changes preserved).
  • Use --staged to discard only staged changes (unstaged changes preserved).
  • Combine -u and -s to discard both staged and unstaged changes.
See also:
  • `w wipe-all` (to discard both staged and unstaged uncommitted changes)
EOF
}

dry_run=false
force=false
target_unstaged=false
target_staged=false
flags_explicit=false

while [[ $# -gt 0 ]]; do
  case "$1" in
    -u|--unstaged)
      target_unstaged=true
      flags_explicit=true
      shift
      ;;
    -s|--staged)
      target_staged=true
      flags_explicit=true
      shift
      ;;
    --dry-run)
      dry_run=true
      shift
      ;;
    -f|--force)
      force=true
      shift
      ;;
    -h|--help)
      show_help
      exit 0
      ;;
    -*)
      error "unknown option: $1"
      show_help >&2
      exit 2
      ;;
    *)
      error "positional arguments are not accepted (use 'git w discard' for path-specific)"
      show_help >&2
      exit 2
      ;;
  esac
done

if ! $flags_explicit; then
  target_unstaged=true
fi

check_git_repo

# Check for changes and handle dry run
declare -a unstaged_paths=() staged_paths=()
empty=true
if $target_unstaged; then
  mapfile -t unstaged_paths < <(git diff --name-only 2>/dev/null || true)
  dedupe_array unstaged_paths
  [[ ${#unstaged_paths[@]} -gt 0 ]] && empty=false
fi
if $target_staged; then
  mapfile -t staged_paths < <(git diff --cached --name-only 2>/dev/null || true)
  dedupe_array staged_paths
  [[ ${#staged_paths[@]} -gt 0 ]] && empty=false
fi

total_changes=$(( ${#unstaged_paths[@]} + ${#staged_paths[@]} ))
if [[ $total_changes -eq 0 ]]; then
  print_nothing_to_do "discard"
  exit 0
fi

if $dry_run; then
  print_dry_run_preview "be discarded" ""
  printf '\n'
  print_staged_unstaged_paths staged_paths unstaged_paths "$target_staged" "$target_unstaged"
  exit 0
fi

# Confirmation preview
if ! $force; then
  print_action_preview "discard the listed changes"
  printf '\n'
  print_staged_unstaged_paths staged_paths unstaged_paths "$target_staged" "$target_unstaged"
  confirm_action_danger 'discard-all'
fi

# Execution
if $target_staged && $target_unstaged; then
  discard_all_uncommitted_changes
elif $target_unstaged; then
  discard_all_unstaged
elif $target_staged; then
  discard_all_staged
fi

exit 0
