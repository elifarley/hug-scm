#!/usr/bin/env bash
# Assume HUG_HOME is set (exported by hug or environment)
# shellcheck source=git-config/lib/hug-common
. "$HUG_HOME/git-config/lib/hug-common"
# shellcheck source=git-config/lib/hug-git-kit
. "$HUG_HOME/git-config/lib/hug-git-kit"
set -euo pipefail  # Exit on error, undefined vars, pipe failures
# Part of the Hug tool suite

show_help() {
    cat << 'EOF'
hug bc: Create a new branch and switch to it

USAGE:
    hug bc [<branch-name>] [--point-to <commitish>] [-h, --help]
    hug bc [--point-to <commitish>] [<branch-name>] [-h, --help]

ARGUMENTS:
    <branch-name>      Name for the new branch (optional with --point-to)

OPTIONS:
    --point-to <commitish>   Create branch pointing to a specific commit, tag, or branch
                             If specified without a branch name, generates one automatically
    -h, --help               Show this help

DESCRIPTION:
    Creates a new branch and switches to it. By default, creates from the current HEAD.
    
    With --point-to, you can create a branch from any commit, tag, or branch.
    When --point-to is used without a branch name, automatically generates a name:
    - If target is a branch: <branch>.copy.<iso-datetime>
    - If target is not a branch: <target>.branch.<iso-datetime>
    
    The ISO datetime format is YYYYMMDD-HHMM (e.g., 20251109-1430).

EXAMPLES:
    hug bc new-feature                      # Create branch from current HEAD
    hug bc --point-to abc123 my-feature     # Create branch from commit abc123
    hug bc --point-to v1.0.0                # Auto-generate name from tag
    hug bc --point-to main                  # Auto-generate name from branch
    hug bc my-feature --point-to abc123     # Flag can come after branch name

SEE ALSO:
    hug b      Switch to an existing branch
    hug br     Rename current branch
    hug bl     List local branches

FURTHER READING:
    See 'git switch --help' for underlying implementation details.
EOF
}

# Check for help flag first
for arg in "$@"; do
    if [[ "$arg" == "-h" || "$arg" == "--help" ]]; then
        show_help
        exit 0
    fi
done

check_git_repo

# Parse arguments
branch_name=""
point_to=""
while [[ $# -gt 0 ]]; do
    case "$1" in
        --point-to)
            if [[ $# -lt 2 ]]; then
                error "--point-to requires a commitish argument"
            fi
            point_to="$2"
            shift 2
            ;;
        -*)
            error "Unknown option: $1. See 'hug bc --help'."
            ;;
        *)
            if [[ -z "$branch_name" ]]; then
                branch_name="$1"
            else
                error "Too many arguments. Expected one branch name. See 'hug bc --help'."
            fi
            shift
            ;;
    esac
done

# If no branch name and no point-to, error
if [[ -z "$branch_name" && -z "$point_to" ]]; then
    error "Branch name is required. See 'hug bc --help'."
fi

# If point-to is specified without a branch name, generate one
if [[ -n "$point_to" && -z "$branch_name" ]]; then
    # Verify the target exists
    if ! git rev-parse --verify --quiet "$point_to" >/dev/null 2>&1; then
        error "Invalid commitish: $point_to"
    fi
    
    # Check if point_to is a branch name
    is_branch=false
    if git show-ref --verify --quiet "refs/heads/$point_to" 2>/dev/null; then
        is_branch=true
    fi
    
    # Generate ISO datetime: YYYYMMDD-HHMM
    iso_datetime=$(date +"%Y%m%d-%H%M")
    
    # Clean the target name (remove refs/heads/, refs/tags/, etc.)
    clean_target=$(echo "$point_to" | sed 's|^refs/[^/]*/||')
    
    # For commit hashes, use short form (7 chars) for readability
    if git rev-parse --verify --quiet "$point_to^{commit}" >/dev/null 2>&1; then
        short_hash=$(git rev-parse --short=7 "$point_to")
        # Only use short hash if the clean_target looks like a full hash (40 chars)
        if [[ ${#clean_target} -eq 40 ]]; then
            clean_target="$short_hash"
        fi
    fi
    
    # Generate branch name based on whether target is a branch
    if [[ "$is_branch" == "true" ]]; then
        branch_name="${clean_target}.copy.${iso_datetime}"
    else
        branch_name="${clean_target}.branch.${iso_datetime}"
    fi
    
    info "Auto-generated branch name: $branch_name"
fi

# Create and switch to the branch
if [[ -n "$point_to" ]]; then
    # Verify the target exists
    if ! git rev-parse --verify --quiet "$point_to" >/dev/null 2>&1; then
        error "Invalid commitish: $point_to"
    fi
    git switch -c "$branch_name" "$point_to"
else
    git switch -c "$branch_name"
fi
