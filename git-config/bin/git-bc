#!/usr/bin/env bash
# Assume HUG_HOME is set (exported by hug or environment)
# shellcheck source=git-config/lib/hug-common
. "$HUG_HOME/git-config/lib/hug-common"
# shellcheck source=git-config/lib/hug-git-kit
. "$HUG_HOME/git-config/lib/hug-git-kit"
set -euo pipefail  # Exit on error, undefined vars, pipe failures
# Part of the Hug tool suite

show_help() {
    cat << 'EOF'
hug bc: Create a new branch and switch to it

USAGE:
    hug bc [<branch-name>] [-t, --point-to <commitish>] [--no-switch] [-h, --help]
    hug bc [-t, --point-to <commitish>] [<branch-name>] [--no-switch] [-h, --help]

ARGUMENTS:
    <branch-name>      Name for the new branch (optional with -t/--point-to)

OPTIONS:
    -t, --point-to <commitish>   Create branch pointing to a specific commit, tag, or branch
                                 If specified without a branch name, generates one automatically
    --no-switch                  Create branch without switching to it
    -h, --help                   Show this help

DESCRIPTION:
    Creates a new branch and switches to it. By default, creates from the current HEAD.
    
    With -t/--point-to, you can create a branch from any commit, tag, or branch.
    When -t/--point-to is used without a branch name, automatically generates a name:
    - If target is a branch: <branch>.copy.<iso-datetime>
    - If target is not a branch: <target>.branch.<iso-datetime>
    
    The ISO datetime format is YYYYMMDD-HHMM (e.g., 20251109-1430).

EXAMPLES:
    hug bc new-feature                      # Create branch from current HEAD
    hug bc -t abc123 my-feature             # Create branch from commit abc123
    hug bc -t v1.0.0                        # Auto-generate name from tag
    hug bc -t main                          # Auto-generate name from branch
    hug bc my-feature -t abc123             # Flag can come after branch name
    hug bc --no-switch backup-branch        # Create without switching
    hug bc --no-switch -t v1.0.0            # Auto-generate and create without switching

SEE ALSO:
    hug b      Switch to an existing branch
    hug br     Rename current branch
    hug bl     List local branches

FURTHER READING:
    See 'git switch --help' for underlying implementation details.
EOF
}

check_git_repo

# Parse arguments using getopt
set +e  # Temporarily disable exit on error to capture getopt failure
PARSED=$(getopt --options ht: --longoptions help,point-to:,no-switch --name "hug bc" -- "$@" 2>&1)
getopt_status=$?
set -e  # Re-enable exit on error

if [ $getopt_status -ne 0 ]; then
  # getopt failed - print the error message if available
  if [ -n "$PARSED" ]; then
    echo "$PARSED" >&2
  fi
  exit 1
fi

eval set -- "$PARSED"

# Initialize variables
branch_name=""
point_to=""
no_switch=false

# Process options
while true; do
    case "$1" in
        -h|--help)
            show_help
            exit 0
            ;;
        -t|--point-to)
            validate_commitish "-t/--point-to" "$2"
            point_to="$2"
            shift 2
            ;;
        --no-switch)
            no_switch=true
            shift
            ;;
        --)
            shift
            break
            ;;
        *)
            error "Internal error in option parsing"
            ;;
    esac
done

# Collect branch name from remaining arguments
if [[ $# -gt 1 ]]; then
    error "Too many arguments. Expected one branch name. See 'hug bc --help'."
elif [[ $# -eq 1 ]]; then
    branch_name="$1"
fi

# If no branch name and no point-to, error
if [[ -z "$branch_name" && -z "$point_to" ]]; then
    error "Branch name is required. See 'hug bc --help'."
fi

# If point-to is specified without a branch name, generate one
if [[ -n "$point_to" && -z "$branch_name" ]]; then
    # Check if point_to is a branch name
    is_branch=false
    if git show-ref --verify --quiet "refs/heads/$point_to" 2>/dev/null; then
        is_branch=true
    fi
    
    # Generate ISO datetime: YYYYMMDD-HHMM
    iso_datetime=$(date +"%Y%m%d-%H%M")
    
    # Clean the target name (remove refs/heads/, refs/tags/, etc.)
    clean_target=$(echo "$point_to" | sed 's|^refs/[^/]*/||')
    
    # For commit hashes, use short form (7 chars) for readability
    if git rev-parse --verify --quiet "$point_to^{commit}" >/dev/null 2>&1; then
        short_hash=$(git rev-parse --short=7 "$point_to")
        # Only use short hash if the clean_target looks like a full hash (40 chars)
        if [[ ${#clean_target} -eq 40 ]]; then
            clean_target="$short_hash"
        fi
    fi
    
    # Generate branch name based on whether target is a branch
    if [[ "$is_branch" == "true" ]]; then
        branch_name="${clean_target}.copy.${iso_datetime}"
    else
        branch_name="${clean_target}.branch.${iso_datetime}"
    fi
    
    # Ensure uniqueness by appending seconds if the name already exists
    if git show-ref --verify --quiet "refs/heads/$branch_name" 2>/dev/null; then
        branch_name="${branch_name}.$(date +%S)"
        warn "Generated name existed; using $branch_name"
    fi
    
    info "Auto-generated branch name: $branch_name"
fi

# Create and switch to the branch
if [[ -n "$point_to" ]]; then
    if [[ "$no_switch" == true ]]; then
        git branch "$branch_name" "$point_to"
        info "Created branch '$branch_name' pointing to $point_to (use 'hug b $branch_name' to switch)"
    else
        git switch -c "$branch_name" "$point_to"
    fi
else
    if [[ "$no_switch" == true ]]; then
        git branch "$branch_name"
        info "Created branch '$branch_name' from HEAD (use 'hug b $branch_name' to switch)"
    else
        git switch -c "$branch_name"
    fi
fi
