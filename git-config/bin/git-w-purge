#!/usr/bin/env bash
CMD_BASE="$(readlink -f "$0" 2>/dev/null || greadlink -f "$0")" || CMD_BASE="$0"; CMD_BASE="$(dirname "$CMD_BASE")"
for f in hug-common hug-git-kit; do . "$CMD_BASE/../lib/$f"; done # Load common constants and functions
set -euo pipefail  # Exit on error, undefined vars, pipe failures

# Part of the Hug tool suite

show_help() {
  cat <<'EOF'
Usage: hug w purge [OPTIONS] [<path>...]

Remove untracked and/or ignored files for the given paths.

Options:
  -u, --untracked    Remove untracked files (default when no flags provided)
  -i, --ignored      Remove ignored files
      --browse-root  Browse full repository scope in file selector UI (default: current directory)
      --dry-run      Show what would be removed without deleting anything
  -f, --force        Skip confirmation prompt
  -h, --help         Show this help

Behavior:
  • When run with no paths, shows an interactive file selection UI (requires gum).
  • By default, file selection is scoped to the current directory and subdirectories.
  • Use --browse-root to browse files across the entire repository in the UI.
  • When explicit paths are provided, they are interpreted relative to the current directory.
  • Use `hug w purge-all` for repository-wide purge without interactive selection.

Notes:
  • Paths that are tracked will produce an error.

Examples:
  hug w purge                     # Interactive UI, current directory scope
  hug w purge --browse-root       # Interactive UI, full repository scope
  hug w purge file.txt            # Purge specific file (CWD-relative)

See also:
  • `w purge-all` (purge across entire repository without UI)
EOF
}

# Initialize custom flag variables
target_untracked=false
target_ignored=false
flags_explicit=false

# Parse custom flags first (non-common flags)
while [[ $# -gt 0 ]]; do
  case "$1" in
    -u|--untracked)
      target_untracked=true
      flags_explicit=true
      shift
      ;;
    -i|--ignored)
      target_ignored=true
      flags_explicit=true
      shift
      ;;
    *)
      break
      ;;
  esac
done

# Parse common flags (--browse-root, --dry-run, -f|--force, -h|--help, --)
eval "$(parse_common_flags "$@")"

# Initialize common flag variables if not set by parse_common_flags
: "${browse_root:=false}"
: "${dry_run:=false}"
: "${force:=false}"

if ! $flags_explicit; then
  target_untracked=true
fi

# Early exit if not in Git repo
check_git_repo

# Handle interactive file selection when no paths provided
if [[ $# -lt 1 ]]; then
  # Check for conflicting flags
  if $browse_root; then
    # --browse-root without explicit paths is valid (triggers UI with full scope)
    :
  fi
  
  # Determine which file types to show based on flags
  declare -a select_opts=("--multi")
  
  # Default to --cwd (current directory scope) unless --browse-root is specified
  if ! $browse_root; then
    select_opts+=("--cwd")
  fi
  
  if $target_untracked; then
    select_opts+=("--untracked")
  fi
  
  if $target_ignored; then
    select_opts+=("--ignored")
  fi
  
  select_opts+=("--prompt" "Select files to purge...")
  
  paths=()
  if ! mapfile -t paths < <(select_files_with_status "${select_opts[@]}"); then
    info "No files selected or cancelled."
    exit 0
  fi
  
  if [[ ${#paths[@]} -eq 0 ]]; then
    info "No files selected."
    exit 0
  fi
else
  # Explicit paths provided - check for conflicting flags
  if $browse_root; then
    error "--browse-root cannot be used with explicit paths. Either use --browse-root alone to browse files, or specify paths directly."
  fi
  
  paths=("$@")
fi

declare -a untracked_paths=()
declare -a ignored_paths=()

while IFS= read -r -d '' entry; do
  [[ -z "$entry" ]] && continue
  status=${entry:0:2}
  path=${entry:3}
  case "$status" in
    '??')
      untracked_paths+=("$path")
      ;;
    '!!')
      ignored_paths+=("$path")
      ;;
    *)
      error "path '$path' is tracked or has staged changes; purge operates on untracked/ignored only"
      exit 1
      ;;
  esac
done < <(git status --porcelain=v1 --ignored=matching -z -- "${paths[@]}" 2>/dev/null || true)

dedupe_array untracked_paths
dedupe_array ignored_paths

(( ${#untracked_paths[@]} == 0 )) && (( ${#ignored_paths[@]} == 0 )) && {
  print_nothing_to_do "purge" "from the specified paths."
  exit 0
}

if $dry_run; then
  print_dry_run_preview "be removed" "from the specified paths."
  printf '\n'
  if $target_untracked && [[ ${#untracked_paths[@]} -gt 0 ]]; then
    print_list '  Untracked' "${untracked_paths[@]}"
  fi
  if $target_ignored && [[ ${#ignored_paths[@]} -gt 0 ]]; then
    print_list '  Ignored' "${ignored_paths[@]}"
  fi
  exit 0
fi
# Convert paths to be relative to current directory for git clean
convert_to_relative_paths untracked_paths
convert_to_relative_paths ignored_paths


remove_with_clean() {
  local mode_flags=()
  # Collect all flags until we hit a non-flag argument
  while [[ $# -gt 0 && "$1" == -* ]]; do
    mode_flags+=("$1")
    shift
  done
  git clean "${mode_flags[@]}" -d -- "$@"
}

print_action_preview "purge the listed entries" "from the specified paths."
printf '\n'

if $target_untracked && [[ ${#untracked_paths[@]} -gt 0 ]]; then
  print_list '  Untracked' "${untracked_paths[@]}"
fi
if $target_ignored && [[ ${#ignored_paths[@]} -gt 0 ]]; then
  print_list '  Ignored' "${ignored_paths[@]}"
fi

# Prompt for confirmation unless force flag is set
if ! $force; then
  prompt_confirm
fi

if $target_untracked && $target_ignored; then
  combined=("${untracked_paths[@]}" "${ignored_paths[@]}")
  dedupe_array combined
  if [[ ${#combined[@]} -gt 0 ]]; then
    remove_with_clean -f -x "${combined[@]}"
    print_list 'Removed (untracked + ignored)' "${combined[@]}"
  fi
else
  if $target_untracked && [[ ${#untracked_paths[@]} -gt 0 ]]; then
    remove_with_clean -f "${untracked_paths[@]}"
    print_list 'Removed untracked' "${untracked_paths[@]}"
  fi
  if $target_ignored && [[ ${#ignored_paths[@]} -gt 0 ]]; then
    remove_with_clean -f -X "${ignored_paths[@]}"
    print_list 'Removed ignored' "${ignored_paths[@]}"
  fi
fi

exit 0
