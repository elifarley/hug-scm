#!/usr/bin/env bash
CMD_BASE="$(readlink -f "$0" 2>/dev/null || greadlink -f "$0")" || CMD_BASE="$0"; CMD_BASE="$(dirname "$CMD_BASE")"
for f in hug-common hug-git-kit; do . "$CMD_BASE/../lib/$f"; done
set -euo pipefail  # Exit on error, undefined vars, pipe failures
# Part of the Hug tool suite

show_help() {
    cat << EOF
hug cmv: Move (relocate) commits from current branch to another branch (new or existing).

USAGE:
    hug cmv [N|COMMIT] <target-branch> [--new] [-u, --upstream] [--quiet] [--force]

OPTIONS:
    [N|COMMIT]      Number of commits to move (default: 1) or specific commit to move above
    <target-branch> Required: Branch to move commits to
    --new           Create <target-branch> if it doesn't exist (from the move target commit)
    -u, --upstream  Move local-only commits above upstream tip instead of [N|COMMIT]
    --quiet         Suppress output (sets HUG_QUIET=T)
    --force         Skip confirmation prompts (use with caution)

DESCRIPTION:
    Moves the specified commits from the current branch to <target-branch> by detaching (new branches) or cherry-picking (existing) and resetting the current branch back. Preserves individual commit history. If <target-branch> missing without --new, prompts to create (auto-creates with --force). Use --new for explicit non-interactive creation. For new branches, detaches by creating at original HEAD then resetting original back (exact history preserved, no conflicts). For existing, cherry-picks the range. With -u, moves commits above the upstream remote tip (read-only preview/confirmation; no fetch).

    Requires a clean working tree and index (no staged or unstaged changes; untracked ok). Cannot mix -u with [N|COMMIT]. Aborts on cherry-pick conflicts (existing branches) or if <target-branch> can't be checked out.

EXAMPLES:
    hug cmv 2 feature/new --new     # Move last 2 commits to new branch 'feature/new'
    hug cmv a1b2c3 existing-branch  # Move commits above a1b2c3 to 'existing-branch'
    hug cmv -u feature/local        # Move local-only commits to 'feature/local'
    hug cmv 3 bugfix --force        # Skip confirmation

SEE ALSO:
    hug cc    Copy commits instead of moving
    hug h back    Move HEAD back without relocating
    hug b         Branch management
EOF
}

# Parse common flags (--quiet, --force, -h|--help)
eval "$(parse_common_flags "$@")"

# Parse custom flags
upstream=false
new_branch=false
target_arg=""
branch_name=""
while [[ $# -gt 0 ]]; do
  case "$1" in
    -u|--upstream) upstream=true; shift ;;
    --new) new_branch=true; shift ;;
    *) 
      if [[ -z "$target_arg" ]]; then target_arg="$1"
      elif [[ -z "$branch_name" ]]; then branch_name="$1"
      else error "Unexpected argument: $1"; fi
      shift ;;
  esac
done

if [[ -z "$branch_name" ]]; then
  # Special case: if using -u and target_arg is set, it's actually the branch name
  if $upstream && [[ -n "$target_arg" ]]; then
    branch_name="$target_arg"
    target_arg=""
  else
    error "Missing required <target-branch>."
  fi
fi

if $upstream && [[ -n "$target_arg" ]]; then
  error "Cannot specify both --upstream and [N|COMMIT]."
fi

check_git_repo

# Require clean working tree and index (no staged or unstaged changes)
if has_staged_changes || has_unstaged_changes; then
  error "Require clean working tree and index to proceed (no staged or unstaged changes; untracked ok). Unstaged changes would be lost during reset."
fi

original_branch=$(git branch --show-current)
if [[ -z "$original_branch" ]]; then
  error "Must be on a branch to move commits. (Detached HEAD not supported.)"
fi
original_head=$(git rev-parse HEAD)

if $upstream; then
  target=$(handle_upstream_operation "moving") || exit 1
  if [[ -z "${target:-}" ]]; then
    exit 0
  fi
else
  # Special case: if target_arg is "0", immediately exit with message
  if [[ "${target_arg:-}" == "0" ]]; then
    info "No commits to move (target is 0)."
    exit 0
  fi
  target=$(resolve_head_target "${target_arg:-}" 'HEAD~1')
  # Validate that the target is a valid commit before proceeding
  if ! git_error=$(git rev-parse --verify "$target" 2>&1); then
    printf '%s\n' "$git_error" >&2
    error "Invalid commit target: $target"
  fi
  handle_standard_operation "moving" "$target" false
fi

# Resolve target to actual SHA (important: do this before reset changes HEAD)
target=$(git rev-parse "$target")

# Check branch existence
branch_exists=true
commits_to_relocate=0  # Initialize to avoid unbound variable error
commit_word="commit"
if ! git rev-parse --verify "$branch_name" >/dev/null 2>&1; then
  branch_exists=false
  if ! $new_branch; then
    if [[ ${HUG_FORCE:-} == true ]]; then
      # Need to calculate commits_to_relocate for later use
      commits_to_relocate=$(count_commits_in_range "$target" HEAD)
      if [ "$commits_to_relocate" -gt 1 ]; then
        commit_word="commits"
      fi
      if [[ ${HUG_QUIET:-} != T ]]; then
        printf 'Branch %s missing; auto-creating with --force from target %s.\n' "$branch_name" "$(git rev-parse --short "$target")" >&2
      fi
      new_branch=true  # Enable creation logic
    else
      # Combined prompt for creation + move
      commits_to_relocate=$(count_commits_in_range "$target" HEAD)
      if [ "$commits_to_relocate" -eq 0 ]; then
        info "No commits to move (already at target)."
        exit 0
      fi

      commit_word="commit"
      if [ "$commits_to_relocate" -gt 1 ]; then
        commit_word="commits"
      fi

      if [[ ${HUG_QUIET:-} != T ]]; then
        printf 'Commits to move to %s (new branch):\n' "$branch_name" >&2
        print_commit_list_in_range "$target" HEAD >&2
        printf '\nPreview: changes in %d %s.\n' "$commits_to_relocate" "$commit_word" >&2
        git diff --stat "$target"..HEAD >&2
      fi

      if prompt_confirm "Branch '$branch_name' doesn't exist. Proceed with creating a new branch named '$branch_name' and moving $commits_to_relocate $commit_word to it? [y/N]: "; then
        new_branch=true
      else
        info "Cancelled."
        exit 0
      fi
    fi
  else
    # --new was explicitly specified, calculate commits_to_relocate
    commits_to_relocate=$(count_commits_in_range "$target" HEAD)
    if [ "$commits_to_relocate" -gt 1 ]; then
      commit_word="commits"
    fi
  fi
fi

# For existing branches, count and confirm move (new branches already handled above)
if $branch_exists; then
  commits_to_relocate=$(count_commits_in_range "$target" HEAD)
  if [ "$commits_to_relocate" -eq 0 ]; then
    info "No commits to move (already at target)."
    exit 0
  fi

  commit_word="commit"
  if [ "$commits_to_relocate" -gt 1 ]; then
    commit_word="commits"
  fi

  if [[ ${HUG_QUIET:-} != T ]]; then
    printf 'Commits to move to %s:\n' "$branch_name" >&2
    print_commit_list_in_range "$target" HEAD >&2
    printf '\nPreview: changes in %d %s.\n' "$commits_to_relocate" "$commit_word" >&2
    git diff --stat "$target"..HEAD >&2
  fi

  # Confirmation (only if --force not set; tree is clean, so always skip prompt if force)
  should_prompt=true
  if [[ ${HUG_FORCE:-} == true ]]; then
    should_prompt=false
  fi

  if $should_prompt; then
    prompt_confirm "Proceed with moving $commits_to_relocate $commit_word to '$branch_name'? [y/N]: "
  fi
fi

# Reset original branch to target (safe since tree/index clean)
git checkout -q "$original_branch"
if [[ ${HUG_QUIET:-} == T ]]; then
  git reset --hard "$target" >/dev/null 2>&1
else
  git reset --hard "$target"
fi

# Handle creation or existing
if ! $branch_exists && $new_branch; then
  # Simple detach for new branch: create pointing to original HEAD
  git branch "$branch_name" "$original_head"
else
  # Existing branch: use temp for cherry-pick
  temp_branch="hug-move-temp-$(git rev-parse --short "$original_head")"
  git branch "$temp_branch" "$original_head"
  git checkout -q "$branch_name"
  git cherry-pick "$target".."$temp_branch"
  git branch -D "$temp_branch"
fi

# Stay on target branch
git checkout -q "$branch_name"

test "${HUG_QUIET:-f}" = T && exit

if ! $branch_exists && $new_branch; then
  info "Created and moved $commits_to_relocate $commit_word to new branch '$branch_name'. Now on '$branch_name'."
else
  info "Moved $commits_to_relocate $commit_word to '$branch_name'. Now on '$branch_name'."
fi
tip "Commits relocated. Continue working on '$branch_name'."
