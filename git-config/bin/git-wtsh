#!/usr/bin/env bash
CMD_BASE="$(readlink -f "$0" 2>/dev/null || greadlink -f "$0")" || CMD_BASE="$0"; CMD_BASE="$(dirname "$CMD_BASE")"
for f in hug-common hug-git-kit hug-git-worktree; do . "$CMD_BASE/../lib/$f"; done # Load common constants and functions
set -euo pipefail  # Exit on error, undefined vars, pipe failures

# Part of the Hug tool suite

show_help() {
  cat <<'EOF'
hug wtsh: Show detailed information about worktrees in a comprehensive, readable format.

USAGE:
  hug wtsh [OPTIONS] [SEARCH_TERM]
  hug wtsh --           # Interactive worktree selection

OPTIONS:
  -h, --help     Show this help message and exit.
  -a, --all      Show all worktrees (preserves current behavior)

DESCRIPTION:
  Displays detailed information about worktrees with flexible viewing options:

  DEFAULT BEHAVIOR (no arguments):
    Shows details for the CURRENT worktree only. This provides focused information
    about your current working context.

  --all FLAG:
    Shows details for ALL worktrees (preserves existing hug wtsh behavior).

  -- FLAG (interactive mode):
    Presents an interactive menu to select which worktree to display.
    Uses gum filter for enhanced selection when available.

  SEARCH TERM:
    Filter worktrees by path or branch name (case-insensitive).
    Preserves existing search functionality.

STATUS INDICATORS:
  [CURRENT] - The worktree you're currently in
  [DIRTY]   - Worktree has uncommitted changes
  [LOCKED]  - Worktree is locked (cannot be removed)
  [DETACHED] - Worktree is in detached HEAD state

EXAMPLES:
  hug wtsh                   # Current worktree only (new default)
  hug wtsh --all             # All worktrees (preserves current behavior)
  hug wtsh -a                # All worktrees (short alias for --all)
  hug wtsh --                # Interactive worktree selection
  hug wtsh feature           # Search/filter by branch name
  hug wtsh /path/to/project  # Search/filter by path

SEE ALSO:
  hug wtl  : For listing worktrees in short form
  hug wtll : For listing worktrees in long form
  hug wt   : For interactive worktree selection and switching
EOF
}

# Function to show only the current worktree
show_current_worktree_only() {
  local current_worktree="$1"

  # Find the current worktree in the arrays
  for i in "${!worktree_paths[@]}"; do
    if [[ "${worktree_paths[$i]}" == "$current_worktree" ]]; then
      # Show details for current worktree only
      show_worktree_details "$current_worktree" "${worktree_paths[$i]}"
      return 0
    fi
  done

  error "No current worktree found"
  return 1
}

# Function to handle interactive worktree selection
interactive_worktree_selection() {
  local current_worktree="$1"
  shift
  local worktree_array=("$@")

  if [[ ${#worktree_array[@]} -eq 0 ]]; then
    error "No worktrees found for interactive selection"
    return 1
  fi

  # Check if gum is available
  if ! gum_available; then
    error "Interactive worktree selection requires 'gum' to be installed.
Install gum: https://github.com/charmbracelet/gum"
    return 1
  fi

  # Build formatted options for interactive selection
  declare -a formatted_options=()
  declare -a worktree_selection_paths=()

  for i in "${!worktree_array[@]}"; do
    local path="${worktree_array[$i]}"
    local branch="${branches[$i]}"
    local commit="${commits[$i]}"
    local dirty="${status_dirty[$i]}"
    local locked="${locked_status[$i]}"

    # Build status indicators
    local status_indicators=""
    local path_display="${path/#$HOME/\~}"

    # Check if current worktree
    [[ "$path" == "$current_worktree" ]] && status_indicators="${GREEN}[CURRENT]${NC} "
    [[ "$dirty" == "true" ]] && status_indicators="${status_indicators}${YELLOW}[DIRTY]${NC} "
    [[ "$locked" == "true" ]] && status_indicators="${status_indicators}${RED}[LOCKED]${NC} "

    # Create formatted display string
    local formatted="${status_indicators}${branch} (${commit}) → ${path_display}"
    formatted_options+=("$formatted")
    worktree_selection_paths+=("$path")
  done

  # Use gum filter for selection
  local selection_output
  if selection_output=$(printf '%s\n' "${formatted_options[@]}" | gum filter --header="Select worktree to show details (ESC to cancel)" --placeholder="Search worktrees..."); then
    # Find the index of selected item
    local selected_index=-1
    for i in "${!formatted_options[@]}"; do
      if [[ "${formatted_options[i]}" == "$selection_output" ]]; then
        selected_index=$i
        break
      fi
    done

    if [[ $selected_index -ge 0 ]]; then
      local selected_path="${worktree_selection_paths[$selected_index]}"
      # Show details for selected worktree
      show_worktree_details "$current_worktree" "$selected_path"
      return 0
    else
      error "Invalid selection"
      return 1
    fi
  else
    info "Worktree selection cancelled"
    return 0
  fi
}

# Function to get detailed commit information
get_commit_details() {
  local worktree_path="$1"
  local commit_hash="$2"

  if [[ -d "$worktree_path" ]]; then
    # Get commit details using git log
    local author date subject
    author=$(git -C "$worktree_path" log -1 --format=%an "$commit_hash" 2>/dev/null || echo "Unknown")
    date=$(git -C "$worktree_path" log -1 --format=%cr "$commit_hash" 2>/dev/null || echo "Unknown")
    subject=$(git -C "$worktree_path" log -1 --format=%s "$commit_hash" 2>/dev/null || echo "Unknown")

    printf '%s|%s|%s' "$author" "$date" "$subject"
  fi
}

# Function to get branch information including remote tracking
get_branch_info() {
  local worktree_path="$1"
  local branch_name="$2"

  if [[ -d "$worktree_path" ]]; then
    # Check if we're on a branch or detached HEAD
    if [[ -n "$branch_name" ]]; then
      local remote_tracking ahead_behind
      remote_tracking=$(git -C "$worktree_path" for-each-ref --format='%(upstream:short)' "refs/heads/$branch_name" 2>/dev/null || echo "")

      # Get ahead/behind information if there's a remote tracking branch
      if [[ -n "$remote_tracking" ]]; then
        local ahead behind
        ahead=$(git -C "$worktree_path" rev-list --count "$remote_tracking..$branch_name" 2>/dev/null || echo "0")
        behind=$(git -C "$worktree_path" rev-list --count "$branch_name..$remote_tracking" 2>/dev/null || echo "0")

        if [[ "$ahead" -gt 0 && "$behind" -gt 0 ]]; then
          ahead_behind=" (↑$ahead ↓$behind)"
        elif [[ "$ahead" -gt 0 ]]; then
          ahead_behind=" (↑$ahead)"
        elif [[ "$behind" -gt 0 ]]; then
          ahead_behind=" (↓$behind)"
        else
          ahead_behind=" (up to date)"
        fi
        printf '%s|%s' "$remote_tracking" "$ahead_behind"
      else
        printf '%s|' "no remote"
      fi
    else
      # Detached HEAD
      printf 'detached HEAD|'
    fi
  fi
}

# Function to get worktree status details
get_status_details() {
  local worktree_path="$1"
  local is_dirty="$2"

  if [[ "$is_dirty" == "true" ]]; then
    local staged_count unstaged_count total_changes
    staged_count=$(git -C "$worktree_path" diff --cached --name-only 2>/dev/null | wc -l)
    unstaged_count=$(git -C "$worktree_path" diff --name-only 2>/dev/null | wc -l)
    total_changes=$((staged_count + unstaged_count))

    printf 'Dirty (%d files changed: %d staged, %d unstaged)' "$total_changes" "$staged_count" "$unstaged_count"
  else
    printf 'Clean'
  fi
}

# Function to display detailed worktree information
show_worktree_details() {
  local current_worktree="$1"
  local worktree_paths=("$@")

  # Remove the first argument (current_worktree) to get only the paths array
  local worktree_array=("${worktree_paths[@]:1}")

  printf "${BLUE}Worktree Summary${NC}\n"
  printf "───────────────────────\n"
  printf "Current: %s\n\n" "${current_worktree/#$HOME/\~}"

  if [[ ${#worktree_array[@]} -eq 0 ]]; then
    printf "${YELLOW}No worktrees found${NC}\n"
    return 1
  fi

  printf "${BLUE}Worktrees (%d total)${NC}\n" "${#worktree_array[@]}"
  printf "───────────────────────\n\n"

  for path in "${worktree_array[@]}"; do
    # Get worktree information from existing functions
    local branch commit dirty locked
    branch=$(git -C "$path" branch --show-current 2>/dev/null || echo "detached")

    # Get commit hash - try branch first, then HEAD
    if [[ "$branch" != "detached" ]]; then
      commit=$(git -C "$path" rev-parse --short "$branch" 2>/dev/null || echo "unknown")
    else
      commit=$(git -C "$path" rev-parse --short HEAD 2>/dev/null || echo "unknown")
    fi

    # Check if worktree is dirty
    if git -C "$path" diff --quiet 2>/dev/null && git -C "$path" diff --cached --quiet 2>/dev/null; then
      dirty="false"
    else
      dirty="true"
    fi

    # Check if locked (simplified check)
    locked="false"
    if ! git -C "$path" worktree list --porcelain 2>/dev/null | grep -A1 "^worktree $path\$" | grep -q "^locked"; then
      locked="false"
    else
      locked="true"
    fi

    # Build status indicators
    local indicators=""
    [[ "$path" == "$current_worktree" ]] && indicators="${indicators}${GREEN}[CURRENT]${NC} "
    [[ "$dirty" == "true" ]] && indicators="${indicators}${YELLOW}[DIRTY]${NC} "
    [[ "$locked" == "true" ]] && indicators="${indicators}${RED}[LOCKED]${NC} "
    [[ "$branch" == "detached" ]] && indicators="${indicators}${CYAN}[DETACHED]${NC} "

    local display_path="${path/#$HOME/\~}"
    printf "%s%s (%s)\n" "$indicators" "$display_path" "$branch"

    # Get detailed information
    printf "├─ Commit: %s " "$commit"

    # Get commit details
    local commit_details
    commit_details=$(get_commit_details "$path" "$commit")
    IFS='|' read -r author date subject <<< "$commit_details"

    printf "%s (%s)\n" "$subject" "$date"
    printf "├─ Author: %s\n" "$author"

    # Get branch information
    local branch_info
    branch_info=$(get_branch_info "$path" "$branch")
    IFS='|' read -r remote tracking <<< "$branch_info"

    if [[ "$branch" != "detached" ]]; then
      printf "├─ Branch: %s" "$branch"
      if [[ -n "$remote" ]]; then
        printf " (%s%s)" "$remote" "$tracking"
      fi
      printf "\n"
    else
      printf "├─ Branch: detached HEAD\n"
    fi

    printf "├─ Path: %s\n" "$path"

    # Get status details
    local status_details
    status_details=$(get_status_details "$path" "$dirty")
    printf "├─ Status: %s\n" "$status_details"

    # Worktree configuration
    printf "└─ Config: "
    if [[ "$locked" == "true" ]]; then
      printf "Locked worktree"
    else
      printf "Standard worktree"
    fi
    if [[ "$branch" == "detached" ]]; then
      printf " (detached: yes)"
    else
      printf " (detached: no)"
    fi
    printf "\n\n"
  done
}

# Parse common flags to detect -- pattern and standard flags
eval "$(parse_common_flags "$@")"

# Initialize behavior flags
show_all=false

# Parse custom flags
while [[ $# -gt 0 ]]; do
  case "$1" in
    --all|-a)
      show_all=true
      shift
      ;;
    -h|--help)
      show_help
      exit 0
      ;;
    -*)
      error "Unknown option: $1"
      show_help
      exit 1
      ;;
    *)
      # Treat remaining arguments as search term
      break
      ;;
  esac
done

# Early exit if not in Git repo
check_git_repo

# Get current worktree path
current_worktree=$(get_current_worktree_path)

# Get worktree paths
declare -a worktree_paths=()
declare -a branches=()
declare -a commits=()
declare -a status_dirty=()
declare -a locked_status=()

if ! get_worktrees worktree_paths branches commits status_dirty locked_status; then
  printf "No worktrees found.\n" >&2
  exit 1
fi

# Handle different command modes
if [[ "${HUG_INTERACTIVE_FILE_SELECTION:-}" == "true" ]]; then
  interactive_worktree_selection "$current_worktree" "${worktree_paths[@]}"
elif [[ "$show_all" == "false" && $# -eq 0 ]]; then
  # Default: show current worktree only
  show_current_worktree_only "$current_worktree"
elif [[ $# -gt 0 ]]; then
  # Multi-term search filtering (enhanced behavior)
  target_worktrees=()
  search_terms="$*"  # Capture all search terms

  for i in "${!worktree_paths[@]}"; do
    path="${worktree_paths[$i]}"
    branch="${branches[$i]}"

    # Use unified search function for multi-term filtering
    if search_worktree "$path" "$branch" "$search_terms" "OR"; then
      target_worktrees+=("$path")
    fi
  done

  if [[ ${#target_worktrees[@]} -eq 0 ]]; then
    printf "No worktrees found matching: %s\n" "$search_terms" >&2
    exit 1
  fi

  # Show details for matching worktrees
  show_worktree_details "$current_worktree" "${target_worktrees[@]}"
else
  # --all or -a behavior (existing default)
  show_worktree_details "$current_worktree" "${worktree_paths[@]}"
fi