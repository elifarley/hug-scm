#!/usr/bin/env bash
# Assume HUG_HOME is set (exported by hug or environment)
# shellcheck source=git-config/lib/hug-common
. "$HUG_HOME/git-config/lib/hug-common"
# shellcheck source=git-config/lib/hug-git-kit
. "$HUG_HOME/git-config/lib/hug-git-kit"
# shellcheck source=git-config/lib/hug-git-worktree
. "$HUG_HOME/git-config/lib/hug-git-worktree"
set -euo pipefail  # Exit on error, undefined vars, pipe failures
# Part of the Hug tool suite

show_help() {
    cat << 'EOF'
hug wtc: Create worktree for existing or new branch

USAGE:
    hug wtc [options]
    hug wtc <branch> [path] [options]
    hug wtc -h|--help

ARGUMENTS:
    [branch]        Name of branch to create worktree for. Can be existing or new branch. If omitted or `--`, interactive branch selection menu is displayed.
    [path]          Custom path for worktree (optional, auto-generated if not provided).

OPTIONS:
    -f, --force     Skip confirmation prompts and auto-create branches
    --dry-run       Show what would be done without creating the worktree
    --new           Automatically create branch if it doesn't exist
    -h, --help      Show this help

DESCRIPTION:
    Creates a new Git worktree for the specified branch. Worktrees allow you to
    work on multiple branches simultaneously without context switching overhead.

    If no path is provided, generates a smart default path outside the main
    repository: ../<repo>-worktrees/<branch>

    By default, the branch must exist locally. With --new flag or with --force,
    non-existent branches will be created automatically from the current HEAD.

    Interactive mode shows only branches that don't already have worktrees,
    preventing duplicate worktree creation errors.

EXAMPLES:
    hug wtc                                 # Interactive branch selection, auto-generated path
    hug wtc --                              # Interactive branch selection, auto-generated path
    hug wtc feature-auth                    # Create worktree for existing branch
    hug wtc feature-auth --new              # Create new branch and worktree
    hug wtc new-feature --new ~/work/feat   # Create new branch at custom path
    hug wtc missing-branch                  # Prompt to create branch if it doesn't exist
    hug wtc missing-branch -f               # Auto-create branch without prompting
    hug wtc feature-auth --dry-run          # Preview creation without doing it
    hug wtc feature-auth -f                 # Create without confirmation

SEE ALSO:
    hug wt      List and switch between worktrees
    hug wtdel   Remove worktree safely

FURTHER READING:
    See 'git worktree add --help' for underlying implementation details.
EOF
}

check_git_repo

# Parse arguments using getopt
set +e  # Temporarily disable exit on error to capture getopt failure
PARSED=$(getopt --options hf --longoptions help,force,dry-run,new --name "hug wtc" -- "$@" 2>&1)
getopt_status=$?
set -e  # Re-enable exit on error

if [ $getopt_status -ne 0 ]; then
  # getopt failed - print the error message if available
  if [ -n "$PARSED" ]; then
    echo "$PARSED" >&2
  fi
  exit 1
fi

eval set -- "$PARSED"

# Initialize variables
force=false
dry_run=false
new_branch=false

# Process options
while true; do
    case "$1" in
        -h|--help)
            show_help
            exit 0
            ;;
        -f|--force)
            force=true
            shift
            ;;
        --dry-run)
            dry_run=true
            shift
            ;;
        --new)
            new_branch=true
            shift
            ;;
        --)
            shift
            break
            ;;
        *)
            error "Internal error in option parsing"
            ;;
    esac
done

# Validate flag combinations
if $force && $dry_run; then
    error "Cannot use --force and --dry-run together. These flags are mutually exclusive."
    exit 1
fi

# Parse arguments
if [[ $# -eq 0 ]]; then
    # No arguments provided - show interactive branch selection
    branch_name=""
    worktree_path=""
elif [[ $# -eq 1 ]]; then
    if [[ "$1" == "--" ]]; then
        # Interactive branch selection
        branch_name=""
        worktree_path=""
    else
        # Branch name provided
        branch_name="$1"
        worktree_path=""
    fi
elif [[ $# -eq 2 ]]; then
    if [[ "$1" == "--" ]]; then
        # Interactive branch selection, custom path provided
        branch_name=""
        worktree_path="$2"
    else
        # Branch name and path both provided
        branch_name="$1"
        worktree_path="$2"
    fi
elif [[ $# -gt 2 ]]; then
    error "Too many arguments. Usage: hug wtc [branch] [path]. See 'hug wtc --help'."
    exit 1
fi

# Interactive branch selection if needed
if [[ -z "$branch_name" ]]; then
    # Show interactive branch selection using existing branch menu functions
    declare -a branches=() hashes=() subjects=() tracks=()
    max_len=""
    current_branch=""
    selected_branch=""

    if ! compute_local_branch_details current_branch max_len hashes branches tracks subjects "true"; then
        error "No local branches found."
        exit 1
    fi

    # Filter out branches that already have worktrees
    declare -a available_branches=() available_hashes=() available_subjects=() available_tracks=()
    for ((i=0; i<${#branches[@]}; i++)); do
        branch="${branches[i]}"
        if branch_available_for_worktree "$branch"; then
            available_branches+=("$branch")
            available_hashes+=("${hashes[i]}")
            available_subjects+=("${subjects[i]}")
            available_tracks+=("${tracks[i]}")
        fi
    done

    if [[ ${#available_branches[@]} -eq 0 ]]; then
        error "All branches already have worktrees. Use 'hug wtl' to see existing worktrees."
        exit 1
    fi

    # Print interactive menu and get selection
    print_interactive_branch_menu selected_branch "$current_branch" "$max_len" available_hashes available_branches available_tracks available_subjects

    # If user cancelled, print a message and exit
    if [[ -z "$selected_branch" ]]; then
        info "Worktree creation cancelled."
        exit 0
    fi

    branch_name="$selected_branch"
fi

# Create branch if needed (for non-interactive mode)
if [[ -n "$branch_name" ]]; then
    if ! create_branch_if_needed "$branch_name" "$new_branch" "$force"; then
        error "Branch creation cancelled or failed."
        exit 1
    fi
fi

# Generate path if not provided
if [[ -z "$worktree_path" ]]; then
    worktree_path=$(generate_worktree_path "$branch_name")

    # Ensure path is unique (handle conflicts)
    if [[ -e "$worktree_path" ]]; then
        worktree_path=$(generate_unique_worktree_path "$branch_name")
        info "Default path exists, using: $worktree_path"
    fi
fi

# Convert relative path to absolute for validation
if [[ ! "$worktree_path" = /* ]]; then
    worktree_path="$(pwd)/$worktree_path"
fi

# Show what we're about to do
echo
printf "${BLUE}Worktree Creation Summary:${NC}\n"
printf "  Branch: %s\n" "$branch_name"
printf "  Path: %s\n" "${worktree_path/#$HOME/\~}"
if "$dry_run"; then
    printf "  Mode: %s\n" "DRY RUN"
else
    printf "  Mode: %s\n" "CREATE"
fi
echo

# Perform the creation
create_worktree "$branch_name" "$worktree_path" "$force" "$dry_run"
