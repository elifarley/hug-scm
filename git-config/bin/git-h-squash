#!/usr/bin/env bash
CMD_BASE="$(readlink -f "$0" 2>/dev/null || greadlink -f "$0")" || CMD_BASE="$0"; CMD_BASE="$(dirname "$CMD_BASE")"
for f in hug-common hug-git-kit; do . "$CMD_BASE/../lib/$f"; done
set -euo pipefail  # Exit on error, undefined vars, pipe failures
# Part of the Hug tool suite

show_help() {
    cat << EOF
hug h squash: Squashes specific commits into 1 with original messages combined.

USAGE:
    hug h squash [--quiet] [--force] [target]

OPTIONS:
    [target]        Either empty, an integer N > 1, a COMMIT hash, or -u, --upstream
        (empty)         The last 2 commits will be squashed.
        N               The last N commits will be squashed.
        COMMIT          All commits above the target commit will be squashed.
        -u, --upstream  Local-only commits (those above the upstream HEAD - the remote tip) will be squashed after read-only preview/confirmation (no fetch)
    --quiet         Suppress output
    --force         Skip confirmation prompts (use with caution)

DESCRIPTION:
    Without [target], defaults to squashing the last 2 commits into 1 (intuitive for combining recent work
    from the *last commit* with the *previous commit*).
    HEAD goes back to target (like 'h back'), then commits changes from the target commits using the original HEAD's message.
    Non-destructive to uncommitted work.
    Pre-existing staged changes will be included - review with `hug ss` first.

EXAMPLES:
    hug h squash                   # Squash last 2 commits into 1
    hug h squash 3                 # Squash last 3 commits into 1
    hug h squash a1b2c3            # Keep a1b2c3 unchanged; Squash all commits above it into 1
    hug h squash -u                # Keep upstream tip unchanged; Squash local-only commits on top
    hug h squash 3 --force         # Skip confirmation

SEE ALSO:
    hug h back    HEAD goes back only (no auto-commit)
    hug c         commit staged changes
EOF
}

# Parse common flags (--quiet, --force, -h|--help)
eval "$(parse_common_flags "$@")"

# Parse custom flags
upstream=false
target_arg=""
while [[ $# -gt 0 ]]; do
  case "$1" in
    -u|--upstream) upstream=true; shift ;;
    *) target_arg="$1"; shift ;;
  esac
done

if $upstream && [[ -n "$target_arg" ]]; then
  error "Cannot specify both -u/--upstream and a target (N|COMMIT)."
fi

check_git_repo

# Capture original HEAD message BEFORE any reset
original_head=$(git rev-parse HEAD)

if $upstream; then
  # handle_upstream_operation performs a read-only preview/confirmation and echoes the upstream commit.
  # When the staging area is clean we temporarily set HUG_FORCE to bypass the confirmation prompt.
  if [[ ${HUG_FORCE:-} == true ]]; then
    target=$(handle_upstream_operation "squashing")
  elif has_staged_changes; then
    target=$(handle_upstream_operation "squashing")
  else
    info "No staged changes detected; skipping confirmation."
    target=$(HUG_FORCE=true handle_upstream_operation "squashing")
  fi
  commits_to_squash=$(count_commits_in_range "$target" HEAD)
else
  target_spec=$(resolve_head_target "${target_arg:-}" 'HEAD~2')
  ensure_ancestor_of_head "$target_spec" "cannot squash onto it."
  target_commit=$(git rev-parse "${target_spec}^{commit}")
  log_range="$target_commit"..HEAD
  # short hash
  target_display=$(git rev-parse --short "$target_commit" 2>/dev/null || echo "$target_spec")
  commits_to_squash=$(count_commits_in_range "$target_commit" HEAD)
  if [ "$commits_to_squash" -eq 0 ]; then
    info "No commits to squash (already at $target_display)."
    exit 0
  fi
  commit_word="commit"
  if [ "$commits_to_squash" -gt 1 ]; then
    commit_word="commits"
  fi
  if [[ ${HUG_QUIET:-} != T ]]; then
    printf 'Commits to be squashed:\n' >&2
    print_commit_list_in_range "$target_commit" HEAD >&2
    printf '\nPreview: changes in %d %s.\n' >&2 \
      "$commits_to_squash" "$commit_word"
    git diff --stat "$log_range" >&2
  fi

  should_prompt=true
  if [[ ${HUG_FORCE:-} == true ]]; then
    should_prompt=false
  elif ! has_staged_changes; then
    should_prompt=false
    info "No staged changes detected; skipping confirmation."
  fi

  if $should_prompt; then
    if [[ -z "${target_arg:-}" || "${target_arg:-}" =~ ^[0-9]+$ ]]; then
      prompt_confirm "Proceed with squash of last $commits_to_squash $commit_word (hug back + hug c)? [y/N]: "
    else
      prompt_confirm "Proceed with squash up to $target_display (hug back + hug c)? [y/N]: "
    fi
  fi
  target="$target_commit"
fi

# Collect all commit messages from the commits to be squashed, in reverse order
combined_messages=$(git log --format='--squash--%n- %B' --reverse "$target..HEAD" 2>/dev/null | tail -n +2 || echo "Squashed commits")

back_cmd="hug h back $target --quiet --force"
$back_cmd

# Check for staged changes (hug c will handle, but warn if none)
if ! has_staged_changes; then
  warn "No changes staged after reset. Skipping commit (empty squash?)."
  target_display=$(git rev-parse --short "$target" 2>/dev/null || echo "$target")
  info "HEAD moved to $target_display."
  exit 0
fi

# Commit with messages collected from all abandoned commits
hug c -m "[squash] $commits_to_squash commitsâ€¦" -m "" -m "$combined_messages"

test "${HUG_QUIET:-f}" = T && exit

target_display=$(git rev-parse --short "$target" 2>/dev/null || echo "$target")
summary_word="commit"
if [ "$commits_to_squash" -gt 1 ]; then
  summary_word="commits"
fi
info "Squash complete: $commits_to_squash $summary_word combined into 1 with parent '$target_display'."
tip 'Use `hug cm` to change the commit message of the last commit.'
