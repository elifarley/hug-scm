#!/usr/bin/env bash
CMD_BASE="$(readlink -f "$0" 2> /dev/null || greadlink -f "$0")" || CMD_BASE="$0"
CMD_BASE="$(dirname "$CMD_BASE")"
for f in hug-common hug-git-kit hug-select-files; do . "$CMD_BASE/../lib/$f"; done
set -euo pipefail # Exit on error, undefined vars, pipe failures
# Part of the Hug tool suite

show_help() {
  cat << EOF
hug h squash: Squashes specific commits into 1 with original messages combined.

USAGE:
    hug h squash [OPTIONS] [target]

TARGET:
    (empty)         Squash the last 2 commits (default)
    N               Squash the last N commits
    COMMIT          Squash all commits above the target commit
    -u, --upstream  Squash local-only commits (above upstream HEAD)
    -t, --temporal TIME
                    Squash commits from TIME to HEAD
                    TIME: relative ("3 days ago") or absolute ("2024-01-15")

MESSAGE OPTIONS:
    -i, --initial-message
                    Use first (oldest) squashed commit's full message
    -m, --message MSG
                    Use provided message directly
    -e, --edit      Open editor to edit commit message

BEHAVIOR FLAGS:
    --quiet         Suppress output
    --force         Skip confirmation prompts (use with caution)

SCRIPTING FLAGS:
    --abort-if-staged
                    Abort immediately if staged changes exist, avoiding
                    interactive prompts. Use in scripts when you want to
                    squash commits without accidentally including staged work.
                    Exits with code 1, showing the staged files.

DESCRIPTION:
    Squashes commits into one, combining their changes. HEAD goes back to target
    (like 'h back'), then commits all changes using the specified message strategy.

    Pre-existing staged changes are included in the squash. Use --abort-if-staged
    in scripts to prevent this, or review with 'hug ss' interactively.

EXAMPLES:
    hug h squash                       # Squash last 2 commits
    hug h squash 3                     # Squash last 3 commits
    hug h squash 3 -i                  # Use first commit's message
    hug h squash 3 -m "feat: xyz"      # Use custom message
    hug h squash 3 -e                  # Edit message in editor
    hug h squash a1b2c3                # Squash commits above a1b2c3
    hug h squash -u                    # Squash local-only commits
    hug h squash -t "3 days ago"       # Squash commits from 3 days ago
    hug h squash 3 --abort-if-staged   # Abort if staged changes (scripting)

SEE ALSO:
    hug h back    HEAD goes back only (no auto-commit)
    hug c         commit staged changes
    hug cm        amend last commit message
    hug ss        show staged changes (diff)
    hug sl        list staged and unstaged files
EOF
}

# Parse common flags (--quiet, --force, -h|--help)
eval "$(parse_common_flags "$@")"

# Parse temporal flag
eval "$(parse_temporal_flag "$@")"

# Parse remaining custom flags
upstream=false
use_initial_message=false
custom_message=""
open_editor=false
abort_if_staged=false
target_arg=""
while [[ $# -gt 0 ]]; do
  case "$1" in
  -u | --upstream)
    upstream=true
    shift
    ;;
  -i | --initial-message)
    use_initial_message=true
    shift
    ;;
  -m | --message)
    if [[ $# -lt 2 || "$2" == -* ]]; then
      error "-m/--message requires a commit message argument"
    fi
    custom_message="$2"
    shift 2
    ;;
  -e | --edit)
    open_editor=true
    shift
    ;;
  --abort-if-staged)
    abort_if_staged=true
    shift
    ;;
  *)
    target_arg="$1"
    shift
    ;;
  esac
done

check_git_repo

# Validate flag combinations
if [[ -n "$custom_message" && "$open_editor" == true ]]; then
  error "Cannot use -m/--message and -e/--edit together (conflicting options)"
fi

if [[ -n "$custom_message" && "$use_initial_message" == true ]]; then
  error "Cannot use -m/--message and -i/--initial-message together (conflicting options)"
fi

# Scripting flag: early abort if staged changes exist
if $abort_if_staged && has_staged_changes; then
  printf 'ðŸš« Aborting: staged changes detected (--abort-if-staged)\n' >&2
  printf '\nðŸ“¦ Staged files:\n' >&2
  list_files_with_status --staged >&2 2> /dev/null || true
  printf '\n' >&2
  hug s >&2
  exit 1
fi

# Capture original HEAD message BEFORE any reset
original_head=$(git rev-parse HEAD)

if $upstream; then
  # Use DRY helper for validation, then handle upstream-specific logic
  resolve_target_with_temporal "$upstream" "$temporal_spec" "$target_arg" 'HEAD~2' > /dev/null || exit 1

  # handle_upstream_operation performs a read-only preview/confirmation and echoes the upstream commit.
  # When the staging area is clean we temporarily set HUG_FORCE to bypass the confirmation prompt.
  if [[ ${HUG_FORCE:-} == true ]]; then
    target=$(handle_upstream_operation "squashing")
  elif has_staged_changes; then
    target=$(handle_upstream_operation "squashing")
  else
    info "No staged changes detected; skipping confirmation."
    target=$(HUG_FORCE=true handle_upstream_operation "squashing")
  fi
  commits_to_squash=$(count_commits_in_range "$target" HEAD)
else
  # Use DRY helper for validation and target resolution
  target_commit=$(resolve_target_with_temporal "$upstream" "$temporal_spec" "$target_arg" 'HEAD~2') || exit 1

  # Common logic for temporal and explicit targets
  ensure_ancestor_of_head "$target_commit" "cannot squash onto it."
  log_range="$target_commit"..HEAD
  target_display=$(git rev-parse --short "$target_commit" 2> /dev/null || echo "$target_commit")
  commits_to_squash=$(count_commits_in_range "$target_commit" HEAD)
  if [ "$commits_to_squash" -eq 0 ]; then
    info "No commits to squash (already at $target_display)."
    exit 0
  fi
  commit_word="commit"
  if [ "$commits_to_squash" -gt 1 ]; then
    commit_word="commits"
  fi
  if [[ ${HUG_QUIET:-} != T ]]; then
    printf 'Commits to be squashed:\n' >&2
    print_commit_list_in_range "$target_commit" HEAD >&2
    printf '\nPreview: changes in %d %s.\n' \
      "$commits_to_squash" "$commit_word" >&2

    git diff --stat "$log_range" >&2
  fi

  should_prompt=true
  if [[ ${HUG_FORCE:-} == true ]]; then
    should_prompt=false
  elif ! has_staged_changes; then
    should_prompt=false
    info "No staged changes detected; skipping confirmation."
  fi

  if $should_prompt; then
    # Show staged files info when prompting
    printf '\nðŸ“¦ Pre-existing staged files (will be included in squash):\n' >&2
    list_files_with_status --staged >&2 2> /dev/null || true
    printf '\n' >&2
    hug s >&2
    printf '\n' >&2
    warn "These staged files will become part of the squashed commit together with the changes from the commits being squashed."
    printf '\n' >&2

    if [[ -z "${target_arg:-}" || "${target_arg:-}" =~ ^[0-9]+$ ]]; then
      prompt_confirm_warn "Proceed with squash of last $commits_to_squash $commit_word (hug back + hug c)? [y/N]: "
    else
      prompt_confirm_warn "Proceed with squash up to $target_display (hug back + hug c)? [y/N]: "
    fi
  fi
  target="$target_commit"
fi

# Determine the commit message based on flags
if [[ -n "$custom_message" ]]; then
  # User provided message directly via -m flag
  final_message="$custom_message"
elif $open_editor; then
  # User wants to edit the message in an editor
  if $use_initial_message; then
    # Pre-populate editor with first squashed commit message
    temp_file=$(mktemp)
    first_commit=$(get_first_child_commit "$target")
    git log -1 --format='%B' "$first_commit" > "$temp_file"
    ${EDITOR:-vi} "$temp_file" || error "Editor exited with non-zero status"
    final_message=$(cat "$temp_file")
    rm -f "$temp_file"
  else
    # Open editor with concatenated messages
    temp_file=$(mktemp)
    combined_messages=$(git log --format='--squash--%n- %B' --reverse "$target..HEAD" 2> /dev/null | tail -n +2 || echo "Squashed commits")
    printf "[squash] %d commitsâ€¦\n\n%s" "$commits_to_squash" "$combined_messages" > "$temp_file"
    ${EDITOR:-vi} "$temp_file" || error "Editor exited with non-zero status"
    final_message=$(cat "$temp_file")
    rm -f "$temp_file"
  fi
elif $use_initial_message; then
  # Use first (oldest) squashed commit's full message (subject + body + footers)
  # Use efficient child lookup for squash operations
  first_commit=$(get_first_child_commit "$target")
  if [[ -z "$first_commit" ]]; then
    error "No commits found in squash range"
    exit 1
  fi
  final_message=$(git log -1 --format='%B' "$first_commit")
else
  # Default: concatenate all commit messages
  combined_messages=$(git log --format='--squash--%n- %B' --reverse "$target..HEAD" 2> /dev/null | tail -n +2 || echo "Squashed commits")
  final_message="[squash] $commits_to_squash commitsâ€¦"$'\n\n'"$combined_messages"
fi

back_cmd="hug h back $target --quiet --force"
$back_cmd

# Check for staged changes (hug c will handle, but warn if none)
if ! has_staged_changes; then
  warn "No changes staged after reset. Skipping commit (empty squash?)."
  target_display=$(git rev-parse --short "$target" 2> /dev/null || echo "$target")
  info "HEAD moved to $target_display."
  exit 0
fi

# Commit with the final message
hug c -m "$final_message"

test "${HUG_QUIET:-f}" = T && exit

target_display=$(git rev-parse --short "$target" 2> /dev/null || echo "$target")
summary_word="commit"
if [ "$commits_to_squash" -gt 1 ]; then
  summary_word="commits"
fi
info "Squash complete: $commits_to_squash $summary_word combined into 1 with parent '$target_display'."
tip 'Use `hug cm` to change the commit message of the last commit.'
