#!/usr/bin/env bash
CMD_BASE="$(readlink -f "$0" 2>/dev/null || greadlink -f "$0")" || CMD_BASE="$0"; CMD_BASE="$(dirname "$CMD_BASE")"
for f in hug-common hug-git-kit; do . "$CMD_BASE/../lib/$f"; done # Load common constants and functions
set -euo pipefail  # Exit on error, undefined vars, pipe failures

# Part of the Hug tool suite

show_help() {
  cat <<'EOF'
hug bpush: Push the current branch and set upstream tracking.

USAGE:
  hug bpush [OPTIONS]
  hug bpush [OPTIONS] <remote-name>
  hug bpush [OPTIONS] <url>
  hug bpush [OPTIONS] <remote-name> <url>

OPTIONS:
  -u, --update   Update the URL of an existing remote when needed.
  -f, --force    Force-push (using git --force-with-lease)
      --unsafe   Force-push, unsafe (using git --force)
  -t, --track    Set or switch upstream tracking to the target remote (default: preserve existing unless auto-setup applies).
  -h, --help     Show this help message and exit.

DESCRIPTION:
  Without arguments the command pushes to the 'origin' remote. Supplying a
  single URL will create or update a matching remote and push to it. Supplying
  both a remote name and URL allows you to explicitly manage the remote.

EXAMPLES:
  hug bpush
  hug bpush upstream
  hug bpush git@github.com:owner/repo.git
  hug bpush --update origin https://github.com/owner/repo
EOF
}

error() {
  printf 'hug bpush: %s\n' "$1" >&2
  exit "${2:-1}"
}

usage_error() {
  printf 'hug bpush: %s\n\n' "$1" >&2
  show_help >&2
  exit 1
}

remote_exists() {
  local name="$1"
  git remote | grep -qxF "$name"
}

derive_remote_name() {
  local url="$1"
  local trimmed="${url%/}"
  local name
  name="$(basename "$trimmed" .git)"
  if [ -z "$name" ]; then
    name="origin"
  fi
  printf '%s\n' "$name"
}

is_url() {
  [[ "$1" =~ ^(git@|ssh://|https?://|git://|file://).*(\.git)?$ ]]
}

normalize_url() {
  local u="$1"
  u="${u%/}"
  if [[ "$u" != *.git ]]; then
    u="${u}.git"
  fi
  printf '%s\n' "$u"
}

find_remote_by_url() {
  local target="$1"
  local remote candidate
  while IFS= read -r remote; do
    while IFS= read -r candidate; do
      candidate="$(normalize_url "$candidate")"
      if [ "$candidate" = "$target" ]; then
        printf '%s\n' "$remote"
        return 0
      fi
    done < <(git remote get-url --all "$remote")
  done < <(git remote)
  return 1
}

get_upstream_remote() {
  local upstream
  if upstream="$(git rev-parse --abbrev-ref --symbolic-full-name @{upstream} 2>/dev/null)"; then
    # Extract remote from upstream ref (e.g., "refs/remotes/origin/main" -> "origin")
    printf '%s\n' "${upstream#refs/remotes/}" | cut -d/ -f1
    return 0
  fi
  return 1
}

has_upstream_for_target() {
  local target_remote="$1"
  local target_branch="$2"
  local current_upstream
  if current_upstream="$(git rev-parse --abbrev-ref --symbolic-full-name @{upstream} 2>/dev/null)"; then
    [[ "$current_upstream" == "refs/remotes/$target_remote/$target_branch" ]]
  else
    return 1
  fi
}

suggest_setup() {
  cat <<'EOF' >&2
No upstream tracking or 'origin' remote found. Suggestions:
  - Add and push to 'origin': hug bpush origin <url>
  - Push to an existing remote with tracking: hug bpush -t <remote>
  - Or push to a new remote with tracking: hug bpush -t <remote> <url>
EOF
  exit 1
}

# Early exit if not in Git repo
check_git_repo

branch="$(git branch --show-current)"
if [ -z "$branch" ]; then
  error "Cannot determine the current branch (detached HEAD?)."
fi

# Parse arguments using getopt
set +e  # Temporarily disable exit on error to capture getopt failure
PARSED=$(getopt --options huft --longoptions help,update,force,unsafe,track --name "hug bpush" -- "$@" 2>&1)
getopt_status=$?
set -e  # Re-enable exit on error

if [ $getopt_status -ne 0 ]; then
  # getopt failed - print the error message if available
  if [ -n "$PARSED" ]; then
    echo "$PARSED" >&2
  fi
  exit 1
fi

eval set -- "$PARSED"

update=false
force_safe=false
force_unsafe=false
track=false

while true; do
  case "$1" in
    -h|--help)
      show_help
      exit 0
      ;;
    -u|--update)
      update=true
      shift
      ;;
    -f|--force)
      force_safe=true
      shift
      ;;
    --unsafe)
      force_unsafe=true
      shift
      ;;
    -t|--track)
      track=true
      shift
      ;;
    --)
      shift
      break
      ;;
    *)
      error "Internal error in option parsing"
      ;;
  esac
done

if $force_safe && $force_unsafe; then
  usage_error "Cannot specify both --force and --unsafe."
fi

remote="origin"
is_url_arg=false
is_remote_name_arg=false

case $# in
  0)
    if upstream_remote="$(get_upstream_remote)"; then
      remote="$upstream_remote"
      printf "Pushing to existing upstream remote '%s'...\n" "$remote"
      should_set_upstream=false
    elif remote_exists "origin"; then
      remote="origin"
      printf "No upstream; pushing to default 'origin'...\n"
      should_set_upstream=true
    else
      error "No upstream or 'origin' remote. See suggestions below."
      suggest_setup
    fi
    ;;
  1)
    arg="$1"
    if is_url "$arg"; then
      is_url_arg=true
      url="$(normalize_url "$arg")"
      if existing_remote="$(find_remote_by_url "$url")"; then
        remote="$existing_remote"
        printf "Using existing remote '%s' (%s)\n" "$remote" "$url"
      else
        derived="$(derive_remote_name "$url")"
        if remote_exists "$derived"; then
          if $update; then
            printf "Updating URL for existing remote '%s'\n" "$derived"
            git remote set-url "$derived" "$url"
            remote="$derived"
          else
            usage_error "Derived remote name '$derived' already exists but points to a different URL. Use --update or provide a remote name."
          fi
        else
          if [ -z "$(git remote)" ]; then
            derived="origin"
          fi
          printf "Adding remote '%s' for %s\n" "$derived" "$url"
          git remote add "$derived" "$url"
          remote="$derived"
        fi
      fi
    else
      is_remote_name_arg=true
      remote="$arg"
      if ! remote_exists "$remote"; then
        error "Remote '$remote' not found."
      fi
    fi
    ;;
  2)
    remote="$1"
    url="$(normalize_url "$2")"
    if ! [[ "$remote" =~ ^[A-Za-z0-9._-]+$ ]]; then
      usage_error "Invalid remote name '$remote'."
    fi
    if remote_exists "$remote"; then
      existing_url="$(normalize_url "$(git remote get-url --all "$remote" | head -n1)")"
      if [ "$existing_url" != "$url" ]; then
        if $update; then
          printf "Updating URL for '%s' to %s\n" "$remote" "$url"
          git remote set-url "$remote" "$url"
        else
          usage_error "Remote '$remote' points to '$existing_url', not '$url'. Use --update."
        fi
      else
        printf "Remote '%s' already points to %s\n" "$remote" "$url"
      fi
    else
      printf "Adding remote '%s' for %s\n" "$remote" "$url"
      git remote add "$remote" "$url"
    fi
    ;;
  *)
    usage_error "Too many positional arguments."
    ;;
esac

# Determine if we should set upstream (-u)
should_set_upstream=false
has_upstream=false
if get_upstream_remote >/dev/null 2>&1; then
  has_upstream=true
  if ! has_upstream_for_target "$remote" "$branch"; then
    # Has upstream but not for this target
    if $track; then
      should_set_upstream=true
      printf "Switching upstream tracking to '%s/%s'...\n" "$remote" "$branch"
    fi
  fi
else
  # No upstream at all
  if $track || ($is_remote_name_arg && [ $# -eq 1 ]) || ([ $# -eq 0 ] && [ "$remote" = "origin" ]); then
    should_set_upstream=true
    printf "Setting upstream tracking to '%s/%s'...\n" "$remote" "$branch"
  fi
fi

if has_upstream_for_target "$remote" "$branch"; then
  printf "Pushing to existing upstream '%s/%s'...\n" "$remote" "$branch"
fi

push_args=()
if $should_set_upstream; then
  push_args+=("-u")
fi
if $force_unsafe; then
  push_args+=("--force")
  tracking_note="$( $should_set_upstream && echo ' with upstream tracking' || echo '' )"
  printf "Force-pushing branch '%s' to remote '%s' (unsafe)%s...\n" "$branch" "$remote" "$tracking_note"
elif $force_safe; then
  push_args+=("--force-with-lease")
  tracking_note="$( $should_set_upstream && echo ' with upstream tracking' || echo '' )"
  printf "Force-pushing branch '%s' to remote '%s' (safe)%s...\n" "$branch" "$remote" "$tracking_note"
else
  tracking_note="$( $should_set_upstream && echo ' with upstream tracking' || echo '' )"
  printf "Pushing branch '%s' to remote '%s'%s...\n" "$branch" "$remote" "$tracking_note"
fi
push_args+=("$remote" "$branch")
exec git push "${push_args[@]}"
